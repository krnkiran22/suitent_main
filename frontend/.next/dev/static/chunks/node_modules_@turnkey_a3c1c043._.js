(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@turnkey/sdk-types/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AuthAction",
    ()=>AuthAction,
    "FiatOnRampBlockchainNetwork",
    ()=>FiatOnRampBlockchainNetwork,
    "FiatOnRampCryptoCurrency",
    ()=>FiatOnRampCryptoCurrency,
    "FiatOnRampCurrency",
    ()=>FiatOnRampCurrency,
    "FiatOnRampPaymentMethod",
    ()=>FiatOnRampPaymentMethod,
    "FiatOnRampProvider",
    ()=>FiatOnRampProvider,
    "OAuthProviders",
    ()=>OAuthProviders,
    "SessionType",
    ()=>SessionType,
    "TurnkeyError",
    ()=>TurnkeyError,
    "TurnkeyErrorCodes",
    ()=>TurnkeyErrorCodes,
    "TurnkeyNetworkError",
    ()=>TurnkeyNetworkError
]);
var SessionType;
(function(SessionType) {
    SessionType["READ_ONLY"] = "SESSION_TYPE_READ_ONLY";
    SessionType["READ_WRITE"] = "SESSION_TYPE_READ_WRITE";
})(SessionType || (SessionType = {}));
var AuthAction;
(function(AuthAction) {
    AuthAction["LOGIN"] = "LOGIN";
    AuthAction["SIGNUP"] = "SIGNUP";
})(AuthAction || (AuthAction = {}));
var TurnkeyErrorCodes;
(function(TurnkeyErrorCodes) {
    TurnkeyErrorCodes["UNKNOWN"] = "UNKNOWN";
    TurnkeyErrorCodes["NETWORK_ERROR"] = "NETWORK_ERROR";
    TurnkeyErrorCodes["KEY_PAIR_CLEANUP_ERROR"] = "KEY_PAIR_CLEANUP_ERROR";
    TurnkeyErrorCodes["LOGOUT_ERROR"] = "LOGOUT_ERROR";
    TurnkeyErrorCodes["CREATE_PASSKEY_ERROR"] = "CREATE_PASSKEY_ERROR";
    TurnkeyErrorCodes["SELECT_PASSKEY_CANCELLED"] = "SELECT_PASSKEY_CANCELLED";
    TurnkeyErrorCodes["CONNECT_WALLET_CANCELLED"] = "CONNECT_WALLET_CANCELLED";
    TurnkeyErrorCodes["WALLET_CONNECT_INITIALIZATION_ERROR"] = "WALLET_CONNECT_INITIALIZATION_ERROR";
    TurnkeyErrorCodes["WALLET_CONNECT_EXPIRED"] = "WALLET_CONNECT_EXPIRED";
    TurnkeyErrorCodes["PASSKEY_SIGNUP_AUTH_ERROR"] = "PASSKEY_SIGNUP_AUTH_ERROR";
    TurnkeyErrorCodes["PASSKEY_LOGIN_AUTH_ERROR"] = "PASSKEY_LOGIN_AUTH_ERROR";
    TurnkeyErrorCodes["WALLET_BUILD_LOGIN_REQUEST_ERROR"] = "WALLET_BUILD_LOGIN_REQUEST_ERROR";
    TurnkeyErrorCodes["WALLET_LOGIN_AUTH_ERROR"] = "WALLET_LOGIN_AUTH_ERROR";
    TurnkeyErrorCodes["WALLET_SIGNUP_AUTH_ERROR"] = "WALLET_SIGNUP_AUTH_ERROR";
    TurnkeyErrorCodes["WALLET_LOGIN_OR_SIGNUP_ERROR"] = "WALLET_LOGIN_OR_SIGNUP_ERROR";
    TurnkeyErrorCodes["INIT_OTP_ERROR"] = "INIT_OTP_ERROR";
    TurnkeyErrorCodes["VERIFY_OTP_ERROR"] = "VERIFY_OTP_ERROR";
    TurnkeyErrorCodes["OTP_LOGIN_ERROR"] = "OTP_LOGIN_ERROR";
    TurnkeyErrorCodes["OTP_SIGNUP_ERROR"] = "OTP_SIGNUP_ERROR";
    TurnkeyErrorCodes["OTP_COMPLETION_ERROR"] = "OTP_COMPLETION_ERROR";
    TurnkeyErrorCodes["OAUTH_LOGIN_ERROR"] = "OAUTH_LOGIN_ERROR";
    TurnkeyErrorCodes["OAUTH_SIGNUP_ERROR"] = "OAUTH_SIGNUP_ERROR";
    TurnkeyErrorCodes["ACCOUNT_FETCH_ERROR"] = "ACCOUNT_FETCH_ERROR";
    TurnkeyErrorCodes["INVALID_OTP_CODE"] = "INVALID_OTP_CODE";
    TurnkeyErrorCodes["FETCH_WALLETS_ERROR"] = "FETCH_WALLETS_ERROR";
    TurnkeyErrorCodes["FETCH_WALLET_ACCOUNTS_ERROR"] = "FETCH_WALLET_ACCOUNTS_ERROR";
    TurnkeyErrorCodes["FETCH_PRIVATE_KEYS_ERROR"] = "FETCH_PRIVATE_KEYS_ERROR";
    TurnkeyErrorCodes["SIGN_MESSAGE_ERROR"] = "SIGN_MESSAGE_ERROR";
    TurnkeyErrorCodes["SIGN_TRANSACTION_ERROR"] = "SIGN_TRANSACTION_ERROR";
    TurnkeyErrorCodes["POLL_TRANSACTION_STATUS_ERROR"] = "POLL_TRANSACTION_STATUS_ERROR";
    TurnkeyErrorCodes["SIGN_AND_SEND_TRANSACTION_ERROR"] = "SIGN_AND_SEND_TRANSACTION_ERROR";
    TurnkeyErrorCodes["ETH_SEND_TRANSACTION_ERROR"] = "ETH_SEND_TRANSACTION_ERROR";
    TurnkeyErrorCodes["FETCH_USER_ERROR"] = "FETCH_USERS_ERROR";
    TurnkeyErrorCodes["CREATE_WALLET_ERROR"] = "CREATE_WALLET_ERROR";
    TurnkeyErrorCodes["CREATE_WALLET_ACCOUNT_ERROR"] = "CREATE_WALLET_ACCOUNT_ERROR";
    TurnkeyErrorCodes["EXPORT_WALLET_ERROR"] = "EXPORT_WALLET_ERROR";
    TurnkeyErrorCodes["EXPORT_PRIVATE_KEY_ERROR"] = "EXPORT_PRIVATE_KEY_ERROR";
    TurnkeyErrorCodes["EXPORT_WALLET_ACCOUNT_ERROR"] = "EXPORT_WALLET_ACCOUNT_ERROR";
    TurnkeyErrorCodes["IMPORT_WALLET_ERROR"] = "IMPORT_WALLET_ERROR";
    TurnkeyErrorCodes["DELETE_SUB_ORGANIZATION_ERROR"] = "DELETE_SUB_ORGANIZATION_ERROR";
    TurnkeyErrorCodes["CREATE_SUB_ORGANIZATION_ERROR"] = "CREATE_SUB_ORGANIZATION_ERROR";
    TurnkeyErrorCodes["CREATE_USERS_ERROR"] = "CREATE_USERS_ERROR";
    TurnkeyErrorCodes["FETCH_BOOT_PROOF_ERROR"] = "FETCH_BOOT_PROOF_ERROR";
    TurnkeyErrorCodes["VERIFY_APP_PROOFS_ERROR"] = "VERIFY_APP_PROOFS_ERROR";
    TurnkeyErrorCodes["CREATE_POLICY_ERROR"] = "CREATE_POLICY_ERROR";
    TurnkeyErrorCodes["STORE_SESSION_ERROR"] = "STORE_SESSION_ERROR";
    TurnkeyErrorCodes["CLEAR_SESSION_ERROR"] = "CLEAR_SESSION_ERROR";
    TurnkeyErrorCodes["CLEAR_ALL_SESSIONS_ERROR"] = "CLEAR_ALL_SESSIONS_ERROR";
    TurnkeyErrorCodes["REFRESH_SESSION_ERROR"] = "REFRESH_SESSION_ERROR";
    TurnkeyErrorCodes["GET_SESSION_ERROR"] = "GET_SESSION_ERROR";
    TurnkeyErrorCodes["GET_WALLET_PROVIDERS_ERROR"] = "GET_WALLET_PROVIDERS_ERROR";
    TurnkeyErrorCodes["GET_ALL_SESSIONS_ERROR"] = "GET_ALL_SESSIONS_ERROR";
    TurnkeyErrorCodes["SET_ACTIVE_SESSION_ERROR"] = "SET_ACTIVE_SESSION_ERROR";
    TurnkeyErrorCodes["GET_ACTIVE_SESSION_KEY_ERROR"] = "GET_ACTIVE_SESSION_KEY_ERROR";
    TurnkeyErrorCodes["CLEAR_UNUSED_KEY_PAIRS_ERROR"] = "CLEAR_UNUSED_KEY_PAIRS_ERROR";
    TurnkeyErrorCodes["CREATE_API_KEY_PAIR_ERROR"] = "CREATE_API_KEY_PAIR_ERROR";
    TurnkeyErrorCodes["GET_PROXY_AUTH_CONFIG_ERROR"] = "GET_PROXY_AUTH_CONFIG_ERROR";
    TurnkeyErrorCodes["UPDATE_USER_EMAIL_ERROR"] = "UPDATE_USER_EMAIL_ERROR";
    TurnkeyErrorCodes["UPDATE_USER_NAME_ERROR"] = "UPDATE_USER_NAME_ERROR";
    TurnkeyErrorCodes["UPDATE_USER_PHONE_NUMBER_ERROR"] = "UPDATE_USER_PHONE_NUMBER_ERROR";
    TurnkeyErrorCodes["ADD_OAUTH_PROVIDER_ERROR"] = "ADD_OAUTH_PROVIDER_ERROR";
    TurnkeyErrorCodes["REMOVE_OAUTH_PROVIDER_ERROR"] = "REMOVE_OAUTH_PROVIDER_ERROR";
    TurnkeyErrorCodes["ADD_PASSKEY_ERROR"] = "ADD_PASSKEY_ERROR";
    TurnkeyErrorCodes["REMOVE_PASSKEY_ERROR"] = "REMOVE_PASSKEY_ERROR";
    TurnkeyErrorCodes["CONNECT_WALLET_ACCOUNT_ERROR"] = "CONNECT_WALLET_ACCOUNT_ERROR";
    TurnkeyErrorCodes["DISCONNECT_WALLET_ACCOUNT_ERROR"] = "DISCONNECT_WALLET_ACCOUNT_ERROR";
    TurnkeyErrorCodes["SWITCH_WALLET_CHAIN_ERROR"] = "SWITCH_WALLET_CHAIN_ERROR";
    TurnkeyErrorCodes["ONRAMP_ERROR"] = "ONRAMP_ERROR";
    TurnkeyErrorCodes["MAX_OTP_INITIATED_ERROR"] = "MAX_OTP_INITIATED_ERROR";
    TurnkeyErrorCodes["CLIENT_NOT_INITIALIZED"] = "CLIENT_NOT_INITIALIZED";
    TurnkeyErrorCodes["WALLET_MANAGER_COMPONENT_NOT_INITIALIZED"] = "WALLET_MANAGER_COMPONENT_NOT_INITIALIZED";
    TurnkeyErrorCodes["CONFIG_NOT_INITIALIZED"] = "CONFIG_NOT_INITIALIZED";
    TurnkeyErrorCodes["AUTH_METHOD_NOT_ENABLED"] = "AUTH_METHOD_NOT_ENABLED";
    TurnkeyErrorCodes["FEATURE_NOT_ENABLED"] = "FEATURE_NOT_ENABLED";
    TurnkeyErrorCodes["INITIALIZE_CLIENT_ERROR"] = "INITIALIZE_CLIENT_ERROR";
    TurnkeyErrorCodes["INITIALIZE_SESSION_ERROR"] = "INITIALIZE_SESSION_ERROR";
    TurnkeyErrorCodes["SCHEDULE_SESSION_EXPIRY_ERROR"] = "SCHEDULE_SESSION_EXPIRY_ERROR";
    TurnkeyErrorCodes["HANDLE_POST_AUTH_ERROR"] = "HANDLE_POST_AUTH_ERROR";
    TurnkeyErrorCodes["HANDLE_POST_LOGOUT_ERROR"] = "HANDLE_POST_LOGOUT_ERROR";
    TurnkeyErrorCodes["CLEAR_SESSION_TIMEOUTS_ERROR"] = "CLEAR_SESSION_TIMEOUTS_ERROR";
    TurnkeyErrorCodes["UPDATE_USER_ERROR"] = "UPDATE_USER_ERROR";
    TurnkeyErrorCodes["ACCOUNT_ALREADY_EXISTS"] = "ACCOUNT_ALREADY_EXISTS";
    TurnkeyErrorCodes["INITIALIZE_IFRAME_ERROR"] = "INITIALIZE_IFRAME_ERROR";
    TurnkeyErrorCodes["PLATFORM_MISMATCH"] = "PLATFORM_MISMATCH";
    TurnkeyErrorCodes["UNSUPPORTED_PLATFORM"] = "UNSUPPORTED_PLATFORM";
    TurnkeyErrorCodes["USER_CANCELED"] = "USER_CANCELED";
    TurnkeyErrorCodes["BAD_RESPONSE"] = "BAD_RESPONSE";
    TurnkeyErrorCodes["OIDC_TOKEN_ERROR"] = "OIDC_TOKEN_ERROR";
    TurnkeyErrorCodes["MISSING_PARAMS"] = "MISSING_PARAMS";
    TurnkeyErrorCodes["INVALID_CONFIGURATION"] = "INVALID_CONFIGURATION";
    TurnkeyErrorCodes["INVALID_REQUEST"] = "INVALID_REQUEST";
    TurnkeyErrorCodes["VALIDATION_ERROR"] = "VALIDATION_ERROR";
    TurnkeyErrorCodes["SESSION_EXPIRED"] = "SESSION_EXPIRED";
    TurnkeyErrorCodes["NO_SESSION_FOUND"] = "NO_SESSION_FOUND";
    TurnkeyErrorCodes["NO_WALLET_FOUND"] = "NO_WALLET_FOUND";
    TurnkeyErrorCodes["NO_WALLETS_FOUND"] = "NO_WALLETS_FOUND";
    TurnkeyErrorCodes["NOT_FOUND"] = "NOT_FOUND";
    TurnkeyErrorCodes["INTERNAL_ERROR"] = "INTERNAL_ERROR";
    TurnkeyErrorCodes["UNAUTHORIZED"] = "UNAUTHORIZED";
    TurnkeyErrorCodes["FORBIDDEN"] = "FORBIDDEN";
    TurnkeyErrorCodes["BAD_REQUEST"] = "BAD_REQUEST";
    TurnkeyErrorCodes["CONFLICT"] = "CONFLICT";
    TurnkeyErrorCodes["TIMEOUT"] = "TIMEOUT";
    TurnkeyErrorCodes["SERVICE_UNAVAILABLE"] = "SERVICE_UNAVAILABLE";
    TurnkeyErrorCodes["GATEWAY_TIMEOUT"] = "GATEWAY_TIMEOUT";
})(TurnkeyErrorCodes || (TurnkeyErrorCodes = {}));
class TurnkeyError extends Error {
    constructor(message, code, cause){
        super(message);
        this.code = code;
        this.cause = cause;
        this.name = "TurnkeyError";
    }
}
class TurnkeyNetworkError extends TurnkeyError {
    constructor(message, statusCode, code, cause){
        super(message, code, cause);
        this.statusCode = statusCode;
        this.name = "TurnkeyNetworkError";
    }
}
var FiatOnRampProvider;
(function(FiatOnRampProvider) {
    FiatOnRampProvider["COINBASE"] = "FIAT_ON_RAMP_PROVIDER_COINBASE";
    FiatOnRampProvider["MOONPAY"] = "FIAT_ON_RAMP_PROVIDER_MOONPAY";
})(FiatOnRampProvider || (FiatOnRampProvider = {}));
var FiatOnRampCryptoCurrency;
(function(FiatOnRampCryptoCurrency) {
    FiatOnRampCryptoCurrency["BITCOIN"] = "FIAT_ON_RAMP_CRYPTO_CURRENCY_BTC";
    FiatOnRampCryptoCurrency["ETHEREUM"] = "FIAT_ON_RAMP_CRYPTO_CURRENCY_ETH";
    FiatOnRampCryptoCurrency["SOLANA"] = "FIAT_ON_RAMP_CRYPTO_CURRENCY_SOL";
    FiatOnRampCryptoCurrency["USDC"] = "FIAT_ON_RAMP_CRYPTO_CURRENCY_USDC";
})(FiatOnRampCryptoCurrency || (FiatOnRampCryptoCurrency = {}));
var FiatOnRampCurrency;
(function(FiatOnRampCurrency) {
    FiatOnRampCurrency["AUD"] = "FIAT_ON_RAMP_CURRENCY_AUD";
    FiatOnRampCurrency["BGN"] = "FIAT_ON_RAMP_CURRENCY_BGN";
    FiatOnRampCurrency["BRL"] = "FIAT_ON_RAMP_CURRENCY_BRL";
    FiatOnRampCurrency["CAD"] = "FIAT_ON_RAMP_CURRENCY_CAD";
    FiatOnRampCurrency["CHF"] = "FIAT_ON_RAMP_CURRENCY_CHF";
    FiatOnRampCurrency["COP"] = "FIAT_ON_RAMP_CURRENCY_COP";
    FiatOnRampCurrency["CZK"] = "FIAT_ON_RAMP_CURRENCY_CZK";
    FiatOnRampCurrency["DKK"] = "FIAT_ON_RAMP_CURRENCY_DKK";
    FiatOnRampCurrency["DOP"] = "FIAT_ON_RAMP_CURRENCY_DOP";
    FiatOnRampCurrency["EGP"] = "FIAT_ON_RAMP_CURRENCY_EGP";
    FiatOnRampCurrency["EUR"] = "FIAT_ON_RAMP_CURRENCY_EUR";
    FiatOnRampCurrency["GBP"] = "FIAT_ON_RAMP_CURRENCY_GBP";
    FiatOnRampCurrency["HKD"] = "FIAT_ON_RAMP_CURRENCY_HKD";
    FiatOnRampCurrency["IDR"] = "FIAT_ON_RAMP_CURRENCY_IDR";
    FiatOnRampCurrency["ILS"] = "FIAT_ON_RAMP_CURRENCY_ILS";
    FiatOnRampCurrency["JOD"] = "FIAT_ON_RAMP_CURRENCY_JOD";
    FiatOnRampCurrency["KES"] = "FIAT_ON_RAMP_CURRENCY_KES";
    FiatOnRampCurrency["KWD"] = "FIAT_ON_RAMP_CURRENCY_KWD";
    FiatOnRampCurrency["LKR"] = "FIAT_ON_RAMP_CURRENCY_LKR";
    FiatOnRampCurrency["MXN"] = "FIAT_ON_RAMP_CURRENCY_MXN";
    FiatOnRampCurrency["NGN"] = "FIAT_ON_RAMP_CURRENCY_NGN";
    FiatOnRampCurrency["NOK"] = "FIAT_ON_RAMP_CURRENCY_NOK";
    FiatOnRampCurrency["NZD"] = "FIAT_ON_RAMP_CURRENCY_NZD";
    FiatOnRampCurrency["OMR"] = "FIAT_ON_RAMP_CURRENCY_OMR";
    FiatOnRampCurrency["PEN"] = "FIAT_ON_RAMP_CURRENCY_PEN";
    FiatOnRampCurrency["PLN"] = "FIAT_ON_RAMP_CURRENCY_PLN";
    FiatOnRampCurrency["RON"] = "FIAT_ON_RAMP_CURRENCY_RON";
    FiatOnRampCurrency["SEK"] = "FIAT_ON_RAMP_CURRENCY_SEK";
    FiatOnRampCurrency["THB"] = "FIAT_ON_RAMP_CURRENCY_THB";
    FiatOnRampCurrency["TRY"] = "FIAT_ON_RAMP_CURRENCY_TRY";
    FiatOnRampCurrency["TWD"] = "FIAT_ON_RAMP_CURRENCY_TWD";
    FiatOnRampCurrency["USD"] = "FIAT_ON_RAMP_CURRENCY_USD";
    FiatOnRampCurrency["VND"] = "FIAT_ON_RAMP_CURRENCY_VND";
    FiatOnRampCurrency["ZAR"] = "FIAT_ON_RAMP_CURRENCY_ZAR";
})(FiatOnRampCurrency || (FiatOnRampCurrency = {}));
var FiatOnRampBlockchainNetwork;
(function(FiatOnRampBlockchainNetwork) {
    FiatOnRampBlockchainNetwork["BITCOIN"] = "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BITCOIN";
    FiatOnRampBlockchainNetwork["ETHEREUM"] = "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_ETHEREUM";
    FiatOnRampBlockchainNetwork["SOLANA"] = "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_SOLANA";
    FiatOnRampBlockchainNetwork["BASE"] = "FIAT_ON_RAMP_BLOCKCHAIN_NETWORK_BASE";
})(FiatOnRampBlockchainNetwork || (FiatOnRampBlockchainNetwork = {}));
var FiatOnRampPaymentMethod;
(function(FiatOnRampPaymentMethod) {
    // Shared methods (supported by both MoonPay and Coinbase)
    FiatOnRampPaymentMethod["CREDIT_DEBIT_CARD"] = "FIAT_ON_RAMP_PAYMENT_METHOD_CREDIT_DEBIT_CARD";
    FiatOnRampPaymentMethod["APPLE_PAY"] = "FIAT_ON_RAMP_PAYMENT_METHOD_APPLE_PAY";
    // MoonPay-specific methods
    FiatOnRampPaymentMethod["GBP_BANK_TRANSFER"] = "FIAT_ON_RAMP_PAYMENT_METHOD_GBP_BANK_TRANSFER";
    FiatOnRampPaymentMethod["GBP_OPEN_BANKING_PAYMENT"] = "FIAT_ON_RAMP_PAYMENT_METHOD_GBP_OPEN_BANKING_PAYMENT";
    FiatOnRampPaymentMethod["GOOGLE_PAY"] = "FIAT_ON_RAMP_PAYMENT_METHOD_GOOGLE_PAY";
    FiatOnRampPaymentMethod["SEPA_BANK_TRANSFER"] = "FIAT_ON_RAMP_PAYMENT_METHOD_SEPA_BANK_TRANSFER";
    FiatOnRampPaymentMethod["PIX_INSTANT_PAYMENT"] = "FIAT_ON_RAMP_PAYMENT_METHOD_PIX_INSTANT_PAYMENT";
    FiatOnRampPaymentMethod["PAYPAL"] = "FIAT_ON_RAMP_PAYMENT_METHOD_PAYPAL";
    FiatOnRampPaymentMethod["VENMO"] = "FIAT_ON_RAMP_PAYMENT_METHOD_VENMO";
    FiatOnRampPaymentMethod["MOONPAY_BALANCE"] = "FIAT_ON_RAMP_PAYMENT_METHOD_MOONPAY_BALANCE";
    // Coinbase-specific methods
    FiatOnRampPaymentMethod["CRYPTO_ACCOUNT"] = "FIAT_ON_RAMP_PAYMENT_METHOD_CRYPTO_ACCOUNT";
    FiatOnRampPaymentMethod["FIAT_WALLET"] = "FIAT_ON_RAMP_PAYMENT_METHOD_FIAT_WALLET";
    FiatOnRampPaymentMethod["ACH_BANK_ACCOUNT"] = "FIAT_ON_RAMP_PAYMENT_METHOD_ACH_BANK_ACCOUNT";
})(FiatOnRampPaymentMethod || (FiatOnRampPaymentMethod = {}));
var OAuthProviders;
(function(OAuthProviders) {
    OAuthProviders["DISCORD"] = "discord";
    OAuthProviders["APPLE"] = "apple";
    OAuthProviders["GOOGLE"] = "google";
    OAuthProviders["FACEBOOK"] = "facebook";
    OAuthProviders["X"] = "x";
})(OAuthProviders || (OAuthProviders = {}));
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@turnkey/encoding/dist/hex.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "hexToAscii",
    ()=>hexToAscii,
    "normalizePadding",
    ()=>normalizePadding,
    "uint8ArrayFromHexString",
    ()=>uint8ArrayFromHexString,
    "uint8ArrayToHexString",
    ()=>uint8ArrayToHexString
]);
/**
 * Converts a Uint8Array into a lowercase hex string.
 *
 * @param {Uint8Array} input - The input byte array.
 * @returns {string} - The resulting hex string.
 */ function uint8ArrayToHexString(input) {
    return input.reduce((result, x)=>result + x.toString(16).padStart(2, "0"), "");
}
/**
 * Creates a Uint8Array from a hex string.
 *
 * @param {string} hexString - The input hex string.
 * @param {number} [length] - Optional target length for the output. If specified,
 * the result will be padded with leading 0s or throw if it overflows.
 * @returns {Uint8Array} - The resulting byte array.
 * @throws {Error} - If the hex string is invalid or too long for the specified length.
 */ const uint8ArrayFromHexString = (hexString, length)=>{
    const hexRegex = /^[0-9A-Fa-f]+$/;
    if (!hexString || hexString.length % 2 != 0 || !hexRegex.test(hexString)) {
        throw new Error(`cannot create uint8array from invalid hex string: "${hexString}"`);
    }
    const buffer = new Uint8Array(hexString.match(/../g).map((h)=>parseInt(h, 16)));
    if (!length) {
        return buffer;
    }
    if (hexString.length / 2 > length) {
        throw new Error("hex value cannot fit in a buffer of " + length + " byte(s)");
    }
    // If a length is specified, ensure we sufficiently pad
    let paddedBuffer = new Uint8Array(length);
    paddedBuffer.set(buffer, length - buffer.length);
    return paddedBuffer;
};
/**
 * Converts a hex string to an ASCII string.
 * @param {string} hexString - The input hex string to convert.
 * @returns {string} - The converted ASCII string.
 */ function hexToAscii(hexString) {
    let asciiStr = "";
    for(let i = 0; i < hexString.length; i += 2){
        asciiStr += String.fromCharCode(parseInt(hexString.substr(i, 2), 16));
    }
    return asciiStr;
}
/**
 * Function to normalize padding of byte array with 0's to a target length.
 *
 * @param {Uint8Array} byteArray - The byte array to pad or trim.
 * @param {number} targetLength - The target length after padding or trimming.
 * @returns {Uint8Array} - The normalized byte array.
 */ const normalizePadding = (byteArray, targetLength)=>{
    const paddingLength = targetLength - byteArray.length;
    // Add leading 0's to array
    if (paddingLength > 0) {
        const padding = new Uint8Array(paddingLength).fill(0);
        return new Uint8Array([
            ...padding,
            ...byteArray
        ]);
    }
    // Remove leading 0's from array
    if (paddingLength < 0) {
        const expectedZeroCount = paddingLength * -1;
        let zeroCount = 0;
        for(let i = 0; i < expectedZeroCount && i < byteArray.length; i++){
            if (byteArray[i] === 0) {
                zeroCount++;
            }
        }
        // Check if the number of zeros found equals the number of zeroes expected
        if (zeroCount !== expectedZeroCount) {
            throw new Error(`invalid number of starting zeroes. Expected number of zeroes: ${expectedZeroCount}. Found: ${zeroCount}.`);
        }
        return byteArray.slice(expectedZeroCount, expectedZeroCount + targetLength);
    }
    return byteArray;
};
;
 //# sourceMappingURL=hex.mjs.map
}),
"[project]/node_modules/@turnkey/encoding/dist/base64.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "atob",
    ()=>atob,
    "base64StringToBase64UrlEncodedString",
    ()=>base64StringToBase64UrlEncodedString,
    "base64UrlToBase64",
    ()=>base64UrlToBase64,
    "decodeBase64urlToString",
    ()=>decodeBase64urlToString,
    "hexStringToBase64url",
    ()=>hexStringToBase64url,
    "stringToBase64urlString",
    ()=>stringToBase64urlString
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/hex.mjs [app-client] (ecmascript)");
;
/**
 * Code modified from https://github.com/github/webauthn-json/blob/e932b3585fa70b0bd5b5a4012ba7dbad7b0a0d0f/src/webauthn-json/base64url.ts#L23
 */ /**
 * Converts a plain string into a base64url-encoded string.
 *
 * @param {string} input - The input string to encode.
 * @returns {string} - The base64url-encoded string.
 */ function stringToBase64urlString(input) {
    // string to base64
    // we do not rely on the browser's btoa since it's not present in React Native environments
    const base64String = btoa(input);
    return base64StringToBase64UrlEncodedString(base64String);
}
/**
 * Converts a hex string into a base64url-encoded string.
 *
 * @param {string} input - The input hex string.
 * @param {number} [length] - Optional length for the resulting buffer. Pads with leading 0s if needed.
 * @returns {string} - The base64url-encoded representation of the hex string.
 * @throws {Error} - If the hex string is invalid or too long for the specified length.
 */ function hexStringToBase64url(input, length) {
    // Add an extra 0 to the start of the string to get a valid hex string (even length)
    // (e.g. 0x0123 instead of 0x123)
    const hexString = input.padStart(Math.ceil(input.length / 2) * 2, "0");
    const buffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(hexString, length);
    return stringToBase64urlString(buffer.reduce((result, x)=>result + String.fromCharCode(x), ""));
}
/**
 * Converts a base64 string into a base64url-encoded string.
 *
 * @param {string} input - The input base64 string.
 * @returns {string} - The base64url-encoded string.
 */ function base64StringToBase64UrlEncodedString(input) {
    return input.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
/**
 * Converts a base64url-encoded string into a standard base64-encoded string.
 *
 * - Replaces URL-safe characters (`-` and `_`) back to standard base64 characters (`+` and `/`).
 * - Pads the result with `=` to ensure the length is a multiple of 4.
 *
 * @param {string} input - The base64url-encoded string to convert.
 * @returns {string} - The equivalent base64-encoded string.
 */ function base64UrlToBase64(input) {
    let b64 = input.replace(/-/g, "+").replace(/_/g, "/");
    const padLen = (4 - b64.length % 4) % 4;
    return b64 + "=".repeat(padLen);
}
/**
 * Decodes a base64url-encoded string into a plain UTF-8 string.
 *
 * - Converts the input from base64url to base64.
 * - Decodes the base64 string into a plain string using a pure JS `atob` implementation.
 *
 * @param {string} input - The base64url-encoded string to decode.
 * @returns {string} - The decoded plain string.
 * @throws {Error} If the input is not correctly base64url/base64 encoded.
 */ function decodeBase64urlToString(input) {
    const b64 = base64UrlToBase64(input);
    return atob(b64);
}
// Pure JS implementation of btoa. This is adapted from the following:
// https://github.com/jsdom/abab/blob/80874ae1fe1cde2e587bb6e51b6d7c9b42ca1d34/lib/btoa.js
function btoa(s) {
    if (arguments.length === 0) {
        throw new TypeError("1 argument required, but only 0 present.");
    }
    let i;
    // String conversion as required by Web IDL.
    s = `${s}`;
    // "The btoa() method must throw an "InvalidCharacterError" DOMException if
    // data contains any character whose code point is greater than U+00FF."
    for(i = 0; i < s.length; i++){
        if (s.charCodeAt(i) > 255) {
            throw new Error(`InvalidCharacterError: found code point greater than 255:${s.charCodeAt(i)} at position ${i}`);
        }
    }
    let out = "";
    for(i = 0; i < s.length; i += 3){
        const groupsOfSix = [
            undefined,
            undefined,
            undefined,
            undefined
        ];
        groupsOfSix[0] = s.charCodeAt(i) >> 2;
        groupsOfSix[1] = (s.charCodeAt(i) & 0x03) << 4;
        if (s.length > i + 1) {
            groupsOfSix[1] |= s.charCodeAt(i + 1) >> 4;
            groupsOfSix[2] = (s.charCodeAt(i + 1) & 0x0f) << 2;
        }
        if (s.length > i + 2) {
            groupsOfSix[2] |= s.charCodeAt(i + 2) >> 6;
            groupsOfSix[3] = s.charCodeAt(i + 2) & 0x3f;
        }
        for(let j = 0; j < groupsOfSix.length; j++){
            if (typeof groupsOfSix[j] === "undefined") {
                out += "=";
            } else {
                out += btoaLookup(groupsOfSix[j]);
            }
        }
    }
    return out;
}
function btoaLookup(index) {
    /**
     * Lookup table for btoa(), which converts a six-bit number into the
     * corresponding ASCII character.
     */ const keystr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    if (index >= 0 && index < 64) {
        return keystr[index];
    }
    // Throw INVALID_CHARACTER_ERR exception here -- won't be hit in the tests.
    return undefined;
}
// Pure JS implementation of btoa.
function atob(input) {
    if (arguments.length === 0) {
        throw new TypeError("1 argument required, but only 0 present.");
    }
    // convert to string and remove invalid characters upfront
    const str = String(input).replace(/[^A-Za-z0-9+/=]/g, "");
    // the atob() method must throw an "InvalidCharacterError" if
    // the length of the string is not a multiple of 4
    if (str.length % 4 === 1) {
        throw new Error("InvalidCharacterError: The string to be decoded is not correctly encoded.");
    }
    const keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    let output = "";
    let buffer = 0;
    let bits = 0;
    let i = 0;
    // process each character
    while(i < str.length){
        const ch = str.charAt(i);
        const index = keyStr.indexOf(ch);
        if (index < 0 || index > 64) {
            i++;
            continue;
        }
        if (ch === "=") {
            // we skip padding characters
            bits = 0;
        } else {
            buffer = buffer << 6 | index;
            bits += 6;
        }
        // output complete bytes
        while(bits >= 8){
            bits -= 8;
            output += String.fromCharCode(buffer >> bits & 0xff);
        }
        i++;
    }
    return output;
}
;
 //# sourceMappingURL=base64.mjs.map
}),
"[project]/node_modules/@turnkey/encoding/dist/encode.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "pointEncode",
    ()=>pointEncode
]);
/**
 * Compresses an uncompressed P-256 public key into its 33-byte compressed form.
 *
 * @param {Uint8Array} raw - The uncompressed public key (65 bytes, starting with 0x04).
 * @returns {Uint8Array} - The compressed public key (33 bytes, starting with 0x02 or 0x03).
 * @throws {Error} - If the input key is not a valid uncompressed P-256 key.
 */ function pointEncode(raw) {
    if (raw.length !== 65 || raw[0] !== 0x04) {
        throw new Error("Invalid uncompressed P-256 key");
    }
    const x = raw.slice(1, 33);
    const y = raw.slice(33, 65);
    if (x.length !== 32 || y.length !== 32) {
        throw new Error("Invalid x or y length");
    }
    const prefix = (y[31] & 1) === 0 ? 0x02 : 0x03;
    const compressed = new Uint8Array(33);
    compressed[0] = prefix;
    compressed.set(x, 1);
    return compressed;
}
;
 //# sourceMappingURL=encode.mjs.map
}),
"[project]/node_modules/@turnkey/encoding/dist/bs58.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bs58",
    ()=>bs58
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bs58/src/esm/index.js [app-client] (ecmascript)");
;
// This is a temporary shim for bs58@6.0.0
//
// This issue is similar to the one described here: https://github.com/bitcoinjs/bs58check/issues/47
//
// bs58 v6.0.0 uses ESM with only a default export, which causes compatibility
// issues with Metro (React Native). When importing the package using
// `import bs58 from 'bs58'`, Metro applies multiple levels of wrapping,
// resulting in a structure like `{ default: { default: { encode, decode, ... } } }`.
//
// This shim unwraps the exports until it reaches the object that contains `.decode`,
// `.encode`, and `.decodeUnsafe`, allowing consistent usage across platforms.
//
// We can remove this shim once bs58 publishes a version that properly re-exports
// named methods from its ESM build.
function unwrap(obj) {
    let cur = obj;
    while(cur && !(cur.encode && cur.decode && cur.decodeUnsafe) && cur.default){
        cur = cur.default;
    }
    return cur;
}
const bs58 = unwrap(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__);
;
 //# sourceMappingURL=bs58.mjs.map
}),
"[project]/node_modules/@turnkey/encoding/dist/bs58check.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bs58check",
    ()=>bs58check
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58check$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bs58check/src/esm/index.js [app-client] (ecmascript)");
;
// This is a temporary shim for bs58check@4.0.0
//
// See: https://github.com/bitcoinjs/bs58check/issues/47
//
// bs58check v4.0.0 uses ESM with only a default export, which causes compatibility
// issues with Metro (React Native). When importing the package using
// `import bs58check from 'bs58check'`, Metro applies multiple levels of wrapping,
// resulting in a structure like `{ default: { default: { encode, decode, ... } } }`.
//
// This shim unwraps the exports until it reaches the object that contains `.decode`,
// `.encode`, and `.decodeUnsafe`, allowing consistent usage across platforms.
//
// We can remove this shim once bs58check publishes a version that properly re-exports
// named methods from its ESM build
function unwrap(obj) {
    let cur = obj;
    while(cur && !(cur.encode && cur.decode && cur.decodeUnsafe) && cur.default){
        cur = cur.default;
    }
    return cur;
}
const bs58check = unwrap(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bs58check$2f$src$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__);
;
 //# sourceMappingURL=bs58check.mjs.map
}),
"[project]/node_modules/@turnkey/encoding/dist/index.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DEFAULT_JWK_MEMBER_BYTE_LENGTH",
    ()=>DEFAULT_JWK_MEMBER_BYTE_LENGTH
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$base64$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/base64.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$encode$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/encode.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/hex.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$bs58$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/bs58.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$bs58check$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/bs58check.mjs [app-client] (ecmascript)");
;
;
;
;
;
const DEFAULT_JWK_MEMBER_BYTE_LENGTH = 32;
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@turnkey/crypto/dist/math.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "modSqrt",
    ()=>modSqrt,
    "testBit",
    ()=>testBit
]);
/**
 * Compute the modular square root using the Tonelli-Shanks algorithm.
 */ const modSqrt = (x, p)=>{
    if (p <= BigInt(0)) {
        throw new Error("p must be positive");
    }
    const base = x % p;
    // Check if p % 4 == 3 (applies to NIST curves P-256, P-384, and P-521)
    if (testBit(p, 0) && testBit(p, 1)) {
        const q = p + BigInt(1) >> BigInt(2);
        const squareRoot = modPow(base, q, p);
        if (squareRoot * squareRoot % p !== base) {
            throw new Error("could not find a modular square root");
        }
        return squareRoot;
    }
    // Other elliptic curve types not supported
    throw new Error("unsupported modulus value");
};
/**
 * Test if a specific bit is set.
 */ const testBit = (n, i)=>{
    const m = BigInt(1) << BigInt(i);
    return (n & m) !== BigInt(0);
};
/**
 * Compute the modular exponentiation.
 */ const modPow = (b, exp, p)=>{
    if (exp === BigInt(0)) {
        return BigInt(1);
    }
    let result = b % p;
    const exponentBitString = exp.toString(2);
    for(let i = 1; i < exponentBitString.length; ++i){
        result = result * result % p;
        if (exponentBitString[i] === "1") {
            result = result * b % p;
        }
    }
    return result;
};
;
 //# sourceMappingURL=math.mjs.map
}),
"[project]/node_modules/@turnkey/crypto/dist/constants.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AES_KEY_INFO",
    ()=>AES_KEY_INFO,
    "AWS_ROOT_CERT_PEM",
    ()=>AWS_ROOT_CERT_PEM,
    "AWS_ROOT_CERT_SHA256",
    ()=>AWS_ROOT_CERT_SHA256,
    "HPKE_VERSION",
    ()=>HPKE_VERSION,
    "IV_INFO",
    ()=>IV_INFO,
    "LABEL_EAE_PRK",
    ()=>LABEL_EAE_PRK,
    "LABEL_SECRET",
    ()=>LABEL_SECRET,
    "LABEL_SHARED_SECRET",
    ()=>LABEL_SHARED_SECRET,
    "PRODUCTION_NOTARIZER_SIGN_PUBLIC_KEY",
    ()=>PRODUCTION_NOTARIZER_SIGN_PUBLIC_KEY,
    "PRODUCTION_ON_RAMP_CREDENTIALS_ENCRYPTION_PUBLIC_KEY",
    ()=>PRODUCTION_ON_RAMP_CREDENTIALS_ENCRYPTION_PUBLIC_KEY,
    "PRODUCTION_SIGNER_SIGN_PUBLIC_KEY",
    ()=>PRODUCTION_SIGNER_SIGN_PUBLIC_KEY,
    "PRODUCTION_TLS_FETCHER_ENCRYPT_PUBLIC_KEY",
    ()=>PRODUCTION_TLS_FETCHER_ENCRYPT_PUBLIC_KEY,
    "QOS_ENCRYPTION_HMAC_MESSAGE",
    ()=>QOS_ENCRYPTION_HMAC_MESSAGE,
    "QUORUM_ENCRYPT_NONCE_LENGTH_BYTES",
    ()=>QUORUM_ENCRYPT_NONCE_LENGTH_BYTES,
    "SUITE_ID_1",
    ()=>SUITE_ID_1,
    "SUITE_ID_2",
    ()=>SUITE_ID_2,
    "UNCOMPRESSED_PUB_KEY_LENGTH_BYTES",
    ()=>UNCOMPRESSED_PUB_KEY_LENGTH_BYTES
]);
const SUITE_ID_1 = new Uint8Array([
    75,
    69,
    77,
    0,
    16
]); //KEM suite ID
const SUITE_ID_2 = new Uint8Array([
    72,
    80,
    75,
    69,
    0,
    16,
    0,
    1,
    0,
    2
]); //HPKE suite ID
const HPKE_VERSION = new Uint8Array([
    72,
    80,
    75,
    69,
    45,
    118,
    49
]); //HPKE-v1
const LABEL_SECRET = new Uint8Array([
    115,
    101,
    99,
    114,
    101,
    116
]); //secret
const LABEL_EAE_PRK = new Uint8Array([
    101,
    97,
    101,
    95,
    112,
    114,
    107
]); //eae_prk
const LABEL_SHARED_SECRET = new Uint8Array([
    115,
    104,
    97,
    114,
    101,
    100,
    95,
    115,
    101,
    99,
    114,
    101,
    116
]); //shared_secret
const AES_KEY_INFO = new Uint8Array([
    0,
    32,
    72,
    80,
    75,
    69,
    45,
    118,
    49,
    72,
    80,
    75,
    69,
    0,
    16,
    0,
    1,
    0,
    2,
    107,
    101,
    121,
    0,
    143,
    195,
    174,
    184,
    50,
    73,
    10,
    75,
    90,
    179,
    228,
    32,
    35,
    40,
    125,
    178,
    154,
    31,
    75,
    199,
    194,
    34,
    192,
    223,
    34,
    135,
    39,
    183,
    10,
    64,
    33,
    18,
    47,
    63,
    4,
    233,
    32,
    108,
    209,
    36,
    19,
    80,
    53,
    41,
    180,
    122,
    198,
    166,
    48,
    185,
    46,
    196,
    207,
    125,
    35,
    69,
    8,
    208,
    175,
    151,
    113,
    201,
    158,
    80
]); //key
const IV_INFO = new Uint8Array([
    0,
    12,
    72,
    80,
    75,
    69,
    45,
    118,
    49,
    72,
    80,
    75,
    69,
    0,
    16,
    0,
    1,
    0,
    2,
    98,
    97,
    115,
    101,
    95,
    110,
    111,
    110,
    99,
    101,
    0,
    143,
    195,
    174,
    184,
    50,
    73,
    10,
    75,
    90,
    179,
    228,
    32,
    35,
    40,
    125,
    178,
    154,
    31,
    75,
    199,
    194,
    34,
    192,
    223,
    34,
    135,
    39,
    183,
    10,
    64,
    33,
    18,
    47,
    63,
    4,
    233,
    32,
    108,
    209,
    36,
    19,
    80,
    53,
    41,
    180,
    122,
    198,
    166,
    48,
    185,
    46,
    196,
    207,
    125,
    35,
    69,
    8,
    208,
    175,
    151,
    113,
    201,
    158,
    80
]); //base_nonce
const QUORUM_ENCRYPT_NONCE_LENGTH_BYTES = 12;
const UNCOMPRESSED_PUB_KEY_LENGTH_BYTES = 65;
const QOS_ENCRYPTION_HMAC_MESSAGE = new Uint8Array([
    113,
    111,
    115,
    95,
    101,
    110,
    99,
    114,
    121,
    112,
    116,
    105,
    111,
    110,
    95,
    104,
    109,
    97,
    99,
    95,
    109,
    101,
    115,
    115,
    97,
    103,
    101
]); // used for encrypting messages to quorum keys matched whats found here: https://github.com/tkhq/qos/blob/ae01904c756107f850aea42000137ef124df3fe4/src/qos_p256/src/encrypt.rs#L22
const PRODUCTION_SIGNER_SIGN_PUBLIC_KEY = "04cf288fe433cc4e1aa0ce1632feac4ea26bf2f5a09dcfe5a42c398e06898710330f0572882f4dbdf0f5304b8fc8703acd69adca9a4bbf7f5d00d20a5e364b2569";
const PRODUCTION_NOTARIZER_SIGN_PUBLIC_KEY = "04d498aa87ac3bf982ac2b5dd9604d0074905cfbda5d62727c5a237b895e6749205e9f7cd566909c4387f6ca25c308445c60884b788560b785f4a96ac33702a469";
const PRODUCTION_TLS_FETCHER_ENCRYPT_PUBLIC_KEY = "045e899f1fcf7d12b3c8fd997a7a43bb853dd4e8d63419a8f867c70aacc1c4cf9d04848baca41f0c85ffbbd23cbf78967501cd8eca9e4a6369370a9a38f70d13c0";
const PRODUCTION_ON_RAMP_CREDENTIALS_ENCRYPTION_PUBLIC_KEY = "02336ebd7e929ef64b87c776b72540255b4c7b41579a24b1e68fb060daa873f9f6";
// Pinned AWS Nitro Enclaves Root
const AWS_ROOT_CERT_PEM = `-----BEGIN CERTIFICATE-----
MIICETCCAZagAwIBAgIRAPkxdWgbkK/hHUbMtOTn+FYwCgYIKoZIzj0EAwMwSTEL
MAkGA1UEBhMCVVMxDzANBgNVBAoMBkFtYXpvbjEMMAoGA1UECwwDQVdTMRswGQYD
VQQDDBJhd3Mubml0cm8tZW5jbGF2ZXMwHhcNMTkxMDI4MTMyODA1WhcNNDkxMDI4
MTQyODA1WjBJMQswCQYDVQQGEwJVUzEPMA0GA1UECgwGQW1hem9uMQwwCgYDVQQL
DANBV1MxGzAZBgNVBAMMEmF3cy5uaXRyby1lbmNsYXZlczB2MBAGByqGSM49AgEG
BSuBBAAiA2IABPwCVOumCMHzaHDimtqQvkY4MpJzbolL//Zy2YlES1BR5TSksfbb
48C8WBoyt7F2Bw7eEtaaP+ohG2bnUs990d0JX28TcPQXCEPZ3BABIeTPYwEoCWZE
h8l5YoQwTcU/9KNCMEAwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUkCW1DdkF
R+eWw5b6cp3PmanfS5YwDgYDVR0PAQH/BAQDAgGGMAoGCCqGSM49BAMDA2kAMGYC
MQCjfy+Rocm9Xue4YnwWmNJVA44fA0P5W2OpYow9OYCVRaEevL8uO1XYru5xtMPW
rfMCMQCi85sWBbJwKKXdS6BptQFuZbT73o/gBh1qUxl/nNr12UO8Yfwr6wPLb+6N
IwLz3/Y=
-----END CERTIFICATE-----`;
// Official SHA-256 fingerprint
const AWS_ROOT_CERT_SHA256 = "641A0321A3E244EFE456463195D606317ED7CDCC3C1756E09893F3C68F79BB5B";
;
 //# sourceMappingURL=constants.mjs.map
}),
"[project]/node_modules/@turnkey/crypto/dist/crypto.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildAdditionalAssociatedData",
    ()=>buildAdditionalAssociatedData,
    "compressRawPublicKey",
    ()=>compressRawPublicKey,
    "extractPrivateKeyFromPKCS8Bytes",
    ()=>extractPrivateKeyFromPKCS8Bytes,
    "formatHpkeBuf",
    ()=>formatHpkeBuf,
    "fromDerSignature",
    ()=>fromDerSignature,
    "generateP256KeyPair",
    ()=>generateP256KeyPair,
    "getPublicKey",
    ()=>getPublicKey,
    "hpkeAuthEncrypt",
    ()=>hpkeAuthEncrypt,
    "hpkeDecrypt",
    ()=>hpkeDecrypt,
    "hpkeEncrypt",
    ()=>hpkeEncrypt,
    "quorumKeyEncrypt",
    ()=>quorumKeyEncrypt,
    "toDerSignature",
    ()=>toDerSignature,
    "uncompressRawPublicKey",
    ()=>uncompressRawPublicKey
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$p256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/node_modules/@noble/curves/esm/p256.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$hkdf$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/hkdf.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/sha256.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$esm$2f$aes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/ciphers/esm/aes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$borsh$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/borsh/lib/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/hex.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$math$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/dist/math.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/dist/constants.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
/// <reference lib="dom" />
// schema for borsh serialization
const EnvelopeSchema = {
    struct: {
        nonce: {
            array: {
                type: "u8",
                len: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QUORUM_ENCRYPT_NONCE_LENGTH_BYTES"]
            }
        },
        ephemeralSenderPublic: {
            array: {
                type: "u8",
                len: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["UNCOMPRESSED_PUB_KEY_LENGTH_BYTES"]
            }
        },
        encryptedMessage: {
            array: {
                type: "u8"
            }
        }
    }
};
/**
 * Get PublicKey function
 * Derives public key from Uint8Array or hexstring private key
 *
 * @param {Uint8Array | string} privateKey - The Uint8Array or hexstring representation of a compressed private key.
 * @param {boolean} isCompressed - Specifies whether to return a compressed or uncompressed public key. Defaults to true.
 * @returns {Uint8Array} - The public key in Uin8Array representation.
 */ const getPublicKey = (privateKey, isCompressed = true)=>{
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$p256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["p256"].getPublicKey(privateKey, isCompressed);
};
/**
 * HPKE Encrypt Function
 * Encrypts data using Hybrid Public Key Encryption (HPKE) standard https://datatracker.ietf.org/doc/rfc9180/.
 *
 * @param {HpkeEncryptParams} params - The encryption parameters including plain text, encapsulated key, and sender private key.
 * @returns {Uint8Array} - The encrypted data.
 */ const hpkeEncrypt = ({ plainTextBuf, targetKeyBuf })=>{
    try {
        // Standard HPKE Mode (Ephemeral Key Pair)
        const ephemeralKeyPair = generateP256KeyPair();
        const senderPrivBuf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(ephemeralKeyPair.privateKey);
        const senderPubBuf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(ephemeralKeyPair.publicKeyUncompressed);
        const aad = buildAdditionalAssociatedData(senderPubBuf, targetKeyBuf);
        // Step 1: Generate Shared Secret
        const ss = deriveSS(targetKeyBuf, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(senderPrivBuf));
        // Step 2: Generate the KEM context
        const kemContext = getKemContext(senderPubBuf, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(targetKeyBuf));
        // Step 3: Build the HKDF inputs for key derivation
        let ikm = buildLabeledIkm(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LABEL_EAE_PRK"], ss, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SUITE_ID_1"]);
        let info = buildLabeledInfo(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LABEL_SHARED_SECRET"], kemContext, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SUITE_ID_1"], 32);
        const sharedSecret = extractAndExpand(new Uint8Array([]), ikm, info, 32);
        // Step 4: Derive the AES key
        ikm = buildLabeledIkm(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LABEL_SECRET"], new Uint8Array([]), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SUITE_ID_2"]);
        info = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AES_KEY_INFO"];
        const key = extractAndExpand(sharedSecret, ikm, info, 32);
        // Step 5: Derive the initialization vector
        info = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IV_INFO"];
        const iv = extractAndExpand(sharedSecret, ikm, info, 12);
        // Step 6: Encrypt the data using AES-GCM
        const encryptedData = aesGcmEncrypt(plainTextBuf, key, iv, aad);
        // Step 7: Concatenate the encapsulated key and the encrypted data for output
        const compressedSenderBuf = compressRawPublicKey(senderPubBuf);
        const result = new Uint8Array(compressedSenderBuf.length + encryptedData.length);
        result.set(compressedSenderBuf, 0);
        result.set(encryptedData, compressedSenderBuf.length);
        return result;
    } catch (error) {
        throw new Error(`Unable to perform hpkeEncrypt: ${error}`);
    }
};
/**
 * HPKE Encrypt Function
 * Encrypts data using Authenticated ,Hybrid Public Key Encryption (HPKE) standard https://datatracker.ietf.org/doc/rfc9180/.
 *
 * @param {HpkeAuthEncryptParams} params - The encryption parameters including plain text, encapsulated key, and sender private key.
 * @returns {Uint8Array} - The encrypted data.
 */ const hpkeAuthEncrypt = ({ plainTextBuf, targetKeyBuf, senderPriv })=>{
    try {
        // Authenticated HPKE Mode
        const senderPrivBuf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(senderPriv);
        const senderPubBuf = getPublicKey(senderPriv, false);
        const aad = buildAdditionalAssociatedData(senderPubBuf, targetKeyBuf);
        // Step 1: Generate Shared Secret
        const ss = deriveSS(targetKeyBuf, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(senderPrivBuf));
        // Step 2: Generate the KEM context
        const kemContext = getKemContext(senderPubBuf, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(targetKeyBuf));
        // Step 3: Build the HKDF inputs for key derivation
        let ikm = buildLabeledIkm(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LABEL_EAE_PRK"], ss, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SUITE_ID_1"]);
        let info = buildLabeledInfo(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LABEL_SHARED_SECRET"], kemContext, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SUITE_ID_1"], 32);
        const sharedSecret = extractAndExpand(new Uint8Array([]), ikm, info, 32);
        // Step 4: Derive the AES key
        ikm = buildLabeledIkm(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LABEL_SECRET"], new Uint8Array([]), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SUITE_ID_2"]);
        info = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AES_KEY_INFO"];
        const key = extractAndExpand(sharedSecret, ikm, info, 32);
        // Step 5: Derive the initialization vector
        info = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IV_INFO"];
        const iv = extractAndExpand(sharedSecret, ikm, info, 12);
        // Step 6: Encrypt the data using AES-GCM
        const encryptedData = aesGcmEncrypt(plainTextBuf, key, iv, aad);
        // Step 7: Concatenate the encapsulated key and the encrypted data for output
        const compressedSenderBuf = compressRawPublicKey(senderPubBuf);
        const result = new Uint8Array(compressedSenderBuf.length + encryptedData.length);
        result.set(compressedSenderBuf, 0);
        result.set(encryptedData, compressedSenderBuf.length);
        return result;
    } catch (error) {
        throw new Error(`Unable to perform hpkeEncrypt: ${error}`);
    }
};
/**
 * Encrypt a message to a quorum key. Algorithm originally implemented in qos here: https://github.com/tkhq/qos/blob/ae01904c756107f850aea42000137ef124df3fe4/src/qos_p256/src/encrypt.rs#L123
 * Returns a borsh serialized encrypted Envelope which is the nonce + ephemeralSenderPublicKey + encryptedMessage
 * This function creates an ephemeral key, creates a shared secret with the recipient targetPublicKeyUncompressed
 * creates additional associated data which follows the form: sender_public||sender_public_len||receiver_public||receiver_public_len
 * encrypts using aes-gcm-256 with a SHA-512 HMAC over the QOS_ENCRYPTION_HMAC_MESSAGE literally: "qos_encryption_hmac_message"
 * inserts and returns the necessary information in a borsh serialized envelope as described above
 * This encryption function is meant to be used with this decryption function in QOS: https://github.com/tkhq/qos/blob/ae01904c756107f850aea42000137ef124df3fe4/src/qos_p256/src/encrypt.rs#L52
 *
 * @param {Uint8Array} targetPublicKeyUncompressed - The P256 uncompressed public key to encrypt the message to
 * @param {Uint8Array} message - The message to encrypt to targetPublicKeyUncompressed
 * @returns {Uint8Array} - A borsh serialized envelope containing the nonce + ephemeralSenderPublicKey + encrypted message
 */ const quorumKeyEncrypt = async (targetPublicKeyUncompressed, message)=>{
    // generate an ephemeral keypair for this encryption operation
    const ephemeralKeyPair = generateP256KeyPair();
    const ephemeralSenderPublic = ephemeralKeyPair.publicKeyUncompressed;
    // create a shared secret AES-GCM key with the SHA-512 HMAC
    let cipher = await createQuorumKeyEncryptCipher((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(ephemeralSenderPublic), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(ephemeralKeyPair.privateKey), targetPublicKeyUncompressed);
    // generate a nonce
    const nonce = new Uint8Array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QUORUM_ENCRYPT_NONCE_LENGTH_BYTES"]);
    crypto.getRandomValues(nonce);
    // create the additional data in the form of sender_public||sender_public_len||receiver_public||receiver_public_len taken from QOS here: https://github.com/tkhq/qos/blob/ae01904c756107f850aea42000137ef124df3fe4/src/qos_p256/src/encrypt.rs#L298
    const aad = createAdditionalAssociatedData((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(ephemeralSenderPublic), targetPublicKeyUncompressed);
    // algorithm specifications for AES-GCM
    const alg = {
        name: "AES-GCM",
        iv: nonce,
        tagLength: 128,
        additionalData: aad
    };
    // encrypt the message with the shared secret
    const encryptedMessageBuf = await crypto.subtle.encrypt(alg, cipher, message);
    // create the envelope
    let envelope = {
        nonce: nonce,
        ephemeralSenderPublic: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(ephemeralSenderPublic),
        encryptedMessage: new Uint8Array(encryptedMessageBuf)
    };
    // borsh serialize the envelope
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$borsh$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["serialize"](EnvelopeSchema, envelope);
};
/**
 * Format HPKE Buffer Function
 * Returns a JSON string of an encrypted bundle, separating out the cipher text and the sender public key
 *
 * @param {Uint8Array} encryptedBuf - The result of hpkeAuthEncrypt or hpkeEncrypt
 * @returns {string} - A JSON string with "encappedPublic" and "ciphertext"
 */ const formatHpkeBuf = (encryptedBuf)=>{
    const compressedSenderBuf = encryptedBuf.slice(0, 33);
    const encryptedData = encryptedBuf.slice(33);
    const encappedKeyBufHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(uncompressRawPublicKey(compressedSenderBuf));
    const ciphertextHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(encryptedData);
    return JSON.stringify({
        encappedPublic: encappedKeyBufHex,
        ciphertext: ciphertextHex
    });
};
/**
 * HPKE Decrypt Function
 * Decrypts data using Hybrid Public Key Encryption (HPKE) standard https://datatracker.ietf.org/doc/rfc9180/.
 *
 * @param {HpkeDecryptParams} params - The decryption parameters including ciphertext, encapsulated key, and receiver private key.
 * @returns {Uint8Array} - The decrypted data.
 */ const hpkeDecrypt = ({ ciphertextBuf, encappedKeyBuf, receiverPriv })=>{
    try {
        let ikm;
        let info;
        const receiverPubBuf = getPublicKey((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(receiverPriv), false);
        const aad = buildAdditionalAssociatedData(encappedKeyBuf, receiverPubBuf); // Eventually we want users to be able to pass in aad as optional
        // Step 1: Generate Shared Secret
        const ss = deriveSS(encappedKeyBuf, receiverPriv);
        // Step 2: Generate the KEM context
        const kemContext = getKemContext(encappedKeyBuf, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(receiverPubBuf));
        // Step 3: Build the HKDF inputs for key derivation
        ikm = buildLabeledIkm(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LABEL_EAE_PRK"], ss, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SUITE_ID_1"]);
        info = buildLabeledInfo(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LABEL_SHARED_SECRET"], kemContext, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SUITE_ID_1"], 32);
        const sharedSecret = extractAndExpand(new Uint8Array([]), ikm, info, 32);
        // Step 4: Derive the AES key
        ikm = buildLabeledIkm(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LABEL_SECRET"], new Uint8Array([]), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SUITE_ID_2"]);
        info = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AES_KEY_INFO"];
        const key = extractAndExpand(sharedSecret, ikm, info, 32);
        // Step 5: Derive the initialization vector
        info = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IV_INFO"];
        const iv = extractAndExpand(sharedSecret, ikm, info, 12);
        // Step 6: Decrypt the data using AES-GCM
        const decryptedData = aesGcmDecrypt(ciphertextBuf, key, iv, aad);
        return decryptedData;
    } catch (error) {
        throw new Error(`Unable to perform hpkeDecrypt: ${error} `);
    }
};
/**
 * Generate a P-256 key pair. Contains the hexed privateKey, publicKey, and Uncompressed publicKey
 *
 * @returns {KeyPair} - The generated key pair.
 */ const generateP256KeyPair = ()=>{
    const privateKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["randomBytes"])(32);
    const publicKey = getPublicKey(privateKey, true);
    const publicKeyUncompressed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(uncompressRawPublicKey(publicKey));
    return {
        privateKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(privateKey),
        publicKey: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(publicKey),
        publicKeyUncompressed
    };
};
/**
 * Create additional associated data (AAD) for AES-GCM decryption.
 *
 * @param {Uint8Array} senderPubBuf
 * @param {Uint8Array} receiverPubBuf
 * @return {Uint8Array} - The resulting concatenation of sender and receiver pubkeys.
 */ const buildAdditionalAssociatedData = (senderPubBuf, receiverPubBuf)=>{
    return new Uint8Array([
        ...Array.from(senderPubBuf),
        ...Array.from(receiverPubBuf)
    ]);
};
/**
 * Accepts a private key Uint8Array in the PKCS8 format, and returns the encapsulated private key.
 *
 * @param {Uint8Array} privateKey - A PKCS#8 private key structured with the key data at a specific position. The actual key starts at byte 36 and is 32 bytes long.
 * @return {Uint8Array} - The private key.
 */ const extractPrivateKeyFromPKCS8Bytes = (privateKey)=>{
    return privateKey.slice(36, 36 + 32);
};
/**
 * Accepts a public key Uint8Array, and returns a Uint8Array with the compressed version of the public key.
 *
 * @param {Uint8Array} rawPublicKey - The raw public key.
 * @return {Uint8Array}  The compressed public key.
 */ const compressRawPublicKey = (rawPublicKey)=>{
    const len = rawPublicKey.byteLength;
    // Drop the y coordinate
    // Uncompressed key is in the form 0x04||x||y
    // `len >>> 1` is a more concise way to write `floor(len/2)`
    var compressedBytes = rawPublicKey.slice(0, 1 + len >>> 1);
    // Encode the parity of `y` in first bit
    // `BYTE & 0x01` tests for parity and returns 0x00 when even, or 0x01 when odd
    // Then `0x02 | <parity test result>` yields either 0x02 (even case) or 0x03 (odd).
    compressedBytes[0] = 0x02 | rawPublicKey[len - 1] & 0x01;
    return compressedBytes;
};
/**
 * Accepts a public key array buffer, and returns a buffer with the uncompressed version of the public key
 * @param {Uint8Array} rawPublicKey - The public key.
 * @return {Uint8Array} - The uncompressed public key.
 */ const uncompressRawPublicKey = (rawPublicKey, curve = "CURVE_P256")=>{
    if (rawPublicKey.length !== 33) {
        throw new Error("failed to uncompress raw public key: invalid length");
    }
    if (!(rawPublicKey[0] === 2 || rawPublicKey[0] === 3)) {
        throw new Error("failed to uncompress raw public key: invalid prefix");
    }
    // point[0] must be 2 (false) or 3 (true).
    // this maps to the initial "02" or "03" prefix
    const lsb = rawPublicKey[0] === 3;
    const x = BigInt("0x" + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(rawPublicKey.subarray(1)));
    let p, a, b;
    if (curve === "CURVE_P256") {
        // p-256 domain parameters
        // https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf (Appendix D).
        p = BigInt("115792089210356248762697446949407573530086143415290314195533631308867097853951");
        b = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
        a = p - BigInt(3);
    } else {
        // secp256k1 domain parameters
        // https://www.secg.org/sec2-v2.pdf (Section 2.4.1).
        p = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
        a = BigInt(0);
        b = BigInt(7);
    }
    // Now compute y based on x
    const rhs = ((x * x + a) * x + b) % p;
    let y = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$math$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["modSqrt"])(rhs, p);
    if (lsb !== (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$math$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["testBit"])(y, 0)) {
        y = (p - y) % p;
    }
    if (x < BigInt(0) || x >= p) {
        throw new Error("x is out of range");
    }
    if (y < BigInt(0) || y >= p) {
        throw new Error("y is out of range");
    }
    var uncompressedHexString = "04" + bigIntToHex(x, 64) + bigIntToHex(y, 64);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(uncompressedHexString);
};
/**
 * Build labeled Initial Key Material (IKM).
 *
 * @param {Uint8Array} label - The label to use.
 * @param {Uint8Array} ikm - The input key material.
 * @param {Uint8Array} suiteId - The suite identifier.
 * @returns {Uint8Array} - The labeled IKM.
 */ const buildLabeledIkm = (label, ikm, suiteId)=>{
    const combinedLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HPKE_VERSION"].length + suiteId.length + label.length + ikm.length;
    const ret = new Uint8Array(combinedLength);
    let offset = 0;
    ret.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HPKE_VERSION"], offset);
    offset += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HPKE_VERSION"].length;
    ret.set(suiteId, offset);
    offset += suiteId.length;
    ret.set(label, offset);
    offset += label.length;
    ret.set(ikm, offset);
    return ret;
};
/**
 * Build labeled info for HKDF operations.
 *
 * @param {Uint8Array} label - The label to use.
 * @param {Uint8Array} info - Additional information.
 * @param {Uint8Array} suiteId - The suite identifier.
 * @param {number} len - The output length.
 * @returns {Uint8Array} - The labeled info.
 */ const buildLabeledInfo = (label, info, suiteId, len)=>{
    const suiteIdStartIndex = 9; // first two are reserved for length bytes (unused in this case), the next 7 are for the HPKE_VERSION, then the suiteId starts at 9
    const ret = new Uint8Array(suiteIdStartIndex + suiteId.byteLength + label.byteLength + info.byteLength);
    ret.set(new Uint8Array([
        0,
        len
    ]), 0); // this isnt an error, were starting at index 2 because the first two bytes should be 0. See <https://github.com/dajiaji/hpke-js/blob/1e7fb1372fbcdb6d06bf2f4fa27ff676329d633e/src/kdfs/hkdf.ts#L41> for reference.
    ret.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HPKE_VERSION"], 2);
    ret.set(suiteId, suiteIdStartIndex);
    ret.set(label, suiteIdStartIndex + suiteId.byteLength);
    ret.set(info, suiteIdStartIndex + suiteId.byteLength + label.byteLength);
    return ret;
};
/**
 * Perform HKDF extract and expand operations.
 */ const extractAndExpand = (sharedSecret, ikm, info, len)=>{
    const prk = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$hkdf$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["extract"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"], ikm, sharedSecret);
    const resp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$hkdf$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["expand"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"], prk, info, len);
    return new Uint8Array(resp);
};
/**
 * Derive the Diffie-Hellman shared secret using ECDH.
 */ const deriveSS = (encappedKeyBuf, priv)=>{
    const ss = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$p256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["p256"].getSharedSecret((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(priv), encappedKeyBuf);
    return ss.slice(1);
};
/**
 * Encrypt data using AES-GCM.
 */ const aesGcmEncrypt = (plainTextData, key, iv, aad)=>{
    const aes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$esm$2f$aes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gcm"])(key, iv, aad);
    const data = aes.encrypt(plainTextData);
    return data;
};
/**
 * Decrypt data using AES-GCM.
 */ const aesGcmDecrypt = (encryptedData, key, iv, aad)=>{
    const aes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ciphers$2f$esm$2f$aes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["gcm"])(key, iv, aad);
    const data = aes.decrypt(encryptedData);
    return data;
};
/**
 * Generate a Key Encapsulation Mechanism (KEM) context.
 */ const getKemContext = (encappedKeyBuf, publicKey)=>{
    const encappedKeyArray = new Uint8Array(encappedKeyBuf);
    const publicKeyArray = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(publicKey);
    const kemContext = new Uint8Array(encappedKeyArray.length + publicKeyArray.length);
    kemContext.set(encappedKeyArray);
    kemContext.set(publicKeyArray, encappedKeyArray.length);
    return kemContext;
};
/**
 * Convert a BigInt to a hexadecimal string of a specific length.
 */ const bigIntToHex = (num, length)=>{
    const hexString = num.toString(16);
    if (hexString.length > length) {
        throw new Error(`number cannot fit in a hex string of ${length} characters`);
    }
    return hexString.padStart(length, "0");
};
/**
 * Converts an ASN.1 DER-encoded ECDSA signature to the raw format used for verification.
 *
 * @param {string} derSignature - The DER-encoded signature.
 * @returns {Uint8Array} - The raw signature.
 */ const fromDerSignature = (derSignature)=>{
    const derSignatureBuf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(derSignature);
    // Check minimum length
    if (derSignatureBuf.length < 2) {
        throw new Error("failed to convert DER-encoded signature: insufficient length");
    }
    // Check SEQUENCE tag (0x30 at first byte)
    if (derSignatureBuf[0] !== 0x30) {
        throw new Error("failed to convert DER-encoded signature: invalid format (missing SEQUENCE tag)");
    }
    // Check second byte, start of length field
    let index = 1;
    const lengthByte = derSignatureBuf[index];
    if (lengthByte <= 0x7f) {
        // Short form: single byte length
        // directly take the consumed value as length and check against buffer
        // buffer length: initial header bytes + claimed remaining length
        if (derSignatureBuf.length < 1 + 1 + lengthByte) {
            throw new Error("failed to convert DER-encoded signature: inconsistent message length header");
        }
        // continue parsing
        index += 1;
    } else {
        // Multi-byte DER length header
        // Invalid DER values: lengthByte 0x80 and 0xff
        // Valid DER values: lengthByte > 0x80, < 0xff
        //
        // We do not expect signature data in the Long form notation
        // -> reject all such inputs
        //
        // More complex parsing for longer signature sequences can be implemented once needed
        throw new Error("failed to convert DER-encoded signature: unexpectedly large or invalid signature length");
    }
    // Parse 'r' and check for integer tag (0x02)
    if (derSignatureBuf[index] !== 0x02) {
        throw new Error("failed to convert DER-encoded signature: invalid tag for r");
    }
    index++; // Move past the INTEGER tag
    const rLength = derSignatureBuf[index];
    // Allow up to 32 data bytes + 1 byte 0-padding prefix
    if (rLength > 33) {
        throw new Error("failed to convert DER-encoded signature: unexpected length for r");
    }
    index++; // Move past the length byte
    const r = derSignatureBuf.slice(index, index + rLength);
    index += rLength; // Move to the start of s
    // Parse 's' and check for integer tag (0x02)
    if (derSignatureBuf[index] !== 0x02) {
        throw new Error("failed to convert DER-encoded signature: invalid tag for s");
    }
    index++; // Move past the INTEGER tag
    const sLength = derSignatureBuf[index];
    // Allow up to 32 data bytes + 1 byte 0-padding prefix
    if (sLength > 33) {
        throw new Error("failed to convert DER-encoded signature: unexpected length for s");
    }
    index++; // Move past the length byte
    const s = derSignatureBuf.slice(index, index + sLength);
    // Normalize 'r' and 's' to 32 bytes each
    const rPadded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizePadding"])(r, 32);
    const sPadded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["normalizePadding"])(s, 32);
    // Concatenate and return the raw signature
    return new Uint8Array([
        ...rPadded,
        ...sPadded
    ]);
};
/**
 * Converts a raw ECDSA signature to DER-encoded format.
 *
 * This function takes a raw ECDSA signature, which is a concatenation of two 32-byte integers (r and s),
 * and converts it into the DER-encoded format. DER (Distinguished Encoding Rules) is a binary encoding
 * for data structures described by ASN.1.
 *
 * @param {string} rawSignature - The raw signature in hexadecimal string format.
 * @returns {string} - The DER-encoded signature in hexadecimal string format.
 *
 * @throws {Error} - Throws an error if the input signature is invalid or if the encoding process fails.
 *
 * @example
 * // Example usage:
 * const rawSignature = "0x487cdb8a88f2f4044b701cbb116075c4cabe5fe4657a6358b395c0aab70694db3453a8057e442bd1aff0ecabe8a82c831f0edd7f2158b7c1feb3de9b1f20309b1c";
 * const derSignature = toDerSignature(rawSignature);
 * console.log(derSignature); // Outputs the DER-encoded signature as a hex string
 * // "30440220487cdb8a88f2f4044b701cbb116075c4cabe5fe4657a6358b395c0aab70694db02203453a8057e442bd1aff0ecabe8a82c831f0edd7f2158b7c1feb3de9b1f20309b"
 */ const toDerSignature = (rawSignature)=>{
    const rawSignatureBuf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(rawSignature);
    // Split raw signature into r and s, each 32 bytes
    const r = rawSignatureBuf.slice(0, 32);
    const s = rawSignatureBuf.slice(32, 64);
    // Helper function to encode an integer with DER structure
    const encodeDerInteger = (integer)=>{
        // Check if integer is defined and has at least one byte
        if (integer === undefined || integer.length === 0 || integer[0] === undefined) {
            throw new Error("Invalid integer: input is undefined or empty.");
        }
        // Add a leading zero if the integer's most significant byte is >= 0x80
        const needsPadding = integer[0] & 0x80;
        const paddedInteger = needsPadding ? new Uint8Array([
            0x00,
            ...integer
        ]) : integer;
        // Prepend the integer tag (0x02) and length
        return new Uint8Array([
            0x02,
            paddedInteger.length,
            ...paddedInteger
        ]);
    };
    // DER encode r and s
    const rEncoded = encodeDerInteger(r);
    const sEncoded = encodeDerInteger(s);
    // Combine as a DER sequence: 0x30, total length, rEncoded, sEncoded
    const derSignature = new Uint8Array([
        0x30,
        rEncoded.length + sEncoded.length,
        ...rEncoded,
        ...sEncoded
    ]);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(derSignature);
};
/**
 * Create a shared AES-GCM secret with the quorum key encryption SHA-512 HMAC
 *
 * This function takes an ephemeral Sender public key generated for each encryption operation
 * the corresponding ephemeral private key, and the target public key uncompressed
 * for data structures described by ASN.1.
 *
 * @param {Uint8Array} ephemeralSenderPublic - The ephemeral public key used to create the preImage
 * @param {Uint8Array} ephemeralSenderPrivate - The ephemeral private key to create the shared secret with
 * @param {Uint8Array} targetPublicKeyUncompressed - The public key to create the shared secret with and encrypt the message to
 * @returns {Promise<CryptoKey>} - A shared secret AES-GCM key between ephemeralSenderPrivate and the targetPublicKeyUncompressed
 */ async function createQuorumKeyEncryptCipher(ephemeralSenderPublic, ephemeralSenderPrivate, targetPublicKeyUncompressed) {
    // create the shared secret between ephemeralSenderPrivate and targetPublicKeyUncompressed
    const sharedSecretUncompressed = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$p256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["p256"].getSharedSecret(ephemeralSenderPrivate, targetPublicKeyUncompressed, false);
    const sharedSecret = sharedSecretUncompressed.slice(1, 33);
    // create the preImage as defined in qos here: https://github.com/tkhq/qos/blob/ae01904c756107f850aea42000137ef124df3fe4/src/qos_p256/src/encrypt.rs#L273-L282
    let preImage = new Uint8Array(ephemeralSenderPublic.length + targetPublicKeyUncompressed.length + sharedSecret.length);
    preImage.set(ephemeralSenderPublic, 0);
    preImage.set(targetPublicKeyUncompressed, ephemeralSenderPublic.length);
    preImage.set(sharedSecret, ephemeralSenderPublic.length + targetPublicKeyUncompressed.length);
    // create the HMAC key and create an HMAC using QOS_ENCRYPTION_HMAC_MESSAGE
    const hmacKey = await crypto.subtle.importKey("raw", preImage, {
        name: "HMAC",
        hash: "SHA-512"
    }, false, [
        "sign"
    ]);
    const mac = new Uint8Array(await crypto.subtle.sign("HMAC", hmacKey, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QOS_ENCRYPTION_HMAC_MESSAGE"]));
    // Use the first 32 bytes as the AES-GCM key
    const aesKeyRaw = mac.slice(0, 32);
    return crypto.subtle.importKey("raw", aesKeyRaw, {
        name: "AES-GCM"
    }, false, [
        "encrypt"
    ]);
}
/// Helper function to create the additional associated data (AAD). The data is
/// of the form `sender_public||sender_public_len||receiver_public||receiver_public_len`.
/// This is taken from QOS here: https://github.com/tkhq/qos/blob/ae01904c756107f850aea42000137ef124df3fe4/src/qos_p256/src/encrypt.rs#L298
///
/// Note that we append the length to each field as per NIST specs here: <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar3.pdf/>. See section 5.8.2.
function createAdditionalAssociatedData(ephemeralSenderPublic, receiverPublic) {
    // get the length of the sending and receiver public keys
    const ephemeralSenderLength = ephemeralSenderPublic.length;
    const receiverPublicLength = receiverPublic.length;
    // ensure the lengths are under 1 byte
    if (ephemeralSenderLength > 255 || receiverPublicLength > 255) throw new Error("AAD len fields are 1 byte");
    // allocate an array the size of both keys + 1 byte for their length
    const aad = new Uint8Array(ephemeralSenderLength + 1 + receiverPublicLength + 1);
    // keep track of the offset within the array
    let offset = 0;
    // set the bytes that represent the sender public key + its length
    aad.set(ephemeralSenderPublic, offset);
    offset += ephemeralSenderLength;
    aad[offset++] = ephemeralSenderLength;
    // set the bytes that represent the receiver public key + its length
    aad.set(receiverPublic, offset);
    offset += receiverPublicLength;
    aad[offset++] = receiverPublicLength;
    return aad;
}
;
 //# sourceMappingURL=crypto.mjs.map
}),
"[project]/node_modules/@turnkey/crypto/dist/turnkey.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Enclave",
    ()=>Enclave,
    "decryptCredentialBundle",
    ()=>decryptCredentialBundle,
    "decryptExportBundle",
    ()=>decryptExportBundle,
    "encryptOauth2ClientSecret",
    ()=>encryptOauth2ClientSecret,
    "encryptOnRampSecret",
    ()=>encryptOnRampSecret,
    "encryptPrivateKeyToBundle",
    ()=>encryptPrivateKeyToBundle,
    "encryptToEnclave",
    ()=>encryptToEnclave,
    "encryptWalletToBundle",
    ()=>encryptWalletToBundle,
    "verifySessionJwtSignature",
    ()=>verifySessionJwtSignature,
    "verifyStampSignature",
    ()=>verifyStampSignature
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$bs58check$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/bs58check.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/hex.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$bs58$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/bs58.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/dist/constants.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/dist/crypto.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$p256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/node_modules/@noble/curves/esm/p256.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$ed25519$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/node_modules/@noble/curves/esm/ed25519.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/sha256.js [app-client] (ecmascript)");
;
;
;
;
;
;
/// <reference lib="dom" />
// Turnkey-specific cryptographic utilities
var Enclave;
(function(Enclave) {
    Enclave["NOTARIZER"] = "notarizer";
    Enclave["SIGNER"] = "signer";
    Enclave["EVM_PARSER"] = "evm-parser";
    Enclave["TLS_FETCHER"] = "tls-fetcher";
    Enclave["UMP"] = "ump";
})(Enclave || (Enclave = {}));
/**
 * Decrypt an encrypted email auth/recovery or oauth credential bundle.
 *
 * @param {string} credentialBundle - The encrypted credential bundle.
 * @param {string} embeddedKey - The private key for decryption.
 * @returns {string} - The decrypted data or null if decryption fails.
 * @throws {Error} - If unable to decrypt the credential bundle
 */ const decryptCredentialBundle = (credentialBundle, embeddedKey)=>{
    try {
        const bundleBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$bs58check$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bs58check"].decode(credentialBundle);
        if (bundleBytes.byteLength <= 33) {
            throw new Error(`Bundle size ${bundleBytes.byteLength} is too low. Expecting a compressed public key (33 bytes) and an encrypted credential.`);
        }
        const compressedEncappedKeyBuf = bundleBytes.slice(0, 33);
        const ciphertextBuf = bundleBytes.slice(33);
        const encappedKeyBuf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uncompressRawPublicKey"])(compressedEncappedKeyBuf);
        const decryptedData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hpkeDecrypt"])({
            ciphertextBuf,
            encappedKeyBuf,
            receiverPriv: embeddedKey
        });
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(decryptedData);
    } catch (error) {
        throw new Error(`"Error decrypting bundle:", ${error}`);
    }
};
/**
 * Decrypt an encrypted export bundle (such as a private key or wallet account bundle).
 *
 * This function verifies the enclave signature to ensure the authenticity of the encrypted data.
 * It uses HPKE (Hybrid Public Key Encryption) to decrypt the contents of the bundle and returns
 * either the decrypted mnemonic or the decrypted data in hexadecimal format, based on the
 * `returnMnemonic` flag.
 *
 * @param {DecryptExportBundleParams} params - An object containing the following properties:
 *   - exportBundle {string}: The encrypted export bundle in JSON format.
 *   - organizationId {string}: The expected organization ID to verify against the signed data.
 *   - embeddedKey {string}: The private key used for decrypting the data.
 *   - dangerouslyOverrideSignerPublicKey {string} [Optional]: Optionally override the default signer public key used for verifying the signature. This should only be done for testing
 *   - returnMnemonic {boolean}: If true, returns the decrypted data as a mnemonic string; otherwise, returns it in hexadecimal format.
 * @returns {Promise<string>} - A promise that resolves to the decrypted mnemonic or decrypted hexadecimal data.
 * @throws {Error} - If decryption or signature verification fails, throws an error with details.
 */ const decryptExportBundle = async ({ exportBundle, embeddedKey, organizationId, dangerouslyOverrideSignerPublicKey, keyFormat, returnMnemonic })=>{
    try {
        const parsedExportBundle = JSON.parse(exportBundle);
        const verified = await verifyEnclaveSignature(parsedExportBundle.enclaveQuorumPublic, parsedExportBundle.dataSignature, parsedExportBundle.data, dangerouslyOverrideSignerPublicKey);
        if (!verified) {
            throw new Error(`failed to verify enclave signature: ${parsedExportBundle}`);
        }
        const signedData = JSON.parse(new TextDecoder().decode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(parsedExportBundle.data)));
        if (!signedData.organizationId || signedData.organizationId !== organizationId) {
            throw new Error(`organization id does not match expected value. Expected: ${organizationId}. Found: ${signedData.organizationId}.`);
        }
        if (!signedData.encappedPublic) {
            throw new Error('missing "encappedPublic" in bundle signed data');
        }
        const encappedKeyBuf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(signedData.encappedPublic);
        const ciphertextBuf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(signedData.ciphertext);
        const decryptedData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hpkeDecrypt"])({
            ciphertextBuf,
            encappedKeyBuf,
            receiverPriv: embeddedKey
        });
        if (keyFormat === "SOLANA" && !returnMnemonic) {
            if (decryptedData.length !== 32) {
                throw new Error(`invalid private key length. Expected 32 bytes. Got ${decryptedData.length}.`);
            }
            const publicKeyBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$ed25519$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ed25519"].getPublicKey(decryptedData);
            if (publicKeyBytes.length !== 32) {
                throw new Error(`invalid public key length. Expected 32 bytes. Got ${publicKeyBytes.length}.`);
            }
            const concatenatedBytes = new Uint8Array(64);
            concatenatedBytes.set(decryptedData, 0);
            concatenatedBytes.set(publicKeyBytes, 32);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$bs58$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bs58"].encode(concatenatedBytes);
        }
        const decryptedDataHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(decryptedData);
        return returnMnemonic ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hexToAscii"])(decryptedDataHex) : decryptedDataHex;
    } catch (error) {
        throw new Error(`Error decrypting bundle: ${error}`);
    }
};
/**
 * Verifies a signature from a Turnkey stamp using ECDSA and SHA-256.
 *
 * @param {string} publicKey - The public key of the authenticator (e.g. WebAuthn or P256 API key).
 * @param {string} signature - The ECDSA signature in DER format.
 * @param {string} signedData - The data that was signed (e.g. JSON-stringified Turnkey request body).
 * @returns {Promise<boolean>} - Returns true if the signature is valid, otherwise throws an error.
 *
 * @example
 *
 * const stampedRequest = await turnkeyClient.stampGetWhoami(...);
 * const decodedStampContents = atob(stampedRequest.stamp.stampHeaderValue);
 * const parsedStampContents = JSON.parse(decodedStampContents);
 * const signature = parsedStampContents.signature;
 *
 * await verifyStampSignature(publicKey, signature, stampedRequest.body)
 */ const verifyStampSignature = async (publicKey, signature, signedData)=>{
    const publicKeyBuffer = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(publicKey);
    const loadedPublicKey = loadPublicKey(publicKeyBuffer);
    if (!loadedPublicKey) {
        throw new Error("failed to load public key");
    }
    // Convert the ASN.1 DER-encoded signature for verification
    const publicSignatureBuf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromDerSignature"])(signature);
    const signedDataBuf = new TextEncoder().encode(signedData);
    const hashedData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"])(signedDataBuf);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$p256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["p256"].verify(publicSignatureBuf, hashedData, loadedPublicKey.toHex());
};
/**
 * Verifies a signature from a Turnkey enclave using ECDSA and SHA-256.
 *
 * @param {string} enclaveQuorumPublic - The public key of the enclave signer.
 * @param {string} publicSignature - The ECDSA signature in DER format.
 * @param {string} signedData - The data that was signed.
 * @param {Environment} dangerouslyOverrideSignerPublicKey - (optional) an enum (PROD or PREPROD) to verify against the correct signer enclave key.
 * @returns {Promise<boolean>} - Returns true if the signature is valid, otherwise throws an error.
 */ const verifyEnclaveSignature = async (enclaveQuorumPublic, publicSignature, signedData, dangerouslyOverrideSignerPublicKey)=>{
    const expectedSignerPublicKey = dangerouslyOverrideSignerPublicKey || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PRODUCTION_SIGNER_SIGN_PUBLIC_KEY"];
    if (enclaveQuorumPublic != expectedSignerPublicKey) {
        throw new Error(`expected signer key ${dangerouslyOverrideSignerPublicKey ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PRODUCTION_SIGNER_SIGN_PUBLIC_KEY"]} does not match signer key from bundle: ${enclaveQuorumPublic}`);
    }
    const encryptionQuorumPublicBuf = new Uint8Array((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(enclaveQuorumPublic));
    const quorumKey = loadPublicKey(encryptionQuorumPublicBuf);
    if (!quorumKey) {
        throw new Error("failed to load quorum key");
    }
    // Convert the ASN.1 DER-encoded signature for verification
    const publicSignatureBuf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromDerSignature"])(publicSignature);
    const signedDataBuf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(signedData);
    const hashedData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"])(signedDataBuf);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$p256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["p256"].verify(publicSignatureBuf, hashedData, quorumKey.toHex());
};
/**
 * Loads an ECDSA public key from a raw format for signature verification.
 *
 * @param {Uint8Array} publicKey - The raw P-256 public key bytes.
 * @returns {ProjPointType<bigint>} - The parsed ECDSA public key.
 * @throws {Error} - If the public key is invalid.
 */ const loadPublicKey = (publicKey)=>{
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$p256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["p256"].ProjectivePoint.fromHex((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(publicKey));
};
/**
 * Decodes a private key based on the specified format.
 *
 * @param {string} privateKey - The private key to decode.
 * @param {string} keyFormat - The format of the private key (e.g., "SOLANA", "HEXADECIMAL").
 * @returns {Uint8Array} - The decoded private key.
 */ const decodeKey = (privateKey, keyFormat)=>{
    switch(keyFormat){
        case "SOLANA":
            const decodedKeyBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$bs58$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bs58"].decode(privateKey);
            if (decodedKeyBytes.length !== 64) {
                throw new Error(`invalid key length. Expected 64 bytes. Got ${decodedKeyBytes.length}.`);
            }
            return decodedKeyBytes.subarray(0, 32);
        case "HEXADECIMAL":
            if (privateKey.startsWith("0x")) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(privateKey.slice(2));
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(privateKey);
        default:
            console.warn(`invalid key format: ${keyFormat}. Defaulting to HEXADECIMAL.`);
            if (privateKey.startsWith("0x")) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(privateKey.slice(2));
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(privateKey);
    }
};
/**
 * Encrypts a private key bundle using HPKE and verifies the enclave signature.
 *
 * @param {EncryptPrivateKeyToBundleParams} params - An object containing the private key, key format, bundle, user, and organization details. Optionally, you can override the default signer key (for testing purposes)
 * @returns {Promise<string>} - A promise that resolves to a JSON string representing the encrypted bundle.
 * @throws {Error} - If enclave signature verification or any other validation fails.
 */ const encryptPrivateKeyToBundle = async ({ privateKey, keyFormat, importBundle, userId, organizationId, dangerouslyOverrideSignerPublicKey })=>{
    const parsedImportBundle = JSON.parse(importBundle);
    const plainTextBuf = decodeKey(privateKey, keyFormat);
    const verified = await verifyEnclaveSignature(parsedImportBundle.enclaveQuorumPublic, parsedImportBundle.dataSignature, parsedImportBundle.data, dangerouslyOverrideSignerPublicKey);
    if (!verified) {
        throw new Error(`failed to verify enclave signature: ${importBundle}`);
    }
    const signedData = JSON.parse(new TextDecoder().decode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(parsedImportBundle.data)));
    if (!signedData.organizationId || signedData.organizationId !== organizationId) {
        throw new Error(`organization id does not match expected value. Expected: ${organizationId}. Found: ${signedData.organizationId}.`);
    }
    if (!signedData.userId || signedData.userId !== userId) {
        throw new Error(`user id does not match expected value. Expected: ${userId}. Found: ${signedData.userId}.`);
    }
    if (!signedData.targetPublic) {
        throw new Error('missing "targetPublic" in bundle signed data');
    }
    // Load target public key generated from enclave
    const targetKeyBuf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(signedData.targetPublic);
    const privateKeyBundle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hpkeEncrypt"])({
        plainTextBuf,
        targetKeyBuf
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatHpkeBuf"])(privateKeyBundle);
};
/**
  /**
   * Encrypts a mnemonic wallet bundle using HPKE and verifies the enclave signature.
   *
   * @param {EncryptWalletToBundleParams} params - An object containing the mnemonic, bundle, user, and organization details. Optionally, you can override the default signer key (for testing purposes).
   * @returns {Promise<string>} - A promise that resolves to a JSON string representing the encrypted wallet bundle.
   * @throws {Error} - If enclave signature verification or any other validation fails.
   */ const encryptWalletToBundle = async ({ mnemonic, importBundle, userId, organizationId, dangerouslyOverrideSignerPublicKey })=>{
    const parsedImportBundle = JSON.parse(importBundle);
    const plainTextBuf = new TextEncoder().encode(mnemonic);
    const verified = await verifyEnclaveSignature(parsedImportBundle.enclaveQuorumPublic, parsedImportBundle.dataSignature, parsedImportBundle.data, dangerouslyOverrideSignerPublicKey);
    if (!verified) {
        throw new Error(`failed to verify enclave signature: ${importBundle}`);
    }
    const signedData = JSON.parse(new TextDecoder().decode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(parsedImportBundle.data)));
    if (!signedData.organizationId || signedData.organizationId !== organizationId) {
        throw new Error(`organization id does not match expected value. Expected: ${organizationId}. Found: ${signedData.organizationId}.`);
    }
    if (!signedData.userId || signedData.userId !== userId) {
        throw new Error(`user id does not match expected value. Expected: ${userId}. Found: ${signedData.userId}.`);
    }
    if (!signedData.targetPublic) {
        throw new Error('missing "targetPublic" in bundle signed data');
    }
    // Load target public key generated from enclave
    const targetKeyBuf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(signedData.targetPublic);
    const privateKeyBundle = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hpkeEncrypt"])({
        plainTextBuf,
        targetKeyBuf
    });
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatHpkeBuf"])(privateKeyBundle);
};
/**
 * Verifies that a **session JWT** was signed by Turnkeys
 * notarizer key (P-256 / ES256, compact 64-byte rs signature).
 *
 * How it works
 * ------------
 * 1.  Split the JWT into `header.payload.signature`.
 * 2.  **Double-hash** the string `"header.payload"`:
 *        `h1 = sha256(header.payload)`
 *        `msg = sha256(h1)`
 *     (The Rust signer feeds `h1` into `SigningKey::sign`, which hashes once
 *     more internally, yielding `msg`.)
 * 3.  Base64-URL-decode the signature (`r||s`, 64 bytes).
 * 4.  Import the notarizer public key (hex `04XY`  `Uint8Array`).
 * 5.  Call `p256.verify(signature, msg, publicKey)`; noble treats the 32-byte
 *     `msg` as a pre-hashed digest and performs ECDSA verification.
 *
 * @param jwt   The session JWT to validate.
 * @param dangerouslyOverrideNotarizerPublicKey *(optional)* Hex-encoded
 *              uncompressed P-256 public key to verify against (use only in
 *              tests).  Defaults to the production notarizer key.
 * @returns `true` if the signature is valid for the given key, else `false`.
 * @throws  If the JWT is malformed.
 */ const verifySessionJwtSignature = async (jwt, dangerouslyOverrideNotarizerPublicKey)=>{
    const notarizerKeyHex = dangerouslyOverrideNotarizerPublicKey ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PRODUCTION_NOTARIZER_SIGN_PUBLIC_KEY"];
    /* 1. split JWT -------------------------------------------------------- */ const [headerB64, payloadB64, signatureB64] = jwt.split(".");
    if (!signatureB64) throw new Error("invalid JWT: need 3 parts");
    const signingInput = `${headerB64}.${payloadB64}`;
    /* 2. sha256(sha256(header.payload)) ----------------------------------- */ const h1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"])(new TextEncoder().encode(signingInput));
    const msgDigest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"])(h1); // 32-byte Uint8Array
    /* 3. base64-url decode signature -------------------------------------- */ const toB64 = (u)=>(u = u.replace(/-/g, "+").replace(/_/g, "/")).padEnd(u.length + (4 - u.length % 4) % 4, "=");
    const signature = Uint8Array.from(atob(toB64(signatureB64)).split("").map((c)=>c.charCodeAt(0))); // 64 bytes
    /* 4. load public key -------------------------------------------------- */ const publicKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(notarizerKeyHex);
    /* 5. verify ----------------------------------------------------------- */ return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$p256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["p256"].verify(signature, msgDigest, publicKey);
};
/**
 * Encrypts a message to an uncompressed P256 public key
 * The function takes in standard strings and converts them
 * to Uint8Arrays to be used by the lower level quorumKeyEncrypt
 * function. More details about how the encryption works is described
 * in that function's documentation.
 *
 * @param targetPublicKeyUncompressed A hex string uncompressed public key to encrypt a message to
 * @param message A standard string message to encrypt, does not have to be hex encoded
 * @returns {Promise<Uint8Array>} A borsh serialized envelope with the encrypted message (more details found in quorumKeyEncrypt)
 */ const encryptToEnclave = async (targetPublicKeyUncompressed, message)=>{
    return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["quorumKeyEncrypt"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(targetPublicKeyUncompressed), new TextEncoder().encode(message));
};
/**
 * Helper function used specifically to encrypt a client secret to
 * TLS Fetchers quorum key. This is used for client_secret upload
 * when enabling authentication with an OAuth 2.0 provider
 *
 * @param client_secret The client secret issued by the OAuth 2.0 provider
 * @param dangerouslyOverrideTlsFetcherPublicKey *(optional)* Hex-encoded
 *              uncompressed P-256 public key to encrypt to (use only in
 *              tests/dev environment).  Defaults to the production TLS Fetcher key.
 * @returns {Promise<string>} A hex encoded borsh serialized envelope with the encrypted client
 *                            secret meant to be passed to the CreateOauth2Credential Activity
 */ const encryptOauth2ClientSecret = async (client_secret, dangerouslyOverrideTlsFetcherPublicKey)=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(await encryptToEnclave(dangerouslyOverrideTlsFetcherPublicKey ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PRODUCTION_TLS_FETCHER_ENCRYPT_PUBLIC_KEY"], client_secret));
};
/**
 * Helper function used specifically to encrypt your on ramp private/secret api keys
 * to the on ramp encryption public key. This is used before uploading your on ramp
 * credentials to Turnkey via the CreateFiatOnRampCredential activity
 *
 * @param secret The private/secret api key issued by the on ramp provider
 * @param dangerouslyOverrideOnRampEncryptionPublicKey *(optional)* Hex-encoded
 *              uncompressed P-256 public key to encrypt to (use only in
 *              tests/dev environment).  Defaults to the production on ramp encryption public key.
 * @returns {Promise<string>} A base58check encoded borsh serialized envelope with the encrypted secret
 *                            meant to be passed to the CreateFiatOnRampCredential activity
 */ const encryptOnRampSecret = (secret, dangerouslyOverrideOnRampEncryptionPublicKey)=>{
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$bs58check$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bs58check"].encode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hpkeEncrypt"])({
        plainTextBuf: new TextEncoder().encode(secret),
        targetKeyBuf: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uncompressRawPublicKey"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(dangerouslyOverrideOnRampEncryptionPublicKey ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PRODUCTION_ON_RAMP_CREDENTIALS_ENCRYPTION_PUBLIC_KEY"]))
    }));
};
;
 //# sourceMappingURL=turnkey.mjs.map
}),
"[project]/node_modules/@turnkey/crypto/dist/proof.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getCryptoInstance",
    ()=>getCryptoInstance,
    "verify",
    ()=>verify,
    "verifyAppProofSignature",
    ()=>verifyAppProofSignature,
    "verifyCertificateChain",
    ()=>verifyCertificateChain,
    "verifyCoseSign1Sig",
    ()=>verifyCoseSign1Sig
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/hex.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$p256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/node_modules/@noble/curves/esm/p256.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/sha2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$js$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cbor-js/cbor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$peculiar$2f$x509$2f$build$2f$x509$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@peculiar/x509/build/x509.es.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/dist/constants.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
const getCryptoInstance = async ()=>{
    let cryptoInstance;
    // Use globalThis.crypto.subtle if available
    if (typeof globalThis !== "undefined" && globalThis.crypto?.subtle) {
        cryptoInstance = globalThis.crypto;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$peculiar$2f$x509$2f$build$2f$x509$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cryptoProvider"].set(cryptoInstance);
        return cryptoInstance;
    } else {
        throw new Error("Web Crypto API is not available in this environment. You may need to polyfill it.");
    }
};
/**
 * Utility: SHA-256 digest  hex (uppercase)
 */ async function sha256Hex(data) {
    const cryptoInstance = await getCryptoInstance();
    const digest = await cryptoInstance.subtle.digest("SHA-256", data);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(new Uint8Array(digest)).toUpperCase();
}
/**
 * Utility: Import SPKI public key for ECDSA verify
 */ async function importEcdsaPublicKey(spki) {
    const cryptoInstance = await getCryptoInstance();
    return cryptoInstance.subtle.importKey("spki", spki, {
        name: "ECDSA",
        namedCurve: "P-384"
    }, false, [
        "verify"
    ]);
}
/**
 * verify goes through the following verification steps for an app proof & boot proof pair:
 *  - Verify app proof signature
 *  - Verify the boot proof
 *    - Attestation doc was signed by AWS
 *    - Attestation doc's `user_data` is the hash of the qos manifest
 *  - Verify the connection between the app proof & boot proof i.e. that the ephemeral keys match
 *
 *  For more information, check out https://whitepaper.turnkey.com/foundations
 */ async function verify(appProof, bootProof) {
    // 1. Verify App Proof
    verifyAppProofSignature(appProof);
    // 2. Verify Boot Proof
    // Parse attestation
    const coseSign1Der = Uint8Array.from(atob(bootProof.awsAttestationDocB64).split("").map((c)=>c.charCodeAt(0)));
    const coseSign1 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$js$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](coseSign1Der.buffer);
    const [, , payload] = coseSign1;
    const attestationDoc = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$js$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](new Uint8Array(payload).buffer);
    // Verify cose sign1 signature
    await verifyCoseSign1Sig(coseSign1, attestationDoc.certificate);
    // Verify certificate chain
    const appProofTimestampMs = parseInt(JSON.parse(appProof.proofPayload).timestampMs);
    await verifyCertificateChain(attestationDoc.cabundle, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AWS_ROOT_CERT_PEM"], attestationDoc.certificate, appProofTimestampMs);
    // Verify manifest digest
    const decodedBootProofManifest = Uint8Array.from(atob(bootProof.qosManifestB64).split("").map((c)=>c.charCodeAt(0)));
    const manifestDigest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"])(decodedBootProofManifest);
    if (!bytesEq(manifestDigest, attestationDoc.user_data)) {
        throw new Error(`attestationDoc's user_data doesn't match the hash of the manifest. attestationDoc.user_data: ${attestationDoc.user_data} , manifest digest: ${manifestDigest}`);
    }
    // 3. Verify that all the ephemeral public keys match: app proof, boot proof structure, actual attestation doc
    const publicKeyBytes = new Uint8Array(attestationDoc.public_key);
    const attestationPubKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(publicKeyBytes);
    if (appProof.publicKey !== attestationPubKey || attestationPubKey !== bootProof.ephemeralPublicKeyHex) {
        throw new Error(`Ephemeral pub keys from app proof: ${appProof.publicKey}, boot proof structure ${bootProof.ephemeralPublicKeyHex}, and attestation doc ${attestationPubKey} should all match`);
    }
}
/**
 * Verify app proof signature with @noble/curves
 */ function verifyAppProofSignature(appProof) {
    if (appProof.scheme !== "SIGNATURE_SCHEME_EPHEMERAL_KEY_P256") {
        throw new Error("Unsupported signature scheme");
    }
    // Decode public key
    let publicKeyBytes;
    try {
        publicKeyBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(appProof.publicKey);
    } catch  {
        throw new Error("Failed to decode public key");
    }
    if (publicKeyBytes.length !== 130) {
        throw new Error(`Expected 130 bytes (encryption + signing pub keys), got ${publicKeyBytes.length} bytes`);
    }
    // Extract signing key (last 65 bytes, uncompressed P-256 point)
    const signingKeyBytes = publicKeyBytes.slice(65);
    if (signingKeyBytes.length !== 65 || signingKeyBytes[0] !== 0x04) {
        throw new Error("Invalid signing key format: expected 65-byte uncompressed P-256 point (0x04||X||Y)");
    }
    // Validate it's a valid P-256 public key by attempting to create a point
    try {
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$p256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["p256"].ProjectivePoint.fromHex(signingKeyBytes);
    } catch (error) {
        throw new Error(`Invalid P-256 public key: ${error}`);
    }
    // Decode signature (64 bytes = 32 bytes r + 32 bytes s)
    let signatureBytes;
    try {
        signatureBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(appProof.signature);
    } catch  {
        throw new Error("Failed to decode signature");
    }
    if (signatureBytes.length !== 64) {
        throw new Error(`Expected 64 bytes signature (r||s), got ${signatureBytes.length} bytes`);
    }
    // Hash the proof payload
    const payloadBytes = new TextEncoder().encode(appProof.proofPayload);
    const payloadDigest = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"])(payloadBytes);
    // Verify ECDSA signature
    const isValid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$node_modules$2f40$noble$2f$curves$2f$esm$2f$p256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["p256"].verify(signatureBytes, payloadDigest, signingKeyBytes);
    if (!isValid) {
        throw new Error("Signature verification failed");
    }
}
async function verifyCertificateChain(cabundle, rootCertPem, leafCert, timestampMs) {
    try {
        // Check root and assert fingerprint
        const rootX509 = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$peculiar$2f$x509$2f$build$2f$x509$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["X509Certificate"](rootCertPem);
        const rootDer = new Uint8Array(rootX509.rawData);
        const rootSha = await sha256Hex(rootDer);
        if (rootSha !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AWS_ROOT_CERT_SHA256"]) {
            throw new Error(`Pinned AWS root fingerprint mismatch: expected=${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$constants$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AWS_ROOT_CERT_SHA256"]} actual=${rootSha}`);
        }
        // Bundle starts with root certificate. We're replacing the root with our hardcoded known certificate, so remove first element
        const bundleWithoutRoot = cabundle.slice(1);
        const intermediatesX509 = bundleWithoutRoot.map((c)=>{
            if (!c) throw new Error("Invalid certificate data in cabundle");
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$peculiar$2f$x509$2f$build$2f$x509$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["X509Certificate"](c);
        });
        const leaf = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$peculiar$2f$x509$2f$build$2f$x509$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["X509Certificate"](leafCert);
        // Build path leaf  intermediates  root, with our hardcoded known root certificate
        const builder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$peculiar$2f$x509$2f$build$2f$x509$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["X509ChainBuilder"]({
            certificates: [
                rootX509,
                ...intermediatesX509
            ]
        });
        const chain = await builder.build(leaf);
        if (chain.length !== intermediatesX509.length + 2) {
            throw new Error(`Incorrect number of certs in X509 Chain. Expected ${intermediatesX509.length + 2}, got ${chain.length}`);
        }
        const appProofDate = new Date(timestampMs);
        for(let i = 0; i < chain.length; i++){
            const cert = chain[i];
            if (!cert) throw new Error("Invalid certificate in chain");
            if (i === chain.length - 1) {
                // is root
                // Self-signature verification for root certificate
                const ok = await cert.verify({
                    publicKey: cert.publicKey,
                    date: appProofDate
                });
                if (!ok) throw new Error("Pinned root failed self-signature verification");
            } else {
                // Verify signature against issuer
                const issuer = chain[i + 1];
                if (!issuer) throw new Error("Issuer can't be null");
                // Attestation docs technically expire after 3 hours, so an app proof generated 3+ hours after an enclave
                // boots up will fail verification due to certificate expiration. This is okay because enclaves are immutable;
                // even if the cert is technically invalid, the code contained within it cannot change. To prevent the cert
                // expiration failure, we set `signatureOnly: true`.
                const ok = await cert.verify({
                    publicKey: issuer.publicKey,
                    signatureOnly: true,
                    date: appProofDate
                });
                if (!ok) {
                    throw new Error(`Signature check failed: ${cert.subject} not signed by ${issuer?.subject}`);
                }
            }
        }
    } catch (error) {
        throw new Error(`Certificate chain verification failed: ${error instanceof Error ? error.message : String(error)}`);
    }
}
async function verifyCoseSign1Sig(coseSign1, leaf) {
    const [protectedHeaders, , payload, signature] = coseSign1;
    const tbs = new Uint8Array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cbor$2d$js$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"]([
        "Signature1",
        new Uint8Array(protectedHeaders),
        new Uint8Array(0),
        new Uint8Array(payload)
    ]));
    const leafCert = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$peculiar$2f$x509$2f$build$2f$x509$2e$es$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["X509Certificate"](leaf);
    const pubKey = await importEcdsaPublicKey(leafCert.publicKey.rawData);
    const cryptoInstance = await getCryptoInstance();
    const ok = await cryptoInstance.subtle.verify({
        name: "ECDSA",
        hash: {
            name: "SHA-384"
        }
    }, pubKey, new Uint8Array(signature), tbs);
    if (!ok) throw new Error("COSE_Sign1 ES384 verification failed");
}
function bytesEq(a, b) {
    const A = new Uint8Array(a), B = new Uint8Array(b);
    if (A.length !== B.length) return false;
    for(let i = 0; i < A.length; i++)if (A[i] !== B[i]) return false;
    return true;
}
;
 //# sourceMappingURL=proof.mjs.map
}),
"[project]/node_modules/@turnkey/crypto/dist/index.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/dist/crypto.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$turnkey$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/dist/turnkey.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$proof$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/dist/proof.mjs [app-client] (ecmascript)"); //# sourceMappingURL=index.mjs.map
;
;
;
}),
"[project]/node_modules/@turnkey/api-key-stamper/dist/tink/bytes.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromHex",
    ()=>fromHex,
    "toBase64",
    ()=>toBase64,
    "toByteString",
    ()=>toByteString,
    "toHex",
    ()=>toHex
]);
/**
 * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/bytes.ts
 *
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ /**
 * Converts the hex string to a byte array.
 *
 * @param hex the input
 * @return the byte array output
 * @throws {!Error}
 * @static
 */ function fromHex(hex) {
    if (hex.length % 2 != 0) {
        throw new Error("Hex string length must be multiple of 2");
    }
    const arr = new Uint8Array(hex.length / 2);
    for(let i = 0; i < hex.length; i += 2){
        arr[i / 2] = parseInt(hex.substring(i, i + 2), 16);
    }
    return arr;
}
/**
 * Converts a byte array to hex.
 *
 * @param bytes the byte array input
 * @return hex the output
 * @static
 */ function toHex(bytes) {
    let result = "";
    for(let i = 0; i < bytes.length; i++){
        const hexByte = bytes[i].toString(16);
        result += hexByte.length > 1 ? hexByte : "0" + hexByte;
    }
    return result;
}
/**
 * Base64 encode a byte array.
 *
 * @param bytes the byte array input
 * @param opt_webSafe True indicates we should use the alternative
 *     alphabet, which does not require escaping for use in URLs.
 * @return base64 output
 * @static
 */ function toBase64(bytes, opt_webSafe) {
    const encoded = btoa(/* padding */ toByteString(bytes)).replace(/=/g, "");
    {
        return encoded.replace(/\+/g, "-").replace(/\//g, "_");
    }
}
/**
 * Turns a byte array into the string given by the concatenation of the
 * characters to which the numbers correspond. Each byte is corresponding to a
 * character. Does not support multi-byte characters.
 *
 * @param bytes Array of numbers representing
 *     characters.
 * @return Stringification of the array.
 */ function toByteString(bytes) {
    let str = "";
    for(let i = 0; i < bytes.length; i += 1){
        str += String.fromCharCode(bytes[i]);
    }
    return str;
}
;
 //# sourceMappingURL=bytes.mjs.map
}),
"[project]/node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "pointDecode",
    ()=>pointDecode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$tink$2f$bytes$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/api-key-stamper/dist/tink/bytes.mjs [app-client] (ecmascript)");
;
/**
 * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts
 * - The implementation of integerToByteArray has been modified to augment the resulting byte array to a certain length.
 * - The implementation of PointDecode has been modified to decode both compressed and uncompressed points by checking for correct format
 * - Method isP256CurvePoint added to check whether an uncompressed point is valid
 *
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */ /**
 * P-256 only
 */ function getModulus() {
    // https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf (Appendix D).
    return BigInt("115792089210356248762697446949407573530086143415290314195533631308" + "867097853951");
}
/**
 * P-256 only
 */ function getB() {
    // https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf (Appendix D).
    return BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
}
/** Converts byte array to bigint. */ function byteArrayToInteger(bytes) {
    return BigInt("0x" + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$tink$2f$bytes$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toHex"])(bytes));
}
/** Converts bigint to byte array. */ function integerToByteArray(i, length) {
    const input = i.toString(16);
    const numHexChars = length * 2;
    let padding = "";
    if (numHexChars < input.length) {
        throw new Error(`cannot pack integer with ${input.length} hex chars into ${length} bytes`);
    } else {
        padding = "0".repeat(numHexChars - input.length);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$tink$2f$bytes$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHex"])(padding + input);
}
/** Returns true iff the ith bit (in lsb order) of n is set. */ function testBit(n, i) {
    const m = BigInt(1) << BigInt(i);
    return (n & m) !== BigInt(0);
}
/**
 * Computes a modular exponent.  Since JavaScript BigInt operations are not
 * constant-time, information about the inputs could leak.  Therefore, THIS
 * METHOD SHOULD ONLY BE USED FOR POINT DECOMPRESSION.
 *
 * @param b base
 * @param exp exponent
 * @param p modulus
 * @return b^exp modulo p
 */ function modPow(b, exp, p) {
    if (exp === BigInt(0)) {
        return BigInt(1);
    }
    let result = b;
    const exponentBitString = exp.toString(2);
    for(let i = 1; i < exponentBitString.length; ++i){
        result = result * result % p;
        if (exponentBitString[i] === "1") {
            result = result * b % p;
        }
    }
    return result;
}
/**
 * Computes a square root modulo an odd prime.  Since timing and exceptions can
 * leak information about the inputs, THIS METHOD SHOULD ONLY BE USED FOR
 * POINT DECOMPRESSION.
 *
 * @param x square
 * @param p prime modulus
 * @return square root of x modulo p
 */ function modSqrt(x, p) {
    if (p <= BigInt(0)) {
        throw new Error("p must be positive");
    }
    const base = x % p;
    // The currently supported NIST curves P-256, P-384, and P-521 all satisfy
    // p % 4 == 3.  However, although currently a no-op, the following check
    // should be left in place in case other curves are supported in the future.
    if (testBit(p, 0) && /* istanbul ignore next */ testBit(p, 1)) {
        // Case p % 4 == 3 (applies to NIST curves P-256, P-384, and P-521)
        // q = (p + 1) / 4
        const q = p + BigInt(1) >> BigInt(2);
        const squareRoot = modPow(base, q, p);
        if (squareRoot * squareRoot % p !== base) {
            throw new Error("could not find a modular square root");
        }
        return squareRoot;
    }
    // Skipping other elliptic curve types that require Cipolla's algorithm.
    throw new Error("unsupported modulus value");
}
/**
 * Computes the y-coordinate of a point on an elliptic curve given its
 * x-coordinate.  Since timing and exceptions can leak information about the
 * inputs, THIS METHOD SHOULD ONLY BE USED FOR POINT DECOMPRESSION.
 *
 * P-256 only
 *
 * @param x x-coordinate
 * @param lsb least significant bit of the y-coordinate
 * @return y-coordinate
 */ function getY(x, lsb) {
    const p = getModulus();
    const a = p - BigInt(3);
    const b = getB();
    const rhs = ((x * x + a) * x + b) % p;
    let y = modSqrt(rhs, p);
    if (lsb !== testBit(y, 0)) {
        y = (p - y) % p;
    }
    return y;
}
/**
 *
 * Given x and y coordinates of a JWK, checks whether these are valid points on
 * the P-256 elliptic curve.
 *
 * P-256 only
 *
 * @param x x-coordinate
 * @param y y-coordinate
 * @return boolean validity
 */ function isP256CurvePoint(x, y) {
    const p = getModulus();
    const a = p - BigInt(3);
    const b = getB();
    const rhs = ((x * x + a) * x + b) % p;
    const lhs = y ** BigInt(2) % p;
    return lhs === rhs;
}
/**
 * Decodes a public key in _compressed_ OR _uncompressed_ format.
 * Augmented to ensure that the x and y components are padded to fit 32 bytes.
 *
 * P-256 only
 */ function pointDecode(point) {
    const fieldSize = fieldSizeInBytes();
    const compressedLength = fieldSize + 1;
    const uncompressedLength = 2 * fieldSize + 1;
    if (point.length !== compressedLength && point.length !== uncompressedLength) {
        throw new Error("Invalid length: point is not in compressed or uncompressed format");
    }
    // Decodes point if its length and first bit match the compressed format
    if ((point[0] === 2 || point[0] === 3) && point.length == compressedLength) {
        const lsb = point[0] === 3; // point[0] must be 2 (false) or 3 (true).
        const x = byteArrayToInteger(point.subarray(1, point.length));
        const p = getModulus();
        if (x < BigInt(0) || x >= p) {
            throw new Error("x is out of range");
        }
        const y = getY(x, lsb);
        const result = {
            kty: "EC",
            crv: "P-256",
            x: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$tink$2f$bytes$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toBase64"])(integerToByteArray(x, 32)),
            y: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$tink$2f$bytes$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toBase64"])(integerToByteArray(y, 32)),
            ext: true
        };
        return result;
    // Decodes point if its length and first bit match the uncompressed format
    } else if (point[0] === 4 && point.length == uncompressedLength) {
        const x = byteArrayToInteger(point.subarray(1, fieldSize + 1));
        const y = byteArrayToInteger(point.subarray(fieldSize + 1, 2 * fieldSize + 1));
        const p = getModulus();
        if (x < BigInt(0) || x >= p || y < BigInt(0) || y >= p || !isP256CurvePoint(x, y)) {
            throw new Error("invalid uncompressed x and y coordinates");
        }
        const result = {
            kty: "EC",
            crv: "P-256",
            x: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$tink$2f$bytes$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toBase64"])(integerToByteArray(x, 32)),
            y: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$tink$2f$bytes$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toBase64"])(integerToByteArray(y, 32)),
            ext: true
        };
        return result;
    }
    throw new Error("invalid format");
}
/**
 * P-256 only
 */ function fieldSizeInBytes() {
    return 32;
}
;
 //# sourceMappingURL=elliptic_curves.mjs.map
}),
"[project]/node_modules/@turnkey/api-key-stamper/dist/index.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ApiKeyStamper",
    ()=>ApiKeyStamper,
    "SignatureFormat",
    ()=>SignatureFormat,
    "signWithApiKey",
    ()=>signWithApiKey
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$base64$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/base64.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/hex.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/dist/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/dist/crypto.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$tink$2f$elliptic_curves$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/api-key-stamper/dist/tink/elliptic_curves.mjs [app-client] (ecmascript)");
;
;
;
/// <reference lib="dom" />
// Header name for an API key stamp
const stampHeaderName = "X-Stamp";
var SignatureFormat;
(function(SignatureFormat) {
    SignatureFormat["Der"] = "der";
    SignatureFormat["Raw"] = "raw";
})(SignatureFormat || (SignatureFormat = {}));
// `window.document` ensures that we're in a browser context
// and `crypto.subtle` ensures that it supports the web crypto APIs
// Inspired by https://github.com/flexdinesh/browser-or-node/blob/master/src/index.ts
const isCryptoEnabledBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof crypto !== "undefined" && typeof crypto.subtle !== "undefined";
// We check `process.versions.node`
// Taken from https://github.com/flexdinesh/browser-or-node/blob/master/src/index.ts
const isNode = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions != null && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions.node != null;
const detectRuntime = ()=>{
    if (isCryptoEnabledBrowser) {
        return "browser";
    }
    if (isNode) {
        return "node";
    }
    // If we don't have NodeJS or web crypto at our disposal, default to pure JS implementation
    // This is the case for old browsers and react native environments
    return "purejs";
};
/**
 * Signature function abstracting the differences between NodeJS and web environments for signing with API keys.
 */ const signWithApiKey = async (input, runtimeOverride)=>{
    const runtime = runtimeOverride ?? detectRuntime();
    switch(runtime){
        case "browser":
            return (await __turbopack_context__.A("[project]/node_modules/@turnkey/api-key-stamper/dist/webcrypto.mjs [app-client] (ecmascript, async loader)")).signWithApiKey(input);
        case "node":
            return (await __turbopack_context__.A("[project]/node_modules/@turnkey/api-key-stamper/dist/nodecrypto.mjs [app-client] (ecmascript, async loader)")).signWithApiKey(input);
        case "purejs":
            return (await __turbopack_context__.A("[project]/node_modules/@turnkey/api-key-stamper/dist/purejs.mjs [app-client] (ecmascript, async loader)")).signWithApiKey(input);
        default:
            throw new Error(`Unsupported runtime: ${runtime}`);
    }
};
/**
 * Stamper to use with `@turnkey/http`'s `TurnkeyClient`
 */ class ApiKeyStamper {
    constructor(config){
        this.apiPublicKey = config.apiPublicKey;
        this.apiPrivateKey = config.apiPrivateKey;
        this.runtimeOverride = config.runtimeOverride;
    }
    async stamp(payload) {
        const signature = await signWithApiKey({
            publicKey: this.apiPublicKey,
            privateKey: this.apiPrivateKey,
            content: payload
        }, this.runtimeOverride);
        const stamp = {
            publicKey: this.apiPublicKey,
            scheme: "SIGNATURE_SCHEME_TK_API_P256",
            signature
        };
        return {
            stampHeaderName,
            stampHeaderValue: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$base64$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringToBase64urlString"])(JSON.stringify(stamp))
        };
    }
    async sign(payload, format) {
        switch(format){
            case SignatureFormat.Raw:
                {
                    const derSignature = await signWithApiKey({
                        publicKey: this.apiPublicKey,
                        privateKey: this.apiPrivateKey,
                        content: payload
                    }, this.runtimeOverride);
                    const raw = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromDerSignature"])(derSignature);
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(raw);
                }
            case SignatureFormat.Der:
                {
                    return signWithApiKey({
                        publicKey: this.apiPublicKey,
                        privateKey: this.apiPrivateKey,
                        content: payload
                    }, this.runtimeOverride);
                }
            default:
                throw new Error(`Unsupported signature format: ${format}`);
        }
    }
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/base64url.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bufferToBase64url",
    ()=>bufferToBase64url
]);
function bufferToBase64url(buffer) {
    // Buffer to binary string
    const byteView = new Uint8Array(buffer);
    let str = "";
    for (const charCode of byteView){
        str += String.fromCharCode(charCode);
    }
    // Binary string to base64
    const base64String = btoa(str);
    // Base64 to base64url
    // We assume that the base64url string is well-formed.
    const base64urlString = base64String.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
    return base64urlString;
}
;
 //# sourceMappingURL=base64url.mjs.map
}),
"[project]/node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/convert.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "convert",
    ()=>convert,
    "convertValue",
    ()=>convertValue,
    "copyValue",
    ()=>copyValue,
    "derived",
    ()=>derived,
    "optional",
    ()=>optional,
    "required",
    ()=>required
]);
// We export these values in order so that they can be used to deduplicate
// schema definitions in minified JS code.
// TODO: Parcel isn't deduplicating these values.
const copyValue = "copy";
const convertValue = "convert";
function convert(conversionFn, schema, input) {
    if (schema === copyValue) {
        return input;
    }
    if (schema === convertValue) {
        return conversionFn(input);
    }
    if (schema instanceof Array) {
        return input.map((v)=>convert(conversionFn, schema[0], v));
    }
    if (schema instanceof Object) {
        const output = {};
        for (const [key, schemaField] of Object.entries(schema)){
            if (schemaField.derive) {
                const v = schemaField.derive(input);
                if (v !== undefined) {
                    input[key] = v;
                }
            }
            if (!(key in input)) {
                if (schemaField.required) {
                    throw new Error(`Missing key: ${key}`);
                }
                continue;
            }
            // Fields can be null (rather than missing or `undefined`), e.g. the
            // `userHandle` field of the `AuthenticatorAssertionResponse`:
            // https://www.w3.org/TR/webauthn/#iface-authenticatorassertionresponse
            if (input[key] == null) {
                output[key] = null;
                continue;
            }
            output[key] = convert(conversionFn, schemaField.schema, input[key]);
        }
        return output;
    }
}
function derived(schema, derive) {
    return {
        required: true,
        schema,
        derive
    };
}
function required(schema) {
    return {
        required: true,
        schema
    };
}
function optional(schema) {
    return {
        required: false,
        schema
    };
}
;
 //# sourceMappingURL=convert.mjs.map
}),
"[project]/node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/schema.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "publicKeyCredentialWithAssertion",
    ()=>publicKeyCredentialWithAssertion
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/convert.mjs [app-client] (ecmascript)");
;
const simplifiedClientExtensionResultsSchema = {
    appid: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optional"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copyValue"]),
    appidExclude: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optional"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copyValue"]),
    credProps: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optional"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copyValue"])
};
// `navigator.get()` response
const publicKeyCredentialWithAssertion = {
    type: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copyValue"]),
    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copyValue"]),
    rawId: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertValue"]),
    authenticatorAttachment: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["optional"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["copyValue"]),
    response: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])({
        clientDataJSON: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertValue"]),
        authenticatorData: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertValue"]),
        signature: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertValue"]),
        userHandle: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["required"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertValue"])
    }),
    clientExtensionResults: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["derived"])(simplifiedClientExtensionResultsSchema, (pkc)=>pkc.getClientExtensionResults())
};
;
 //# sourceMappingURL=schema.mjs.map
}),
"[project]/node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/api.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "getResponseToJSON",
    ()=>getResponseToJSON
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$base64url$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/base64url.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/convert.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$schema$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/schema.mjs [app-client] (ecmascript)");
;
;
;
function getResponseToJSON(credential) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$convert$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convert"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$base64url$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bufferToBase64url"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$schema$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["publicKeyCredentialWithAssertion"], credential);
}
;
 //# sourceMappingURL=api.mjs.map
}),
"[project]/node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "get",
    ()=>get
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$api$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/api.mjs [app-client] (ecmascript)");
;
async function get(options) {
    const response = await navigator.credentials.get(options);
    response.toJSON = ()=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$api$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getResponseToJSON"])(response);
    return response;
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@turnkey/webauthn-stamper/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WebauthnStamper",
    ()=>WebauthnStamper
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/webauthn-stamper/dist/webauthn-json/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sha256$2d$uint8array$2f$dist$2f$sha256$2d$uint8array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/sha256-uint8array/dist/sha256-uint8array.mjs [app-client] (ecmascript)");
;
;
/// <reference lib="dom" />
// Header name for a webauthn stamp
const stampHeaderName = "X-Stamp-Webauthn";
const defaultTimeout = 5 * 60 * 1000; // five minutes
const defaultUserVerification = "preferred";
/**
 * Stamper to use with `@turnkey/http`'s `TurnkeyClient`
 */ class WebauthnStamper {
    constructor(config){
        this.rpId = config.rpId;
        this.timeout = config.timeout || defaultTimeout;
        this.userVerification = config.userVerification || defaultUserVerification;
        this.allowCredentials = config.allowCredentials || [];
    }
    async stamp(payload) {
        const challenge = getChallengeFromPayload(payload);
        const signingOptions = {
            publicKey: {
                rpId: this.rpId,
                challenge: challenge,
                allowCredentials: this.allowCredentials,
                timeout: this.timeout,
                userVerification: this.userVerification
            }
        };
        const clientGetResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$webauthn$2d$json$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["get"])(signingOptions);
        const assertion = clientGetResult.toJSON();
        const stamp = {
            authenticatorData: assertion.response.authenticatorData,
            clientDataJson: assertion.response.clientDataJSON,
            credentialId: assertion.id,
            signature: assertion.response.signature
        };
        return {
            stampHeaderName: stampHeaderName,
            stampHeaderValue: JSON.stringify(stamp)
        };
    }
}
function getChallengeFromPayload(payload) {
    const hexString = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sha256$2d$uint8array$2f$dist$2f$sha256$2d$uint8array$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createHash"])().update(payload).digest("hex");
    return new TextEncoder().encode(hexString);
}
;
 //# sourceMappingURL=index.mjs.map
}),
"[project]/node_modules/@turnkey/iframe-stamper/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "IframeEventType",
    ()=>IframeEventType,
    "IframeStamper",
    ()=>IframeStamper,
    "KeyFormat",
    ()=>KeyFormat,
    "MessageType",
    ()=>MessageType,
    "TransactionType",
    ()=>TransactionType
]);
/// <reference lib="dom" />
// Header name for an API key stamp
const stampHeaderName = "X-Stamp";
// Set of constants for event types expected to be sent and received between a parent page and its iframe.
var IframeEventType;
(function(IframeEventType) {
    // Event sent by the iframe to its parent to indicate readiness.
    // Value: the iframe public key
    IframeEventType["PublicKeyReady"] = "PUBLIC_KEY_READY";
    // Event sent by the parent to inject a credential bundle (for recovery or auth) into the iframe.
    // Value: the bundle to inject
    IframeEventType["InjectCredentialBundle"] = "INJECT_CREDENTIAL_BUNDLE";
    // Event sent by the parent to inject a private key export bundle into the iframe.
    // Value: the bundle to inject
    // Key Format (optional): the key format to encode the private key in after it's exported and decrypted: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.
    // Public Key (optional): the public key of the exported private key. Required when the key format is SOLANA.
    IframeEventType["InjectKeyExportBundle"] = "INJECT_KEY_EXPORT_BUNDLE";
    // Event sent by the parent to inject a wallet export bundle into the iframe.
    // Value: the bundle to inject
    IframeEventType["InjectWalletExportBundle"] = "INJECT_WALLET_EXPORT_BUNDLE";
    // Event sent by the parent to inject an import bundle into the iframe.
    // Value: the bundle to inject
    IframeEventType["InjectImportBundle"] = "INJECT_IMPORT_BUNDLE";
    // Event sent by the parent to extract an encrypted wallet bundle from the iframe.
    // Value: none
    IframeEventType["ExtractWalletEncryptedBundle"] = "EXTRACT_WALLET_ENCRYPTED_BUNDLE";
    // Event sent by the parent to extract an encrypted private key bundle from the iframe.
    // Value: none
    // Key Format (optional): the key format to decode the private key in before it's encrypted for import: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.
    IframeEventType["ExtractKeyEncryptedBundle"] = "EXTRACT_KEY_ENCRYPTED_BUNDLE";
    // Event sent by the parent to apply settings on the iframe.
    // Value: the settings to apply in JSON string format.
    IframeEventType["ApplySettings"] = "APPLY_SETTINGS";
    // Event sent by the iframe to its parent when `InjectBundle` is successful
    // Value: true (boolean)
    IframeEventType["BundleInjected"] = "BUNDLE_INJECTED";
    // Event sent by the iframe to its parent when `ExtractEncryptedBundle` is successful
    // Value: the bundle encrypted in the iframe
    IframeEventType["EncryptedBundleExtracted"] = "ENCRYPTED_BUNDLE_EXTRACTED";
    // Event sent by the iframe to its parent when `ApplySettings` is successful
    // Value: true (boolean)
    IframeEventType["SettingsApplied"] = "SETTINGS_APPLIED";
    // Event sent by the iframe to its parent when `signTransaction` is successful
    // Value: true (boolean)
    IframeEventType["TransactionSigned"] = "TRANSACTION_SIGNED";
    // Event sent by the iframe to its parent when `signMessage` is successful
    // Value: true (boolean)
    IframeEventType["MessageSigned"] = "MESSAGE_SIGNED";
    // Event sent by the iframe to its parent when `clearEmbeddedPrivateKey` is successful
    // Value: true (boolean)
    IframeEventType["EmbeddedPrivateKeyCleared"] = "EMBEDDED_PRIVATE_KEY_CLEARED";
    // Event sent by the parent page to request a signature
    // Value: payload to sign
    IframeEventType["StampRequest"] = "STAMP_REQUEST";
    // Event sent by the iframe to communicate the result of a stamp operation.
    // Value: signed payload
    IframeEventType["Stamp"] = "STAMP";
    // Event sent by the parent to establish secure communication via MessageChannel API.
    // Value: MessageChannel port
    IframeEventType["TurnkeyInitMessageChannel"] = "TURNKEY_INIT_MESSAGE_CHANNEL";
    // Event sent by the parent to get the iframe target embedded key's public key.
    // Value: the iframe public key
    IframeEventType["GetEmbeddedPublicKey"] = "GET_EMBEDDED_PUBLIC_KEY";
    // Event sent by the parent to clear the iframe's embedded key.
    // Value: none
    IframeEventType["ClearEmbeddedKey"] = "RESET_EMBEDDED_KEY";
    // Event sent by the parent to initialize a new embedded key.
    // Value: none
    IframeEventType["InitEmbeddedKey"] = "INIT_EMBEDDED_KEY";
    // Event sent by the parent page to request a signature for a transaction.
    // Value: payload to sign
    IframeEventType["SignTransaction"] = "SIGN_TRANSACTION";
    // Event sent by the parent page to request a signature for a message.
    // Value: payload to sign
    IframeEventType["SignMessage"] = "SIGN_MESSAGE";
    // Event sent by the parent page to request that the iframe embedded private key is cleared from memory.
    // Value: none
    IframeEventType["clearEmbeddedPrivateKey"] = "CLEAR_EMBEDDED_PRIVATE_KEY";
    // Event sent by the iframe to communicate an error
    // Value: serialized error
    IframeEventType["Error"] = "ERROR";
})(IframeEventType || (IframeEventType = {}));
// Set of constants for private key formats. These formats map to the encoding type used on a private key before encrypting and importing it
// or after exporting it and decrypting it.
var KeyFormat;
(function(KeyFormat) {
    // 64 hexadecimal digits. Key format used by MetaMask, MyEtherWallet, Phantom, Ledger, and Trezor for Ethereum and Tron keys
    KeyFormat["Hexadecimal"] = "HEXADECIMAL";
    // Key format used by Phantom and Solflare for Solana keys
    KeyFormat["Solana"] = "SOLANA";
    // Wallet Import Format used by Main Net Bitcoin wallets like Electrum and Bitcoin Core
    KeyFormat["BitcoinMainNetWIF"] = "BITCOIN_MAINNET_WIF";
    // Wallet Import Format used by Test Net Bitcoin wallets like Electrum and Bitcoin Core
    KeyFormat["BitcoinTestNetWIF"] = "BITCOIN_TESTNET_WIF";
    // Bech32 format used by modern Bitcoin wallets & Sui wallets
    KeyFormat["SuiBech32"] = "SUI_BECH32";
})(KeyFormat || (KeyFormat = {}));
var MessageType;
(function(MessageType) {
    MessageType["Ethereum"] = "ETHEREUM";
    MessageType["Solana"] = "SOLANA";
})(MessageType || (MessageType = {}));
var TransactionType;
(function(TransactionType) {
    TransactionType["Ethereum"] = "ETHEREUM";
    TransactionType["Solana"] = "SOLANA";
})(TransactionType || (TransactionType = {}));
function generateUUID() {
    return crypto.randomUUID();
}
/**
 * Stamper to use with `@turnkey/http`'s `TurnkeyClient`
 * Creating a stamper inserts an iframe in the current page.
 */ class IframeStamper {
    /**
     * Creates a new iframe stamper. This function _does not_ insert the iframe in the DOM.
     * Call `.init()` to insert the iframe element in the DOM.
     * @param {TIframeStamperConfig} config - Configuration object for the iframe stamper
     * @throws {Error} When running in non-browser environment
     * @throws {Error} When MessageChannel is not supported
     * @throws {Error} When iframeContainer is not provided
     * @throws {Error} When iframe element with the same ID already exists
     */ constructor(config){
        if (typeof window === "undefined") {
            throw new Error("Cannot initialize iframe in non-browser environment");
        }
        if (typeof MessageChannel === "undefined") {
            throw new Error("Cannot initialize iframe without MessageChannel support");
        }
        if (!config.iframeContainer) {
            throw new Error("Iframe container cannot be found");
        }
        this.container = config.iframeContainer;
        if (this.container.querySelector(`#${config.iframeElementId}`)) {
            throw new Error(`Iframe element with ID ${config.iframeElementId} already exists`);
        }
        let iframe = window.document.createElement("iframe");
        // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#sandbox
        // We do not need any other permission than running scripts for import/export/auth frames.
        iframe.setAttribute("sandbox", "allow-scripts allow-same-origin");
        iframe.id = config.iframeElementId;
        iframe.src = config.iframeUrl;
        if (config.clearClipboardOnPaste ?? true) {
            iframe.allow = "clipboard-write"; // Clipboard will clear when pasting in the iframe
        }
        this.iframe = iframe;
        const iframeUrl = new URL(config.iframeUrl);
        this.iframeOrigin = iframeUrl.origin;
        // This is populated once the iframe is ready. Call `.init()` to kick off DOM insertion!
        this.iframePublicKey = null;
        /**
         * The MessageChannel API is used to establish secure communication between two execution contexts.
         * In this case, the parent page and the iframe.
         * See https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel
         */ this.messageChannel = new MessageChannel();
        // Initialize a pending requests tracker
        this.pendingRequests = new Map();
    }
    /**
     * Handles incoming messages from the iframe via MessageChannel
     * @param {MessageEvent} event - Message event from the iframe
     * @returns {void}
     */ onMessageHandler(event) {
        const { type, value, requestId } = event.data || {};
        // Handle messages without requestId (like PUBLIC_KEY_READY)
        if (!requestId) {
            if (type === IframeEventType.PublicKeyReady) {
                this.iframePublicKey = value;
                return;
            }
            return;
        }
        const pendingRequest = this.pendingRequests.get(requestId);
        if (!pendingRequest) {
            console.warn(`Received response for unknown request: ${requestId}`);
            return;
        }
        // Remove from pending requests
        this.pendingRequests.delete(requestId);
        if (type === IframeEventType.Error) {
            pendingRequest.reject(new Error(value));
            return;
        }
        // Handle specific response types
        switch(type){
            case IframeEventType.Stamp:
                pendingRequest.resolve({
                    stampHeaderName,
                    stampHeaderValue: value
                });
                break;
            default:
                pendingRequest.resolve(value);
        }
    }
    /**
     * Inserts the iframe on the page and returns a promise resolving to the iframe's public key
     * @param {number} [dangerouslyOverrideIframeKeyTtl] - Optional TTL override for the iframe's embedded key (default 48 hours). Only use this if you are intentional about the security implications.
     * @returns {Promise<string>} The iframe's public key
     * @throws {Error} When contentWindow or contentWindow.postMessage does not exist
     */ async init(dangerouslyOverrideIframeKeyTtl) {
        return new Promise((resolve, reject)=>{
            this.container.appendChild(this.iframe);
            this.iframe.addEventListener("load", ()=>{
                if (!this.iframe.contentWindow?.postMessage) {
                    reject(new Error("contentWindow or contentWindow.postMessage does not exist"));
                    return;
                }
                this.iframe.contentWindow.postMessage({
                    type: IframeEventType.TurnkeyInitMessageChannel,
                    dangerouslyOverrideIframeKeyTtl: dangerouslyOverrideIframeKeyTtl
                }, this.iframeOrigin, [
                    this.messageChannel.port2
                ]);
            });
            this.messageChannel.port1.onmessage = (event)=>{
                // Handle initial PublicKeyReady event
                if (event.data?.type === IframeEventType.PublicKeyReady) {
                    this.iframePublicKey = event.data.value;
                    resolve(event.data.value);
                }
                // Handle all other messages
                this.onMessageHandler(event);
            };
        });
    }
    /**
     * Removes the iframe from the DOM and cleans up all resources
     * @returns {void}
     */ clear() {
        this.messageChannel?.port1?.close();
        this.messageChannel?.port2?.close();
        this.iframe.remove();
        this.pendingRequests.clear();
    }
    /**
     * Returns the public key, or `null` if the underlying iframe isn't properly initialized.
     * @returns {string | null} The iframe's public key or null
     */ publicKey() {
        return this.iframePublicKey;
    }
    /**
     * Returns the public key, or `null` if the underlying iframe isn't properly initialized.
     * This differs from the above in that it reaches out to the live iframe to see if an embedded key exists.
     * @returns {Promise<string | null>} The embedded public key or null
     */ async getEmbeddedPublicKey() {
        const publicKey = await this.createRequest(IframeEventType.GetEmbeddedPublicKey);
        this.iframePublicKey = publicKey;
        return publicKey;
    }
    /**
     * Clears the embedded key within an iframe.
     * @returns {Promise<null>} Returns null on success
     */ async clearEmbeddedKey() {
        await this.createRequest(IframeEventType.ClearEmbeddedKey);
        this.iframePublicKey = "";
        return null;
    }
    /**
     * Creates a new embedded key within an iframe. If an embedded key already exists, this will return it.
     * This is primarily to be used in conjunction with `clearEmbeddedKey()`: after an embedded key is cleared,
     * this can be used to create a new one.
     * @returns {Promise<string | null>} The newly created embedded public key
     */ async initEmbeddedKey() {
        const publicKey = await this.createRequest(IframeEventType.InitEmbeddedKey);
        this.iframePublicKey = publicKey;
        return publicKey;
    }
    /**
     * Generic function to abstract away request creation
     * @template T
     * @param {IframeEventType} type - The type of iframe event to send
     * @param {any} [payload={}] - Optional payload data to send with the request
     * @returns {Promise<T>} Promise resolving to the expected response shape
     */ createRequest(type, payload = {}) {
        return new Promise((resolve, reject)=>{
            const requestId = generateUUID();
            this.pendingRequests.set(requestId, {
                resolve,
                reject,
                requestId
            });
            this.messageChannel.port1.postMessage({
                type,
                requestId,
                ...payload
            });
        });
    }
    /**
     * Function to inject a new credential into the iframe
     * The bundle should be encrypted to the iframe's initial public key
     * Encryption should be performed with HPKE (RFC 9180).
     * This is used during recovery and auth flows.
     * @param {string} bundle - The encrypted credential bundle to inject
     * @returns {Promise<boolean>} Returns true on successful injection
     */ async injectCredentialBundle(bundle) {
        return this.createRequest(IframeEventType.InjectCredentialBundle, {
            value: bundle
        });
    }
    /**
     * Function to inject an export bundle into the iframe
     * The bundle should be encrypted to the iframe's initial public key
     * Encryption should be performed with HPKE (RFC 9180).
     * The key format to encode the private key in after it's exported and decrypted: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.
     * This is used during the private key export flow.
     * @param {string} bundle - The encrypted export bundle to inject
     * @param {string} organizationId - The organization ID
     * @param {KeyFormat} keyFormat - [Optional] The key format (HEXADECIMAL or SOLANA). Defaults to HEXADECIMAL
     * @param {string} address - [Optional] Address corresponding to the key bundle (case sensitive)
     * @returns {Promise<boolean>} Returns true on successful injection
     */ async injectKeyExportBundle(bundle, organizationId, keyFormat, address) {
        return this.createRequest(IframeEventType.InjectKeyExportBundle, {
            value: bundle,
            keyFormat,
            organizationId,
            address
        });
    }
    /**
     * Function to inject an export bundle into the iframe
     * The bundle should be encrypted to the iframe's initial public key
     * Encryption should be performed with HPKE (RFC 9180).
     * This is used during the wallet export flow.
     * @param {string} bundle - The encrypted wallet export bundle to inject
     * @param {string} organizationId - The organization ID
     * @returns {Promise<boolean>} Returns true on successful injection
     */ async injectWalletExportBundle(bundle, organizationId) {
        return this.createRequest(IframeEventType.InjectWalletExportBundle, {
            value: bundle,
            organizationId
        });
    }
    /**
     * Function to inject an import bundle into the iframe
     * This is used to initiate either the wallet import flow or the private key import flow.
     * @param {string} bundle - The import bundle to inject
     * @param {string} organizationId - The organization ID
     * @param {string} userId - The user ID
     * @returns {Promise<boolean>} Returns true on successful injection
     */ async injectImportBundle(bundle, organizationId, userId) {
        return this.createRequest(IframeEventType.InjectImportBundle, {
            value: bundle,
            organizationId,
            userId
        });
    }
    /**
     * Function to extract an encrypted bundle from the iframe
     * The bundle should be encrypted to Turnkey's Signer enclave's initial public key
     * Encryption should be performed with HPKE (RFC 9180).
     * This is used during the wallet import flow.
     * @returns {Promise<string>} The encrypted wallet bundle
     */ async extractWalletEncryptedBundle() {
        return this.createRequest(IframeEventType.ExtractWalletEncryptedBundle);
    }
    /**
     * Function to extract an encrypted bundle from the iframe
     * The bundle should be encrypted to Turnkey's Signer enclave's initial public key
     * Encryption should be performed with HPKE (RFC 9180).
     * The key format to encode the private key in before it's encrypted and imported: HEXADECIMAL or SOLANA. Defaults to HEXADECIMAL.
     * This is used during the private key import flow.
     * @param {KeyFormat} [keyFormat] - The key format (HEXADECIMAL or SOLANA). Defaults to HEXADECIMAL
     * @returns {Promise<string>} The encrypted key bundle
     */ async extractKeyEncryptedBundle(keyFormat) {
        return this.createRequest(IframeEventType.ExtractKeyEncryptedBundle, {
            keyFormat
        });
    }
    /**
     * Function to apply settings on allowed parameters in the iframe
     * This is used to style the HTML element used for plaintext in wallet and private key import.
     * @param {TIframeSettings} settings - The settings object containing styles to apply
     * @returns {Promise<boolean>} Returns true on successful application
     */ async applySettings(settings) {
        return this.createRequest(IframeEventType.ApplySettings, {
            value: JSON.stringify(settings)
        });
    }
    /**
     * Function to sign a payload with the underlying iframe
     * @param {string} payload - The payload to sign
     * @returns {Promise<TStamp>} Object containing stamp header name and value
     * @throws {Error} When iframe public key is null (init() not called/awaited)
     */ async stamp(payload) {
        if (this.iframePublicKey === null) {
            throw new Error("null iframe public key. Have you called/awaited .init()?");
        }
        return this.createRequest(IframeEventType.StampRequest, {
            value: payload
        });
    }
    /**
     * Function to sign a message using an embedded private key in-memory within an iframe
     * Returns the signed message string
     * @param {TSignableMessage} message - The message to sign with type (Ethereum or Solana)
     * @param {string} address - [Optional] Address to sign with
     * @returns {Promise<string>} The signed message string
     */ async signMessage(message, address) {
        return this.createRequest(IframeEventType.SignMessage, {
            value: JSON.stringify(message),
            address
        });
    }
    /**
     * Function to sign a transaction using an embedded private key in-memory within an iframe
     * Returns the signed, serialized transaction payload
     * @param {TSignableTransaction} transaction - The transaction to sign with type (Ethereum or Solana)
     * @param {string} address - [Optional] Address to sign with
     * @returns {Promise<string>} The signed, serialized transaction payload
     */ async signTransaction(transaction, address) {
        return this.createRequest(IframeEventType.SignTransaction, {
            value: JSON.stringify(transaction),
            address
        });
    }
    /**
     * Function to clear the iframe's in-memory embedded private key. For now, we assume that there will be only one private key at most.
     * @returns {Promise<boolean>} Returns true on successful clearing
     */ async clearEmbeddedPrivateKey() {
        return this.createRequest(IframeEventType.clearEmbeddedPrivateKey);
    }
}
;
 //# sourceMappingURL=index.mjs.map
}),
]);

//# sourceMappingURL=node_modules_%40turnkey_a3c1c043._.js.map