(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@turnkey/core/dist/__types__/enums.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Chain",
    ()=>Chain,
    "Curve",
    ()=>Curve,
    "FilterType",
    ()=>FilterType,
    "OtpType",
    ()=>OtpType,
    "OtpTypeToFilterTypeMap",
    ()=>OtpTypeToFilterTypeMap,
    "SessionKey",
    ()=>SessionKey,
    "SignIntent",
    ()=>SignIntent,
    "StamperType",
    ()=>StamperType,
    "WalletInterfaceType",
    ()=>WalletInterfaceType,
    "WalletSource",
    ()=>WalletSource
]);
/**
 * StamperType defines the type of stamper to use when stamping a request.
 */ var StamperType;
(function(StamperType) {
    StamperType["ApiKey"] = "api-key";
    StamperType["Passkey"] = "passkey";
    StamperType["Wallet"] = "wallet";
})(StamperType || (StamperType = {}));
/** @internal */ var SessionKey;
(function(SessionKey) {
    SessionKey["DefaultSessionkey"] = "@turnkey/session/v3";
})(SessionKey || (SessionKey = {}));
/**
 * OtpType defines the type of OTP to use.
 */ var OtpType;
(function(OtpType) {
    OtpType["Email"] = "OTP_TYPE_EMAIL";
    OtpType["Sms"] = "OTP_TYPE_SMS";
})(OtpType || (OtpType = {}));
/** @internal */ var FilterType;
(function(FilterType) {
    FilterType["Email"] = "EMAIL";
    FilterType["Sms"] = "PHONE_NUMBER";
    FilterType["OidcToken"] = "OIDC_TOKEN";
    FilterType["PublicKey"] = "PUBLIC_KEY";
})(FilterType || (FilterType = {}));
/** @internal */ const OtpTypeToFilterTypeMap = {
    [OtpType.Email]: FilterType.Email,
    [OtpType.Sms]: FilterType.Sms
};
/** @internal */ var Chain;
(function(Chain) {
    Chain["Ethereum"] = "ethereum";
    Chain["Solana"] = "solana";
})(Chain || (Chain = {}));
/**@internal */ var Curve;
(function(Curve) {
    Curve["SECP256K1"] = "CURVE_SECP256K1";
    Curve["ED25519"] = "CURVE_ED25519";
})(Curve || (Curve = {}));
/** @internal */ var WalletInterfaceType;
(function(WalletInterfaceType) {
    WalletInterfaceType["Solana"] = "solana";
    WalletInterfaceType["Ethereum"] = "ethereum";
    WalletInterfaceType["WalletConnect"] = "wallet_connect";
})(WalletInterfaceType || (WalletInterfaceType = {}));
/** @internal */ var WalletSource;
(function(WalletSource) {
    WalletSource["Embedded"] = "embedded";
    WalletSource["Connected"] = "connected";
})(WalletSource || (WalletSource = {}));
/** @internal */ var SignIntent;
(function(SignIntent) {
    SignIntent["SignMessage"] = "sign_message";
    SignIntent["SignTransaction"] = "sign_transaction";
    SignIntent["SignAndSendTransaction"] = "sign_and_send";
})(SignIntent || (SignIntent = {}));
;
 //# sourceMappingURL=enums.mjs.map
}),
"[project]/node_modules/@turnkey/core/dist/__types__/error.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TurnkeyRequestError",
    ()=>TurnkeyRequestError
]);
/**@internal */ class TurnkeyRequestError extends Error {
    constructor(input){
        let turnkeyErrorMessage = `Turnkey error ${input.code}: ${input.message}`;
        if (input.details != null) {
            turnkeyErrorMessage += ` (Details: ${JSON.stringify(input.details)})`;
        }
        super(turnkeyErrorMessage);
        this.name = "TurnkeyRequestError";
        this.details = input.details ?? null;
        this.code = input.code;
    }
}
;
 //# sourceMappingURL=error.mjs.map
}),
"[project]/node_modules/@turnkey/core/dist/__types__/http.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TERMINAL_ACTIVITY_STATUSES",
    ()=>TERMINAL_ACTIVITY_STATUSES
]);
/** @internal */ const TERMINAL_ACTIVITY_STATUSES = [
    "ACTIVITY_STATUS_COMPLETED",
    "ACTIVITY_STATUS_FAILED",
    "ACTIVITY_STATUS_REJECTED"
];
;
 //# sourceMappingURL=http.mjs.map
}),
"[project]/node_modules/@turnkey/core/dist/__generated__/version.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "VERSION",
    ()=>VERSION
]);
const VERSION = "@turnkey/core@1.11.1";
;
 //# sourceMappingURL=version.mjs.map
}),
"[project]/node_modules/@turnkey/core/dist/__generated__/sdk-client-base.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TurnkeySDKClientBase",
    ()=>TurnkeySDKClientBase
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__types__/enums.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$error$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__types__/error.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$http$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__types__/http.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$generated_$5f2f$version$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__generated__/version.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/sdk-types/dist/index.mjs [app-client] (ecmascript)");
;
;
;
;
;
/* @generated by codegen. DO NOT EDIT BY HAND */ class TurnkeySDKClientBase {
    constructor(config){
        this.getActivity = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_activity", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetActivity = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_activity";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getApiKey = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_api_key", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetApiKey = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_api_key";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getApiKeys = async (input = {}, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_api_keys", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetApiKeys = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_api_keys";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getAttestationDocument = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_attestation", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetAttestationDocument = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_attestation";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getAuthenticator = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_authenticator", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetAuthenticator = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_authenticator";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getAuthenticators = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_authenticators", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetAuthenticators = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_authenticators";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getBootProof = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_boot_proof", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetBootProof = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_boot_proof";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getGasUsage = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_gas_usage", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetGasUsage = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_gas_usage";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getLatestBootProof = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_latest_boot_proof", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetLatestBootProof = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_latest_boot_proof";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getNonces = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_nonces", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetNonces = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_nonces";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getOauth2Credential = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_oauth2_credential", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetOauth2Credential = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_oauth2_credential";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getOauthProviders = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_oauth_providers", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetOauthProviders = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_oauth_providers";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getOnRampTransactionStatus = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_onramp_transaction_status", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetOnRampTransactionStatus = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_onramp_transaction_status";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getOrganization = async (input = {}, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_organization", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetOrganization = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_organization";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getOrganizationConfigs = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_organization_configs", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetOrganizationConfigs = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_organization_configs";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getPolicy = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_policy", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetPolicy = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_policy";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getPolicyEvaluations = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_policy_evaluations", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetPolicyEvaluations = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_policy_evaluations";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getPrivateKey = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_private_key", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetPrivateKey = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_private_key";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getSendTransactionStatus = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_send_transaction_status", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetSendTransactionStatus = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_send_transaction_status";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getSmartContractInterface = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_smart_contract_interface", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetSmartContractInterface = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_smart_contract_interface";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getUser = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_user", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetUser = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_user";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getWallet = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_wallet", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetWallet = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_wallet";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getWalletAccount = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/get_wallet_account", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetWalletAccount = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/get_wallet_account";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getActivities = async (input = {}, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/list_activities", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetActivities = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_activities";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getAppProofs = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/list_app_proofs", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetAppProofs = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_app_proofs";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.listFiatOnRampCredentials = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/list_fiat_on_ramp_credentials", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampListFiatOnRampCredentials = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_fiat_on_ramp_credentials";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.listOauth2Credentials = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/list_oauth2_credentials", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampListOauth2Credentials = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_oauth2_credentials";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getPolicies = async (input = {}, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/list_policies", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetPolicies = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_policies";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.listPrivateKeyTags = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/list_private_key_tags", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampListPrivateKeyTags = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_private_key_tags";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getPrivateKeys = async (input = {}, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/list_private_keys", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetPrivateKeys = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_private_keys";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getSmartContractInterfaces = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/list_smart_contract_interfaces", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetSmartContractInterfaces = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_smart_contract_interfaces";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getSubOrgIds = async (input = {}, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/list_suborgs", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetSubOrgIds = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_suborgs";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.listUserTags = async (input = {}, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/list_user_tags", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampListUserTags = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_user_tags";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getUsers = async (input = {}, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/list_users", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetUsers = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_users";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getVerifiedSubOrgIds = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/list_verified_suborgs", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetVerifiedSubOrgIds = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_verified_suborgs";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getWalletAccounts = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/list_wallet_accounts", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetWalletAccounts = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_wallet_accounts";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getWallets = async (input = {}, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/list_wallets", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetWallets = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/list_wallets";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.getWhoami = async (input = {}, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/public/v1/query/whoami", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampGetWhoami = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/query/whoami";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.approveActivity = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activityDecision("/public/v1/submit/approve_activity", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_APPROVE_ACTIVITY"
            }, stampWith);
        };
        this.stampApproveActivity = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/approve_activity";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_APPROVE_ACTIVITY"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createApiKeys = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_api_keys", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_API_KEYS_V2"
            }, "createApiKeysResult", stampWith);
        };
        this.stampCreateApiKeys = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_api_keys";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_API_KEYS_V2"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createApiOnlyUsers = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_api_only_users", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_API_ONLY_USERS"
            }, "createApiOnlyUsersResult", stampWith);
        };
        this.stampCreateApiOnlyUsers = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_api_only_users";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_API_ONLY_USERS"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createAuthenticators = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_authenticators", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2"
            }, "createAuthenticatorsResult", stampWith);
        };
        this.stampCreateAuthenticators = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_authenticators";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_AUTHENTICATORS_V2"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createFiatOnRampCredential = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_fiat_on_ramp_credential", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_FIAT_ON_RAMP_CREDENTIAL"
            }, "createFiatOnRampCredentialResult", stampWith);
        };
        this.stampCreateFiatOnRampCredential = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_fiat_on_ramp_credential";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_FIAT_ON_RAMP_CREDENTIAL"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createInvitations = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_invitations", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_INVITATIONS"
            }, "createInvitationsResult", stampWith);
        };
        this.stampCreateInvitations = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_invitations";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_INVITATIONS"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createOauth2Credential = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_oauth2_credential", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_OAUTH2CREDENTIAL"
            }, "createOauth2CredentialResult", stampWith);
        };
        this.stampCreateOauth2Credential = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_oauth2_credential";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_OAUTH2CREDENTIAL"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createOauthProviders = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_oauth_providers", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS"
            }, "createOauthProvidersResult", stampWith);
        };
        this.stampCreateOauthProviders = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_oauth_providers";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_OAUTH_PROVIDERS"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createPolicies = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_policies", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_POLICIES"
            }, "createPoliciesResult", stampWith);
        };
        this.stampCreatePolicies = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_policies";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_POLICIES"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createPolicy = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_policy", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_POLICY_V3"
            }, "createPolicyResult", stampWith);
        };
        this.stampCreatePolicy = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_policy";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_POLICY_V3"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createPrivateKeyTag = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_private_key_tag", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG"
            }, "createPrivateKeyTagResult", stampWith);
        };
        this.stampCreatePrivateKeyTag = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_private_key_tag";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_PRIVATE_KEY_TAG"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createPrivateKeys = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_private_keys", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2"
            }, "createPrivateKeysResultV2", stampWith);
        };
        this.stampCreatePrivateKeys = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_private_keys";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_PRIVATE_KEYS_V2"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createReadOnlySession = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_read_only_session", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION"
            }, "createReadOnlySessionResult", stampWith);
        };
        this.stampCreateReadOnlySession = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_read_only_session";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_READ_ONLY_SESSION"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createReadWriteSession = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_read_write_session", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2"
            }, "createReadWriteSessionResultV2", stampWith);
        };
        this.stampCreateReadWriteSession = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_read_write_session";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_READ_WRITE_SESSION_V2"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createSmartContractInterface = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_smart_contract_interface", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_SMART_CONTRACT_INTERFACE"
            }, "createSmartContractInterfaceResult", stampWith);
        };
        this.stampCreateSmartContractInterface = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_smart_contract_interface";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_SMART_CONTRACT_INTERFACE"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createSubOrganization = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_sub_organization", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7"
            }, "createSubOrganizationResultV7", stampWith);
        };
        this.stampCreateSubOrganization = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_sub_organization";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_SUB_ORGANIZATION_V7"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createUserTag = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_user_tag", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_USER_TAG"
            }, "createUserTagResult", stampWith);
        };
        this.stampCreateUserTag = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_user_tag";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_USER_TAG"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createUsers = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_users", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_USERS_V3"
            }, "createUsersResult", stampWith);
        };
        this.stampCreateUsers = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_users";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_USERS_V3"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createWallet = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_wallet", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_WALLET"
            }, "createWalletResult", stampWith);
        };
        this.stampCreateWallet = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_wallet";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_WALLET"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.createWalletAccounts = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/create_wallet_accounts", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS"
            }, "createWalletAccountsResult", stampWith);
        };
        this.stampCreateWalletAccounts = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/create_wallet_accounts";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_CREATE_WALLET_ACCOUNTS"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.deleteApiKeys = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/delete_api_keys", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_API_KEYS"
            }, "deleteApiKeysResult", stampWith);
        };
        this.stampDeleteApiKeys = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_api_keys";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_API_KEYS"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.deleteAuthenticators = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/delete_authenticators", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_AUTHENTICATORS"
            }, "deleteAuthenticatorsResult", stampWith);
        };
        this.stampDeleteAuthenticators = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_authenticators";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_AUTHENTICATORS"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.deleteFiatOnRampCredential = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/delete_fiat_on_ramp_credential", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_FIAT_ON_RAMP_CREDENTIAL"
            }, "deleteFiatOnRampCredentialResult", stampWith);
        };
        this.stampDeleteFiatOnRampCredential = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_fiat_on_ramp_credential";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_FIAT_ON_RAMP_CREDENTIAL"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.deleteInvitation = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/delete_invitation", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_INVITATION"
            }, "deleteInvitationResult", stampWith);
        };
        this.stampDeleteInvitation = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_invitation";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_INVITATION"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.deleteOauth2Credential = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/delete_oauth2_credential", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_OAUTH2CREDENTIAL"
            }, "deleteOauth2CredentialResult", stampWith);
        };
        this.stampDeleteOauth2Credential = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_oauth2_credential";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_OAUTH2CREDENTIAL"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.deleteOauthProviders = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/delete_oauth_providers", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS"
            }, "deleteOauthProvidersResult", stampWith);
        };
        this.stampDeleteOauthProviders = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_oauth_providers";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_OAUTH_PROVIDERS"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.deletePolicies = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/delete_policies", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_POLICIES"
            }, "deletePoliciesResult", stampWith);
        };
        this.stampDeletePolicies = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_policies";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_POLICIES"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.deletePolicy = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/delete_policy", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_POLICY"
            }, "deletePolicyResult", stampWith);
        };
        this.stampDeletePolicy = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_policy";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_POLICY"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.deletePrivateKeyTags = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/delete_private_key_tags", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS"
            }, "deletePrivateKeyTagsResult", stampWith);
        };
        this.stampDeletePrivateKeyTags = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_private_key_tags";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_PRIVATE_KEY_TAGS"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.deletePrivateKeys = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/delete_private_keys", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS"
            }, "deletePrivateKeysResult", stampWith);
        };
        this.stampDeletePrivateKeys = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_private_keys";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_PRIVATE_KEYS"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.deleteSmartContractInterface = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/delete_smart_contract_interface", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_SMART_CONTRACT_INTERFACE"
            }, "deleteSmartContractInterfaceResult", stampWith);
        };
        this.stampDeleteSmartContractInterface = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_smart_contract_interface";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_SMART_CONTRACT_INTERFACE"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.deleteSubOrganization = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/delete_sub_organization", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION"
            }, "deleteSubOrganizationResult", stampWith);
        };
        this.stampDeleteSubOrganization = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_sub_organization";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_SUB_ORGANIZATION"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.deleteUserTags = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/delete_user_tags", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_USER_TAGS"
            }, "deleteUserTagsResult", stampWith);
        };
        this.stampDeleteUserTags = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_user_tags";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_USER_TAGS"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.deleteUsers = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/delete_users", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_USERS"
            }, "deleteUsersResult", stampWith);
        };
        this.stampDeleteUsers = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_users";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_USERS"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.deleteWalletAccounts = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/delete_wallet_accounts", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_WALLET_ACCOUNTS"
            }, "deleteWalletAccountsResult", stampWith);
        };
        this.stampDeleteWalletAccounts = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_wallet_accounts";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_WALLET_ACCOUNTS"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.deleteWallets = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/delete_wallets", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_WALLETS"
            }, "deleteWalletsResult", stampWith);
        };
        this.stampDeleteWallets = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/delete_wallets";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_DELETE_WALLETS"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.emailAuth = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/email_auth", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_EMAIL_AUTH_V3"
            }, "emailAuthResult", stampWith);
        };
        this.stampEmailAuth = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/email_auth";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_EMAIL_AUTH_V3"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.ethSendRawTransaction = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/eth_send_raw_transaction", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_ETH_SEND_RAW_TRANSACTION"
            }, "ethSendRawTransactionResult", stampWith);
        };
        this.stampEthSendRawTransaction = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/eth_send_raw_transaction";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_ETH_SEND_RAW_TRANSACTION"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.ethSendTransaction = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/eth_send_transaction", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_ETH_SEND_TRANSACTION"
            }, "ethSendTransactionResult", stampWith);
        };
        this.stampEthSendTransaction = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/eth_send_transaction";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_ETH_SEND_TRANSACTION"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.exportPrivateKey = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/export_private_key", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY"
            }, "exportPrivateKeyResult", stampWith);
        };
        this.stampExportPrivateKey = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/export_private_key";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_EXPORT_PRIVATE_KEY"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.exportWallet = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/export_wallet", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_EXPORT_WALLET"
            }, "exportWalletResult", stampWith);
        };
        this.stampExportWallet = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/export_wallet";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_EXPORT_WALLET"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.exportWalletAccount = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/export_wallet_account", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT"
            }, "exportWalletAccountResult", stampWith);
        };
        this.stampExportWalletAccount = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/export_wallet_account";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_EXPORT_WALLET_ACCOUNT"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.importPrivateKey = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/import_private_key", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY"
            }, "importPrivateKeyResult", stampWith);
        };
        this.stampImportPrivateKey = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/import_private_key";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_IMPORT_PRIVATE_KEY"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.importWallet = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/import_wallet", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_IMPORT_WALLET"
            }, "importWalletResult", stampWith);
        };
        this.stampImportWallet = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/import_wallet";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_IMPORT_WALLET"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.initFiatOnRamp = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/init_fiat_on_ramp", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_INIT_FIAT_ON_RAMP"
            }, "initFiatOnRampResult", stampWith);
        };
        this.stampInitFiatOnRamp = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/init_fiat_on_ramp";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_INIT_FIAT_ON_RAMP"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.initImportPrivateKey = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/init_import_private_key", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY"
            }, "initImportPrivateKeyResult", stampWith);
        };
        this.stampInitImportPrivateKey = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/init_import_private_key";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_INIT_IMPORT_PRIVATE_KEY"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.initImportWallet = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/init_import_wallet", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_INIT_IMPORT_WALLET"
            }, "initImportWalletResult", stampWith);
        };
        this.stampInitImportWallet = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/init_import_wallet";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_INIT_IMPORT_WALLET"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.initOtp = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/init_otp", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_INIT_OTP_V2"
            }, "initOtpResult", stampWith);
        };
        this.stampInitOtp = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/init_otp";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_INIT_OTP_V2"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.initOtpAuth = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/init_otp_auth", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_INIT_OTP_AUTH_V3"
            }, "initOtpAuthResultV2", stampWith);
        };
        this.stampInitOtpAuth = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/init_otp_auth";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_INIT_OTP_AUTH_V3"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.initUserEmailRecovery = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/init_user_email_recovery", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY_V2"
            }, "initUserEmailRecoveryResult", stampWith);
        };
        this.stampInitUserEmailRecovery = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/init_user_email_recovery";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_INIT_USER_EMAIL_RECOVERY_V2"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.oauth = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/oauth", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_OAUTH"
            }, "oauthResult", stampWith);
        };
        this.stampOauth = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/oauth";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_OAUTH"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.oauth2Authenticate = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/oauth2_authenticate", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_OAUTH2AUTHENTICATE"
            }, "oauth2AuthenticateResult", stampWith);
        };
        this.stampOauth2Authenticate = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/oauth2_authenticate";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_OAUTH2AUTHENTICATE"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.oauthLogin = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/oauth_login", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_OAUTH_LOGIN"
            }, "oauthLoginResult", stampWith);
        };
        this.stampOauthLogin = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/oauth_login";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_OAUTH_LOGIN"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.otpAuth = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/otp_auth", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_OTP_AUTH"
            }, "otpAuthResult", stampWith);
        };
        this.stampOtpAuth = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/otp_auth";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_OTP_AUTH"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.otpLogin = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/otp_login", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_OTP_LOGIN"
            }, "otpLoginResult", stampWith);
        };
        this.stampOtpLogin = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/otp_login";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_OTP_LOGIN"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.recoverUser = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/recover_user", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_RECOVER_USER"
            }, "recoverUserResult", stampWith);
        };
        this.stampRecoverUser = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/recover_user";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_RECOVER_USER"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.rejectActivity = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activityDecision("/public/v1/submit/reject_activity", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_REJECT_ACTIVITY"
            }, stampWith);
        };
        this.stampRejectActivity = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/reject_activity";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_REJECT_ACTIVITY"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.removeOrganizationFeature = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/remove_organization_feature", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE"
            }, "removeOrganizationFeatureResult", stampWith);
        };
        this.stampRemoveOrganizationFeature = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/remove_organization_feature";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_REMOVE_ORGANIZATION_FEATURE"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.setOrganizationFeature = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/set_organization_feature", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE"
            }, "setOrganizationFeatureResult", stampWith);
        };
        this.stampSetOrganizationFeature = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/set_organization_feature";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_SET_ORGANIZATION_FEATURE"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.signRawPayload = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/sign_raw_payload", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2"
            }, "signRawPayloadResult", stampWith);
        };
        this.stampSignRawPayload = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/sign_raw_payload";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOAD_V2"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.signRawPayloads = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/sign_raw_payloads", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS"
            }, "signRawPayloadsResult", stampWith);
        };
        this.stampSignRawPayloads = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/sign_raw_payloads";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_SIGN_RAW_PAYLOADS"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.signTransaction = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/sign_transaction", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_SIGN_TRANSACTION_V2"
            }, "signTransactionResult", stampWith);
        };
        this.stampSignTransaction = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/sign_transaction";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_SIGN_TRANSACTION_V2"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.stampLogin = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/stamp_login", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_STAMP_LOGIN"
            }, "stampLoginResult", stampWith);
        };
        this.stampStampLogin = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/stamp_login";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_STAMP_LOGIN"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.updateFiatOnRampCredential = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/update_fiat_on_ramp_credential", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_FIAT_ON_RAMP_CREDENTIAL"
            }, "updateFiatOnRampCredentialResult", stampWith);
        };
        this.stampUpdateFiatOnRampCredential = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_fiat_on_ramp_credential";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_FIAT_ON_RAMP_CREDENTIAL"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.updateOauth2Credential = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/update_oauth2_credential", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_OAUTH2CREDENTIAL"
            }, "updateOauth2CredentialResult", stampWith);
        };
        this.stampUpdateOauth2Credential = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_oauth2_credential";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_OAUTH2CREDENTIAL"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.updatePolicy = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/update_policy", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_POLICY_V2"
            }, "updatePolicyResultV2", stampWith);
        };
        this.stampUpdatePolicy = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_policy";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_POLICY_V2"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.updatePrivateKeyTag = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/update_private_key_tag", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG"
            }, "updatePrivateKeyTagResult", stampWith);
        };
        this.stampUpdatePrivateKeyTag = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_private_key_tag";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_PRIVATE_KEY_TAG"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.updateRootQuorum = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/update_root_quorum", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM"
            }, "updateRootQuorumResult", stampWith);
        };
        this.stampUpdateRootQuorum = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_root_quorum";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_ROOT_QUORUM"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.updateUser = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/update_user", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_USER"
            }, "updateUserResult", stampWith);
        };
        this.stampUpdateUser = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_user";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_USER"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.updateUserEmail = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/update_user_email", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_USER_EMAIL"
            }, "updateUserEmailResult", stampWith);
        };
        this.stampUpdateUserEmail = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_user_email";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_USER_EMAIL"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.updateUserName = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/update_user_name", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_USER_NAME"
            }, "updateUserNameResult", stampWith);
        };
        this.stampUpdateUserName = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_user_name";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_USER_NAME"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.updateUserPhoneNumber = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/update_user_phone_number", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_USER_PHONE_NUMBER"
            }, "updateUserPhoneNumberResult", stampWith);
        };
        this.stampUpdateUserPhoneNumber = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_user_phone_number";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_USER_PHONE_NUMBER"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.updateUserTag = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/update_user_tag", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_USER_TAG"
            }, "updateUserTagResult", stampWith);
        };
        this.stampUpdateUserTag = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_user_tag";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_USER_TAG"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.updateWallet = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/update_wallet", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_WALLET"
            }, "updateWalletResult", stampWith);
        };
        this.stampUpdateWallet = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/update_wallet";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_UPDATE_WALLET"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.verifyOtp = async (input, stampWith)=>{
            const { organizationId, timestampMs, ...rest } = input;
            const session = await this.storageManager?.getActiveSession();
            return this.activity("/public/v1/submit/verify_otp", {
                parameters: rest,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_VERIFY_OTP"
            }, "verifyOtpResult", stampWith);
        };
        this.stampVerifyOtp = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const { organizationId, timestampMs, ...parameters } = input;
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/public/v1/submit/verify_otp";
            const bodyWithType = {
                parameters,
                organizationId: organizationId ?? session?.organizationId ?? this.config.organizationId,
                timestampMs: timestampMs ?? String(Date.now()),
                type: "ACTIVITY_TYPE_VERIFY_OTP"
            };
            const stringifiedBody = JSON.stringify(bodyWithType);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.testRateLimits = async (input, stampWith)=>{
            const session = await this.storageManager?.getActiveSession();
            return this.request("/tkhq/api/v1/test_rate_limits", {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            }, stampWith);
        };
        this.stampTestRateLimits = async (input, stampWith)=>{
            const activeStamper = this.getStamper(stampWith);
            if (!activeStamper) {
                return undefined;
            }
            const session = await this.storageManager?.getActiveSession();
            const fullUrl = this.config.apiBaseUrl + "/tkhq/api/v1/test_rate_limits";
            const body = {
                ...input,
                organizationId: input.organizationId ?? session?.organizationId ?? this.config.organizationId
            };
            const stringifiedBody = JSON.stringify(body);
            const stamp = await activeStamper.stamp(stringifiedBody);
            return {
                body: stringifiedBody,
                stamp: stamp,
                url: fullUrl
            };
        };
        this.proxyGetAccount = async (input)=>{
            return this.authProxyRequest("/v1/account", input);
        };
        this.proxyOAuth2Authenticate = async (input)=>{
            return this.authProxyRequest("/v1/oauth2_authenticate", input);
        };
        this.proxyOAuthLogin = async (input)=>{
            return this.authProxyRequest("/v1/oauth_login", input);
        };
        this.proxyInitOtp = async (input)=>{
            return this.authProxyRequest("/v1/otp_init", input);
        };
        this.proxyOtpLogin = async (input)=>{
            return this.authProxyRequest("/v1/otp_login", input);
        };
        this.proxyVerifyOtp = async (input)=>{
            return this.authProxyRequest("/v1/otp_verify", input);
        };
        this.proxySignup = async (input)=>{
            return this.authProxyRequest("/v1/signup", input);
        };
        this.proxyGetWalletKitConfig = async (input)=>{
            return this.authProxyRequest("/v1/wallet_kit_config", input);
        };
        this.config = config;
        if (config.apiKeyStamper) {
            this.apiKeyStamper = config.apiKeyStamper;
        }
        if (config.passkeyStamper) {
            this.passkeyStamper = config.passkeyStamper;
        }
        if (config.walletStamper) {
            this.walletStamper = config.walletStamper;
        }
        if (config.storageManager) {
            this.storageManager = config.storageManager;
        }
        if (config.defaultStamperType) {
            this.defaultStamperType = config.defaultStamperType;
        } else {
            // Set default stamper type based on available stampers
            if (this.apiKeyStamper) {
                this.defaultStamperType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StamperType"].ApiKey;
            } else if (this.passkeyStamper) {
                this.defaultStamperType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StamperType"].Passkey;
            } else if (this.walletStamper) {
                this.defaultStamperType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StamperType"].Wallet;
            } else {
                this.defaultStamperType = undefined;
            }
        }
    }
    getStamper(stampWith) {
        if (!stampWith) {
            // Use default stamper type if none specified
            stampWith = this.defaultStamperType;
        }
        switch(stampWith){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StamperType"].ApiKey:
                return this.apiKeyStamper;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StamperType"].Passkey:
                return this.passkeyStamper;
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StamperType"].Wallet:
                return this.walletStamper;
            default:
                return this.apiKeyStamper;
        }
    }
    sleep(ms) {
        return new Promise((resolve)=>setTimeout(resolve, ms));
    }
    /**
     * Poll for activity completion until terminal status or max retries.
     * @internal
     */ async pollForCompletion(activityId, stampWith) {
        const pollingDuration = this.config.activityPoller?.intervalMs ?? 1000;
        const maxRetries = this.config.activityPoller?.numRetries ?? 3;
        let attempts = 0;
        let activityData;
        do {
            await this.sleep(pollingDuration);
            activityData = await this.getActivity({
                activityId
            }, stampWith);
            attempts++;
        }while (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$http$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TERMINAL_ACTIVITY_STATUSES"].includes(activityData.activity.status) && attempts < maxRetries)
        return activityData;
    }
    /**
     * Extract and flatten result fields from a completed activity response.
     * @internal
     */ handleActivityResponse(activityData, resultKey) {
        const { result, status } = activityData.activity;
        if (status === "ACTIVITY_STATUS_COMPLETED" && result) {
            // If a specific resultKey was provided, use it
            if (resultKey && result[resultKey]) {
                return {
                    ...result[resultKey],
                    ...activityData
                };
            }
            // Otherwise, try to find any result field and flatten it
            for (const key of Object.keys(result)){
                if (key.endsWith("Result") && result[key]) {
                    return {
                        ...result[key],
                        ...activityData
                    };
                }
            }
        }
        return activityData;
    }
    async request(url, body, stampWith) {
        const fullUrl = this.config.apiBaseUrl + url;
        const stringifiedBody = JSON.stringify(body);
        var headers = {
            "X-Client-Version": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$generated_$5f2f$version$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERSION"]
        };
        // Use the specified stamper for this request
        const activeStamper = this.getStamper(stampWith);
        if (activeStamper) {
            const stamp = await activeStamper.stamp(stringifiedBody);
            headers[stamp.stampHeaderName] = stamp.stampHeaderValue;
        }
        const response = await fetch(fullUrl, {
            method: "POST",
            headers: headers,
            body: stringifiedBody,
            redirect: "follow"
        });
        if (!response.ok) {
            let res;
            try {
                res = await response.json();
            } catch (_) {
                throw new Error(`${response.status} ${response.statusText}`);
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$error$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyRequestError"](res);
        }
        const data = await response.json();
        return data;
    }
    async activity(url, body, resultKey, stampWith) {
        // Make the initial request
        let activityData = await this.request(url, body, stampWith);
        // Poll if not in terminal status
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$http$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TERMINAL_ACTIVITY_STATUSES"].includes(activityData.activity.status)) {
            activityData = await this.pollForCompletion(activityData.activity.id, stampWith);
        }
        return this.handleActivityResponse(activityData, resultKey);
    }
    async activityDecision(url, body, stampWith) {
        // Use the specified stamper for this request
        const activityData = await this.request(url, body, stampWith);
        return {
            ...activityData["activity"]["result"],
            ...activityData
        };
    }
    async authProxyRequest(url, body) {
        if (!this.config.authProxyUrl || !this.config.authProxyConfigId) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Auth Proxy URL or ID is not configured.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_CONFIGURATION);
        }
        const fullUrl = this.config.authProxyUrl + url;
        const stringifiedBody = JSON.stringify(body);
        var headers = {
            "Content-Type": "application/json",
            "X-Auth-Proxy-Config-ID": this.config.authProxyConfigId
        };
        const response = await fetch(fullUrl, {
            method: "POST",
            headers: headers,
            body: stringifiedBody
        });
        if (!response.ok) {
            let res;
            try {
                res = await response.json();
            } catch (_) {
                throw new Error(`${response.status} ${response.statusText}`);
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$error$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyRequestError"](res);
        }
        const data = await response.json();
        return data;
    }
    /**
     * Submit a pre-signed request to Turnkey.
     *
     * Use this method to execute any TSignedRequest returned by the SDK's
     * stamping methods (stampCreateApiKeys, stampGetPolicies, stampGetWallets, etc.).
     *
     * Works for both query and activity requests:
     * - For queries: returns the response directly
     * - For activities: automatically polls until completion and extracts the result
     *
     * @param signedRequest - A TSignedRequest object returned by a stamping method
     * @param options - Optional configuration for the request
     * @param options.resultKey - For activity requests, the key to extract from the result (e.g., "createApiKeysResultV2")
     * @returns The parsed response, with activity result fields flattened if applicable
     */ async sendSignedRequest(signedRequest, options) {
        const headers = {
            "Content-Type": "application/json",
            "X-Client-Version": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$generated_$5f2f$version$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERSION"],
            [signedRequest.stamp.stampHeaderName]: signedRequest.stamp.stampHeaderValue
        };
        const response = await fetch(signedRequest.url, {
            method: "POST",
            headers,
            body: signedRequest.body
        });
        if (!response.ok) {
            let res;
            try {
                res = await response.json();
            } catch (_) {
                throw new Error(`${response.status} ${response.statusText}`);
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$error$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyRequestError"](res);
        }
        const data = await response.json();
        // Check if this is an activity response that needs polling
        if (data.activity) {
            let activityData = data;
            // Poll if not in terminal status
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$http$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TERMINAL_ACTIVITY_STATUSES"].includes(activityData.activity.status)) {
                activityData = await this.pollForCompletion(activityData.activity.id);
            }
            return this.handleActivityResponse(activityData, options?.resultKey);
        }
        return data;
    }
}
;
 //# sourceMappingURL=sdk-client-base.mjs.map
}),
"[project]/node_modules/@turnkey/core/dist/__types__/auth.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DEFAULT_SESSION_EXPIRATION_IN_SECONDS",
    ()=>DEFAULT_SESSION_EXPIRATION_IN_SECONDS
]);
/** @internal */ const DEFAULT_SESSION_EXPIRATION_IN_SECONDS = "900"; // 15 minutes
;
 //# sourceMappingURL=auth.mjs.map
}),
"[project]/node_modules/@turnkey/core/dist/turnkey-helpers.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DEFAULT_APTOS_ACCOUNTS",
    ()=>DEFAULT_APTOS_ACCOUNTS,
    "DEFAULT_BITCOIN_MAINNET_P2PKH_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_MAINNET_P2PKH_ACCOUNTS,
    "DEFAULT_BITCOIN_MAINNET_P2SH_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_MAINNET_P2SH_ACCOUNTS,
    "DEFAULT_BITCOIN_MAINNET_P2TR_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_MAINNET_P2TR_ACCOUNTS,
    "DEFAULT_BITCOIN_MAINNET_P2WPKH_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_MAINNET_P2WPKH_ACCOUNTS,
    "DEFAULT_BITCOIN_MAINNET_P2WSH_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_MAINNET_P2WSH_ACCOUNTS,
    "DEFAULT_BITCOIN_REGTEST_P2PKH_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_REGTEST_P2PKH_ACCOUNTS,
    "DEFAULT_BITCOIN_REGTEST_P2SH_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_REGTEST_P2SH_ACCOUNTS,
    "DEFAULT_BITCOIN_REGTEST_P2TR_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_REGTEST_P2TR_ACCOUNTS,
    "DEFAULT_BITCOIN_REGTEST_P2WPKH_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_REGTEST_P2WPKH_ACCOUNTS,
    "DEFAULT_BITCOIN_REGTEST_P2WSH_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_REGTEST_P2WSH_ACCOUNTS,
    "DEFAULT_BITCOIN_SIGNET_P2PKH_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_SIGNET_P2PKH_ACCOUNTS,
    "DEFAULT_BITCOIN_SIGNET_P2SH_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_SIGNET_P2SH_ACCOUNTS,
    "DEFAULT_BITCOIN_SIGNET_P2TR_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_SIGNET_P2TR_ACCOUNTS,
    "DEFAULT_BITCOIN_SIGNET_P2WPKH_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_SIGNET_P2WPKH_ACCOUNTS,
    "DEFAULT_BITCOIN_SIGNET_P2WSH_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_SIGNET_P2WSH_ACCOUNTS,
    "DEFAULT_BITCOIN_TESTNET_P2PKH_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_TESTNET_P2PKH_ACCOUNTS,
    "DEFAULT_BITCOIN_TESTNET_P2SH_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_TESTNET_P2SH_ACCOUNTS,
    "DEFAULT_BITCOIN_TESTNET_P2TR_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_TESTNET_P2TR_ACCOUNTS,
    "DEFAULT_BITCOIN_TESTNET_P2WPKH_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_TESTNET_P2WPKH_ACCOUNTS,
    "DEFAULT_BITCOIN_TESTNET_P2WSH_ACCOUNTS",
    ()=>DEFAULT_BITCOIN_TESTNET_P2WSH_ACCOUNTS,
    "DEFAULT_COSMOS_ACCOUNTS",
    ()=>DEFAULT_COSMOS_ACCOUNTS,
    "DEFAULT_DOGE_MAINNET_ACCOUNTS",
    ()=>DEFAULT_DOGE_MAINNET_ACCOUNTS,
    "DEFAULT_DOGE_TESTNET_ACCOUNTS",
    ()=>DEFAULT_DOGE_TESTNET_ACCOUNTS,
    "DEFAULT_ETHEREUM_ACCOUNTS",
    ()=>DEFAULT_ETHEREUM_ACCOUNTS,
    "DEFAULT_SEI_ACCOUNTS",
    ()=>DEFAULT_SEI_ACCOUNTS,
    "DEFAULT_SOLANA_ACCOUNTS",
    ()=>DEFAULT_SOLANA_ACCOUNTS,
    "DEFAULT_SUI_ACCOUNTS",
    ()=>DEFAULT_SUI_ACCOUNTS,
    "DEFAULT_TON_V3R2_ACCOUNTS",
    ()=>DEFAULT_TON_V3R2_ACCOUNTS,
    "DEFAULT_TON_V4R2_ACCOUNTS",
    ()=>DEFAULT_TON_V4R2_ACCOUNTS,
    "DEFAULT_TRON_ACCOUNTS",
    ()=>DEFAULT_TRON_ACCOUNTS,
    "DEFAULT_XLM_ACCOUNTS",
    ()=>DEFAULT_XLM_ACCOUNTS,
    "DEFAULT_XRP_ACCOUNTS",
    ()=>DEFAULT_XRP_ACCOUNTS,
    "defaultAptosAccountAtIndex",
    ()=>defaultAptosAccountAtIndex,
    "defaultBitcoinMainnetP2PKHAccountAtIndex",
    ()=>defaultBitcoinMainnetP2PKHAccountAtIndex,
    "defaultBitcoinMainnetP2SHAccountAtIndex",
    ()=>defaultBitcoinMainnetP2SHAccountAtIndex,
    "defaultBitcoinMainnetP2TRAccountAtIndex",
    ()=>defaultBitcoinMainnetP2TRAccountAtIndex,
    "defaultBitcoinMainnetP2WPKHAccountAtIndex",
    ()=>defaultBitcoinMainnetP2WPKHAccountAtIndex,
    "defaultBitcoinMainnetP2WSHAccountAtIndex",
    ()=>defaultBitcoinMainnetP2WSHAccountAtIndex,
    "defaultBitcoinRegtestP2PKHAccountAtIndex",
    ()=>defaultBitcoinRegtestP2PKHAccountAtIndex,
    "defaultBitcoinRegtestP2SHAccountAtIndex",
    ()=>defaultBitcoinRegtestP2SHAccountAtIndex,
    "defaultBitcoinRegtestP2TRAccountAtIndex",
    ()=>defaultBitcoinRegtestP2TRAccountAtIndex,
    "defaultBitcoinRegtestP2WPKHAccountAtIndex",
    ()=>defaultBitcoinRegtestP2WPKHAccountAtIndex,
    "defaultBitcoinRegtestP2WSHAccountAtIndex",
    ()=>defaultBitcoinRegtestP2WSHAccountAtIndex,
    "defaultBitcoinSignetP2PKHAccountAtIndex",
    ()=>defaultBitcoinSignetP2PKHAccountAtIndex,
    "defaultBitcoinSignetP2SHAccountAtIndex",
    ()=>defaultBitcoinSignetP2SHAccountAtIndex,
    "defaultBitcoinSignetP2TRAccountAtIndex",
    ()=>defaultBitcoinSignetP2TRAccountAtIndex,
    "defaultBitcoinSignetP2WPKHAccountAtIndex",
    ()=>defaultBitcoinSignetP2WPKHAccountAtIndex,
    "defaultBitcoinSignetP2WSHAccountAtIndex",
    ()=>defaultBitcoinSignetP2WSHAccountAtIndex,
    "defaultBitcoinTestnetP2PKHAccountAtIndex",
    ()=>defaultBitcoinTestnetP2PKHAccountAtIndex,
    "defaultBitcoinTestnetP2SHAccountAtIndex",
    ()=>defaultBitcoinTestnetP2SHAccountAtIndex,
    "defaultBitcoinTestnetP2TRAccountAtIndex",
    ()=>defaultBitcoinTestnetP2TRAccountAtIndex,
    "defaultBitcoinTestnetP2WPKHAccountAtIndex",
    ()=>defaultBitcoinTestnetP2WPKHAccountAtIndex,
    "defaultBitcoinTestnetP2WSHAccountAtIndex",
    ()=>defaultBitcoinTestnetP2WSHAccountAtIndex,
    "defaultCosmosAccountAtIndex",
    ()=>defaultCosmosAccountAtIndex,
    "defaultDogeMainnetAccountAtIndex",
    ()=>defaultDogeMainnetAccountAtIndex,
    "defaultDogeTestnetAccountAtIndex",
    ()=>defaultDogeTestnetAccountAtIndex,
    "defaultEthereumAccountAtIndex",
    ()=>defaultEthereumAccountAtIndex,
    "defaultSeiAccountAtIndex",
    ()=>defaultSeiAccountAtIndex,
    "defaultSolanaAccountAtIndex",
    ()=>defaultSolanaAccountAtIndex,
    "defaultSuiAccountAtIndex",
    ()=>defaultSuiAccountAtIndex,
    "defaultTonV3r2AccountAtIndex",
    ()=>defaultTonV3r2AccountAtIndex,
    "defaultTonV4r2AccountAtIndex",
    ()=>defaultTonV4r2AccountAtIndex,
    "defaultTronAccountAtIndex",
    ()=>defaultTronAccountAtIndex,
    "defaultXlmAccountAtIndex",
    ()=>defaultXlmAccountAtIndex,
    "defaultXrpAccountAtIndex",
    ()=>defaultXrpAccountAtIndex
]);
// ----------------------------
// CURVE_SECP256K1 Accounts
// ----------------------------
// Ethereum
const defaultEthereumAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/60'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_ETHEREUM"
    };
};
const DEFAULT_ETHEREUM_ACCOUNTS = [
    defaultEthereumAccountAtIndex(0)
];
// Cosmos
const defaultCosmosAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/118'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_COSMOS"
    };
};
const DEFAULT_COSMOS_ACCOUNTS = [
    defaultCosmosAccountAtIndex(0)
];
// Tron
const defaultTronAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/195'/${pathIndex}'`,
        addressFormat: "ADDRESS_FORMAT_TRON"
    };
};
const DEFAULT_TRON_ACCOUNTS = [
    defaultTronAccountAtIndex(0)
];
// Bitcoin Mainnet P2PKH
const defaultBitcoinMainnetP2PKHAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/0'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_MAINNET_P2PKH"
    };
};
const DEFAULT_BITCOIN_MAINNET_P2PKH_ACCOUNTS = [
    defaultBitcoinMainnetP2PKHAccountAtIndex(0)
];
// Bitcoin Mainnet P2WPKH
const defaultBitcoinMainnetP2WPKHAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/84'/0'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WPKH"
    };
};
const DEFAULT_BITCOIN_MAINNET_P2WPKH_ACCOUNTS = [
    defaultBitcoinMainnetP2WPKHAccountAtIndex(0)
];
// Bitcoin Mainnet P2WSH
const defaultBitcoinMainnetP2WSHAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/48'/0'/${pathIndex}'/2'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_MAINNET_P2WSH"
    };
};
const DEFAULT_BITCOIN_MAINNET_P2WSH_ACCOUNTS = [
    defaultBitcoinMainnetP2WSHAccountAtIndex(0)
];
// Bitcoin Mainnet P2TR
const defaultBitcoinMainnetP2TRAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/86'/0'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_MAINNET_P2TR"
    };
};
const DEFAULT_BITCOIN_MAINNET_P2TR_ACCOUNTS = [
    defaultBitcoinMainnetP2TRAccountAtIndex(0)
];
// Bitcoin Mainnet P2SH
const defaultBitcoinMainnetP2SHAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/0'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_MAINNET_P2SH"
    };
};
const DEFAULT_BITCOIN_MAINNET_P2SH_ACCOUNTS = [
    defaultBitcoinMainnetP2SHAccountAtIndex(0)
];
// Bitcoin Testnet P2PKH
const defaultBitcoinTestnetP2PKHAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/1'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_TESTNET_P2PKH"
    };
};
const DEFAULT_BITCOIN_TESTNET_P2PKH_ACCOUNTS = [
    defaultBitcoinTestnetP2PKHAccountAtIndex(0)
];
// Bitcoin Testnet P2WPKH
const defaultBitcoinTestnetP2WPKHAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/84'/1'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WPKH"
    };
};
const DEFAULT_BITCOIN_TESTNET_P2WPKH_ACCOUNTS = [
    defaultBitcoinTestnetP2WPKHAccountAtIndex(0)
];
// Bitcoin Testnet P2WSH
const defaultBitcoinTestnetP2WSHAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/48'/1'/${pathIndex}'/2'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_TESTNET_P2WSH"
    };
};
const DEFAULT_BITCOIN_TESTNET_P2WSH_ACCOUNTS = [
    defaultBitcoinTestnetP2WSHAccountAtIndex(0)
];
// Bitcoin Testnet P2TR
const defaultBitcoinTestnetP2TRAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/86'/1'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_TESTNET_P2TR"
    };
};
const DEFAULT_BITCOIN_TESTNET_P2TR_ACCOUNTS = [
    defaultBitcoinTestnetP2TRAccountAtIndex(0)
];
// Bitcoin Testnet P2SH
const defaultBitcoinTestnetP2SHAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/1'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_TESTNET_P2SH"
    };
};
const DEFAULT_BITCOIN_TESTNET_P2SH_ACCOUNTS = [
    defaultBitcoinTestnetP2SHAccountAtIndex(0)
];
// Bitcoin Signet P2PKH
const defaultBitcoinSignetP2PKHAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/1'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_SIGNET_P2PKH"
    };
};
const DEFAULT_BITCOIN_SIGNET_P2PKH_ACCOUNTS = [
    defaultBitcoinSignetP2PKHAccountAtIndex(0)
];
// Bitcoin Signet P2WPKH
const defaultBitcoinSignetP2WPKHAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/84'/1'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WPKH"
    };
};
const DEFAULT_BITCOIN_SIGNET_P2WPKH_ACCOUNTS = [
    defaultBitcoinSignetP2WPKHAccountAtIndex(0)
];
// Bitcoin Signet P2WSH
const defaultBitcoinSignetP2WSHAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/48'/1'/${pathIndex}'/2'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_SIGNET_P2WSH"
    };
};
const DEFAULT_BITCOIN_SIGNET_P2WSH_ACCOUNTS = [
    defaultBitcoinSignetP2WSHAccountAtIndex(0)
];
// Bitcoin Signet P2TR
const defaultBitcoinSignetP2TRAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/86'/1'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_SIGNET_P2TR"
    };
};
const DEFAULT_BITCOIN_SIGNET_P2TR_ACCOUNTS = [
    defaultBitcoinSignetP2TRAccountAtIndex(0)
];
// Bitcoin Signet P2SH
const defaultBitcoinSignetP2SHAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/1'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_SIGNET_P2SH"
    };
};
const DEFAULT_BITCOIN_SIGNET_P2SH_ACCOUNTS = [
    defaultBitcoinSignetP2SHAccountAtIndex(0)
];
// Bitcoin Regtest P2PKH
const defaultBitcoinRegtestP2PKHAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/1'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_REGTEST_P2PKH"
    };
};
const DEFAULT_BITCOIN_REGTEST_P2PKH_ACCOUNTS = [
    defaultBitcoinRegtestP2PKHAccountAtIndex(0)
];
// Bitcoin Regtest P2WPKH
const defaultBitcoinRegtestP2WPKHAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/84'/1'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WPKH"
    };
};
const DEFAULT_BITCOIN_REGTEST_P2WPKH_ACCOUNTS = [
    defaultBitcoinRegtestP2WPKHAccountAtIndex(0)
];
// Bitcoin Regtest P2WSH
const defaultBitcoinRegtestP2WSHAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/48'/1'/${pathIndex}'/2'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_REGTEST_P2WSH"
    };
};
const DEFAULT_BITCOIN_REGTEST_P2WSH_ACCOUNTS = [
    defaultBitcoinRegtestP2WSHAccountAtIndex(0)
];
// Bitcoin Regtest P2TR
const defaultBitcoinRegtestP2TRAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/86'/1'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_REGTEST_P2TR"
    };
};
const DEFAULT_BITCOIN_REGTEST_P2TR_ACCOUNTS = [
    defaultBitcoinRegtestP2TRAccountAtIndex(0)
];
// Bitcoin Regtest P2SH
const defaultBitcoinRegtestP2SHAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/1'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_BITCOIN_REGTEST_P2SH"
    };
};
const DEFAULT_BITCOIN_REGTEST_P2SH_ACCOUNTS = [
    defaultBitcoinRegtestP2SHAccountAtIndex(0)
];
// Dogecoin Mainnet
const defaultDogeMainnetAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/3'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_DOGE_MAINNET"
    };
};
const DEFAULT_DOGE_MAINNET_ACCOUNTS = [
    defaultDogeMainnetAccountAtIndex(0)
];
// Dogecoin Testnet
const defaultDogeTestnetAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/3'/${pathIndex}'/0/0`,
        addressFormat: "ADDRESS_FORMAT_DOGE_TESTNET"
    };
};
const DEFAULT_DOGE_TESTNET_ACCOUNTS = [
    defaultDogeTestnetAccountAtIndex(0)
];
// Sei
const defaultSeiAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/118'/${pathIndex}'/0'/0'`,
        addressFormat: "ADDRESS_FORMAT_SEI"
    };
};
const DEFAULT_SEI_ACCOUNTS = [
    defaultSeiAccountAtIndex(0)
];
// Xrp
const defaultXrpAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_SECP256K1",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/144'/${pathIndex}'/0'/0'`,
        addressFormat: "ADDRESS_FORMAT_XRP"
    };
};
const DEFAULT_XRP_ACCOUNTS = [
    defaultXrpAccountAtIndex(0)
];
// ----------------------------
// CURVE_ED25519 Accounts
// ----------------------------
// Solana
const defaultSolanaAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_ED25519",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/501'/${pathIndex}'/0'`,
        addressFormat: "ADDRESS_FORMAT_SOLANA"
    };
};
const DEFAULT_SOLANA_ACCOUNTS = [
    defaultSolanaAccountAtIndex(0)
];
// SUI
const defaultSuiAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_ED25519",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/784'/${pathIndex}'/0'/0'`,
        addressFormat: "ADDRESS_FORMAT_SUI"
    };
};
const DEFAULT_SUI_ACCOUNTS = [
    defaultSuiAccountAtIndex(0)
];
// Aptos
const defaultAptosAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_ED25519",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/637'/${pathIndex}'/0'/0'`,
        addressFormat: "ADDRESS_FORMAT_APTOS"
    };
};
const DEFAULT_APTOS_ACCOUNTS = [
    defaultAptosAccountAtIndex(0)
];
// Stellar (XLM)
const defaultXlmAccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_ED25519",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/148'/${pathIndex}'`,
        addressFormat: "ADDRESS_FORMAT_XLM"
    };
};
const DEFAULT_XLM_ACCOUNTS = [
    defaultXlmAccountAtIndex(0)
];
// TON V3R2
const defaultTonV3r2AccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_ED25519",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/607'/${pathIndex}'/0'/0'`,
        addressFormat: "ADDRESS_FORMAT_TON_V3R2"
    };
};
const DEFAULT_TON_V3R2_ACCOUNTS = [
    defaultTonV3r2AccountAtIndex(0)
];
// TON V4R2
const defaultTonV4r2AccountAtIndex = (pathIndex)=>{
    return {
        curve: "CURVE_ED25519",
        pathFormat: "PATH_FORMAT_BIP32",
        path: `m/44'/607'/${pathIndex}'/0'/0'`,
        addressFormat: "ADDRESS_FORMAT_TON_V4R2"
    };
};
const DEFAULT_TON_V4R2_ACCOUNTS = [
    defaultTonV4r2AccountAtIndex(0)
];
;
 //# sourceMappingURL=turnkey-helpers.mjs.map
}),
"[project]/node_modules/@turnkey/core/dist/utils.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addressFormatConfig",
    ()=>addressFormatConfig,
    "addressFromPublicKey",
    ()=>addressFromPublicKey,
    "assertValidP256ECDSAKeyPair",
    ()=>assertValidP256ECDSAKeyPair,
    "broadcastTransaction",
    ()=>broadcastTransaction,
    "buildSignUpBody",
    ()=>buildSignUpBody,
    "createWalletAccountFromAddressFormat",
    ()=>createWalletAccountFromAddressFormat,
    "decodeVerificationToken",
    ()=>decodeVerificationToken,
    "fetchAllWalletAccountsWithCursor",
    ()=>fetchAllWalletAccountsWithCursor,
    "findWalletProviderFromAddress",
    ()=>findWalletProviderFromAddress,
    "generateRandomBuffer",
    ()=>generateRandomBuffer,
    "generateWalletAccountsFromAddressFormat",
    ()=>generateWalletAccountsFromAddressFormat,
    "getActiveSessionOrThrowIfRequired",
    ()=>getActiveSessionOrThrowIfRequired,
    "getAuthProxyConfig",
    ()=>getAuthProxyConfig,
    "getAuthenticatorAddresses",
    ()=>getAuthenticatorAddresses,
    "getClientSignatureMessageForLogin",
    ()=>getClientSignatureMessageForLogin,
    "getClientSignatureMessageForSignup",
    ()=>getClientSignatureMessageForSignup,
    "getCurveTypeFromProvider",
    ()=>getCurveTypeFromProvider,
    "getEncodedMessage",
    ()=>getEncodedMessage,
    "getEncodingType",
    ()=>getEncodingType,
    "getHashFunction",
    ()=>getHashFunction,
    "getPolicySignature",
    ()=>getPolicySignature,
    "getPublicKeyFromStampHeader",
    ()=>getPublicKeyFromStampHeader,
    "getSignatureSchemeFromProvider",
    ()=>getSignatureSchemeFromProvider,
    "googleISS",
    ()=>googleISS,
    "hexSignedTxToBase58",
    ()=>hexSignedTxToBase58,
    "isEthereumProvider",
    ()=>isEthereumProvider,
    "isReactNative",
    ()=>isReactNative,
    "isSolanaProvider",
    ()=>isSolanaProvider,
    "isValidPasskeyName",
    ()=>isValidPasskeyName,
    "isWalletAccountArray",
    ()=>isWalletAccountArray,
    "isWeb",
    ()=>isWeb,
    "mapAccountsToWallet",
    ()=>mapAccountsToWallet,
    "parseSession",
    ()=>parseSession,
    "sendSignedRequest",
    ()=>sendSignedRequest,
    "splitSignature",
    ()=>splitSignature,
    "toExternalTimestamp",
    ()=>toExternalTimestamp,
    "withTimeout",
    ()=>withTimeout,
    "withTimeoutFallback",
    ()=>withTimeoutFallback,
    "withTurnkeyErrorHandling",
    ()=>withTurnkeyErrorHandling
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/sdk-types/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__types__/enums.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$error$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__types__/error.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$base64$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/base64.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/hex.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$bs58$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/bs58.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/turnkey-helpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/dist/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/dist/crypto.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$crypto$2f$keccak$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ethers/lib.esm/crypto/keccak.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ethers/lib.esm/utils/utf8.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$generated_$5f2f$version$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__generated__/version.mjs [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
/**
 * Configuration for all supported address formats.
 *
 * Includes:
 * - encoding type
 * - hash function
 * - default accounts for the address format
 * - display name for the address format
 *
 * ```ts
 * // Example usage:
 * import { addressFormatConfig } from "@turnkey/sdk-core";
 *
 * const config = addressFormatConfig["ADDRESS_FORMAT_ETHEREUM"];
 * ```
 */ const sessionExpiredErrors = {
    pubKeyNotFound: "could not find public key in organization or its parent organization",
    apiKeyExpired: "Unauthenticated desc = expired api key publicKey"
};
// Global errors to match against error messages returned from the API
const globalErrorsToMatch = Object.freeze({
    [sessionExpiredErrors.pubKeyNotFound]: {
        message: "Session public key could not be found in the sub-organization or parent organization",
        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SESSION_EXPIRED
    },
    [sessionExpiredErrors.apiKeyExpired]: {
        message: "Session API key has expired",
        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SESSION_EXPIRED
    }
});
const addressFormatConfig = {
    ADDRESS_FORMAT_UNCOMPRESSED: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: null,
        displayName: "Uncompressed"
    },
    ADDRESS_FORMAT_COMPRESSED: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: null,
        displayName: "Compressed"
    },
    ADDRESS_FORMAT_ETHEREUM: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_KECCAK256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_ETHEREUM_ACCOUNTS"],
        displayName: "Ethereum"
    },
    ADDRESS_FORMAT_SOLANA: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_NOT_APPLICABLE",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_SOLANA_ACCOUNTS"],
        displayName: "Solana"
    },
    ADDRESS_FORMAT_COSMOS: {
        encoding: "PAYLOAD_ENCODING_TEXT_UTF8",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_COSMOS_ACCOUNTS"],
        displayName: "Cosmos"
    },
    ADDRESS_FORMAT_TRON: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_TRON_ACCOUNTS"],
        displayName: "Tron"
    },
    ADDRESS_FORMAT_SUI: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_NOT_APPLICABLE",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_SUI_ACCOUNTS"],
        displayName: "Sui"
    },
    ADDRESS_FORMAT_APTOS: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_NOT_APPLICABLE",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_APTOS_ACCOUNTS"],
        displayName: "Aptos"
    },
    ADDRESS_FORMAT_BITCOIN_MAINNET_P2PKH: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_MAINNET_P2PKH_ACCOUNTS"],
        displayName: "Bitcoin Mainnet P2PKH"
    },
    ADDRESS_FORMAT_BITCOIN_MAINNET_P2SH: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_MAINNET_P2SH_ACCOUNTS"],
        displayName: "Bitcoin Mainnet P2SH"
    },
    ADDRESS_FORMAT_BITCOIN_MAINNET_P2WPKH: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_MAINNET_P2WPKH_ACCOUNTS"],
        displayName: "Bitcoin Mainnet P2WPKH"
    },
    ADDRESS_FORMAT_BITCOIN_MAINNET_P2WSH: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_MAINNET_P2WSH_ACCOUNTS"],
        displayName: "Bitcoin Mainnet P2WSH"
    },
    ADDRESS_FORMAT_BITCOIN_MAINNET_P2TR: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_MAINNET_P2TR_ACCOUNTS"],
        displayName: "Bitcoin Mainnet P2TR"
    },
    ADDRESS_FORMAT_BITCOIN_TESTNET_P2PKH: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_TESTNET_P2PKH_ACCOUNTS"],
        displayName: "Bitcoin Testnet P2PKH"
    },
    ADDRESS_FORMAT_BITCOIN_TESTNET_P2SH: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_TESTNET_P2SH_ACCOUNTS"],
        displayName: "Bitcoin Testnet P2SH"
    },
    ADDRESS_FORMAT_BITCOIN_TESTNET_P2WPKH: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_TESTNET_P2WPKH_ACCOUNTS"],
        displayName: "Bitcoin Testnet P2WPKH"
    },
    ADDRESS_FORMAT_BITCOIN_TESTNET_P2WSH: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_TESTNET_P2WSH_ACCOUNTS"],
        displayName: "Bitcoin Testnet P2WSH"
    },
    ADDRESS_FORMAT_BITCOIN_TESTNET_P2TR: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_TESTNET_P2TR_ACCOUNTS"],
        displayName: "Bitcoin Testnet P2TR"
    },
    ADDRESS_FORMAT_BITCOIN_SIGNET_P2PKH: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_SIGNET_P2PKH_ACCOUNTS"],
        displayName: "Bitcoin Signet P2PKH"
    },
    ADDRESS_FORMAT_BITCOIN_SIGNET_P2SH: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_SIGNET_P2SH_ACCOUNTS"],
        displayName: "Bitcoin Signet P2SH"
    },
    ADDRESS_FORMAT_BITCOIN_SIGNET_P2WPKH: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_SIGNET_P2WPKH_ACCOUNTS"],
        displayName: "Bitcoin Signet P2WPKH"
    },
    ADDRESS_FORMAT_BITCOIN_SIGNET_P2WSH: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_SIGNET_P2WSH_ACCOUNTS"],
        displayName: "Bitcoin Signet P2WSH"
    },
    ADDRESS_FORMAT_BITCOIN_SIGNET_P2TR: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_SIGNET_P2TR_ACCOUNTS"],
        displayName: "Bitcoin Signet P2TR"
    },
    ADDRESS_FORMAT_BITCOIN_REGTEST_P2PKH: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_REGTEST_P2PKH_ACCOUNTS"],
        displayName: "Bitcoin Regtest P2PKH"
    },
    ADDRESS_FORMAT_BITCOIN_REGTEST_P2SH: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_REGTEST_P2SH_ACCOUNTS"],
        displayName: "Bitcoin Regtest P2SH"
    },
    ADDRESS_FORMAT_BITCOIN_REGTEST_P2WPKH: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_REGTEST_P2WPKH_ACCOUNTS"],
        displayName: "Bitcoin Regtest P2WPKH"
    },
    ADDRESS_FORMAT_BITCOIN_REGTEST_P2WSH: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_REGTEST_P2WSH_ACCOUNTS"],
        displayName: "Bitcoin Regtest P2WSH"
    },
    ADDRESS_FORMAT_BITCOIN_REGTEST_P2TR: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_BITCOIN_REGTEST_P2TR_ACCOUNTS"],
        displayName: "Bitcoin Regtest P2TR"
    },
    ADDRESS_FORMAT_SEI: {
        encoding: "PAYLOAD_ENCODING_TEXT_UTF8",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_SEI_ACCOUNTS"],
        displayName: "Sei"
    },
    ADDRESS_FORMAT_XLM: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_NOT_APPLICABLE",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_XLM_ACCOUNTS"],
        displayName: "Xlm"
    },
    ADDRESS_FORMAT_DOGE_MAINNET: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_DOGE_MAINNET_ACCOUNTS"],
        displayName: "Doge Mainnet"
    },
    ADDRESS_FORMAT_DOGE_TESTNET: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_DOGE_TESTNET_ACCOUNTS"],
        displayName: "Doge Testnet"
    },
    ADDRESS_FORMAT_TON_V3R2: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_NOT_APPLICABLE",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_TON_V3R2_ACCOUNTS"],
        displayName: "Ton V3R2"
    },
    ADDRESS_FORMAT_TON_V4R2: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_NOT_APPLICABLE",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_TON_V4R2_ACCOUNTS"],
        displayName: "Ton V4R2"
    },
    ADDRESS_FORMAT_TON_V5R1: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_NOT_APPLICABLE",
        defaultAccounts: null,
        displayName: "Ton V5R1"
    },
    ADDRESS_FORMAT_XRP: {
        encoding: "PAYLOAD_ENCODING_HEXADECIMAL",
        hashFunction: "HASH_FUNCTION_SHA256",
        defaultAccounts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_XRP_ACCOUNTS"],
        displayName: "XRP"
    }
};
const googleISS = "https://accounts.google.com";
const isReactNative = ()=>{
    const g = typeof globalThis !== "undefined" ? globalThis : /*TURBOPACK member replacement*/ __turbopack_context__.g;
    // if we have a DOM, it's definitely not RN
    // RN-web has DOM but we want false for that anyway
    if (typeof document !== "undefined" && typeof window !== "undefined") return false;
    // check for RN-specific globals
    // these shouldn't exist in Node, browsers, or webviews
    return typeof g?.__fbBatchedBridge !== "undefined" || typeof g?.nativeCallSyncHook !== "undefined" || typeof g?.RN$Bridgeless !== "undefined";
};
const isWeb = ()=>{
    return typeof window !== "undefined" && typeof document !== "undefined";
};
const generateRandomBuffer = ()=>{
    const arr = new Uint8Array(32);
    crypto.getRandomValues(arr);
    return arr.buffer;
};
Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, "0"));
const toExternalTimestamp = (date = new Date())=>{
    const millis = date.getTime();
    const seconds = Math.floor(millis / 1000);
    const nanos = millis % 1000 * 1_000_000;
    return {
        seconds: seconds.toString(),
        nanos: nanos.toString()
    };
};
async function getActiveSessionOrThrowIfRequired(stampWith, getActiveSession) {
    const session = await getActiveSession();
    // the api-key stamper requires an active session
    // if there is no stampWith defined, the default is api-key stamper
    if ((!stampWith || stampWith === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StamperType"].ApiKey) && !session) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No active session found. Please log in first.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].NO_SESSION_FOUND);
    }
    return session;
}
function parseSession(token) {
    if (typeof token !== "string") {
        return token;
    }
    const [, payload] = token.split(".");
    if (!payload) {
        throw new Error("Invalid JWT: Missing payload");
    }
    const decoded = JSON.parse(atob(payload));
    const { exp, public_key: publicKey, session_type: sessionType, user_id: userId, organization_id: organizationId } = decoded;
    if (!exp || !publicKey || !sessionType || !userId || !organizationId) {
        throw new Error("JWT payload missing required fields");
    }
    const expSeconds = Math.ceil((exp * 1000 - Date.now()) / 1000);
    return {
        sessionType,
        userId,
        organizationId,
        expiry: exp,
        expirationSeconds: expSeconds.toString(),
        publicKey,
        token
    };
}
function getHashFunction(addressFormat) {
    const config = addressFormatConfig[addressFormat];
    if (!config) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Unsupported address format: ${addressFormat}`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
    }
    return config.hashFunction;
}
function getEncodingType(addressFormat) {
    const config = addressFormatConfig[addressFormat];
    if (!config) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Unsupported address format: ${addressFormat}`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
    }
    return config.encoding;
}
function getEncodedMessage(payloadEncoding, rawMessage) {
    if (payloadEncoding === "PAYLOAD_ENCODING_HEXADECIMAL") {
        return "0x" + Array.from(rawMessage).map((b)=>b.toString(16).padStart(2, "0")).join("");
    }
    // we decode back to a UTF-8 string
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUtf8String"])(rawMessage);
}
function hexSignedTxToBase58(hex) {
    const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(hex);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$bs58$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bs58"].encode(bytes);
}
const broadcastTransaction = async (params)=>{
    const { signedTransaction, rpcUrl, transactionType } = params;
    switch(transactionType){
        case "TRANSACTION_TYPE_SOLANA":
            {
                const encodedTx = hexSignedTxToBase58(signedTransaction);
                const response = await fetch(rpcUrl, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        jsonrpc: "2.0",
                        id: 1,
                        method: "sendTransaction",
                        params: [
                            encodedTx,
                            {
                                encoding: "base58"
                            }
                        ]
                    })
                });
                const json = await response.json();
                if (json.error) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Solana RPC Error: ${json.error.message}`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SIGN_AND_SEND_TRANSACTION_ERROR);
                }
                return json.result;
            }
        case "TRANSACTION_TYPE_ETHEREUM":
            {
                const response = await fetch(rpcUrl, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        jsonrpc: "2.0",
                        id: 1,
                        method: "eth_sendRawTransaction",
                        params: [
                            signedTransaction
                        ]
                    })
                });
                const json = await response.json();
                if (json.error) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Ethereum RPC Error: ${json.error.message}`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SIGN_AND_SEND_TRANSACTION_ERROR);
                }
                return json.result;
            }
        case "TRANSACTION_TYPE_TRON":
            {
                const response = await fetch(`${rpcUrl}/wallet/broadcasthex`, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        transaction: signedTransaction
                    })
                });
                const json = await response.json();
                if (!json.result) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Tron RPC Error: ${json.message}`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SIGN_AND_SEND_TRANSACTION_ERROR);
                }
                return json.txid;
            }
        default:
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Unsupported transaction type for broadcasting: ${transactionType}`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SIGN_AND_SEND_TRANSACTION_ERROR);
    }
};
function splitSignature(signature, addressFormat) {
    const hex = signature.replace(/^0x/, "");
    if (addressFormat === "ADDRESS_FORMAT_ETHEREUM") {
        // this is a ECDSA signature
        if (hex.length === 130) {
            const r = hex.slice(0, 64);
            const s = hex.slice(64, 128);
            const v = hex.slice(128, 130);
            return {
                r,
                s,
                v
            };
        }
        // this is a DER-encoded signatures (e.g., Ledger)
        const raw = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromDerSignature"])(hex);
        const r = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(raw.slice(0, 32));
        const s = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(raw.slice(32, 64));
        // DER signatures do not have a v component
        // so we return 00 to match what Turnkey does
        const v = "00";
        return {
            r,
            s,
            v
        };
    }
    if (addressFormat === "ADDRESS_FORMAT_SOLANA") {
        if (hex.length !== 128) {
            throw new Error(`Invalid Solana signature length: expected 64 bytes (128 hex), got ${hex.length}`);
        }
        // this is a Ed25519 signature
        const r = hex.slice(0, 64);
        const s = hex.slice(64, 128);
        // solana signatures do not have a v component
        // so we return 00 to match what Turnkey does
        return {
            r,
            s,
            v: "00"
        };
    }
    throw new Error(`Unsupported address format or invalid signature length: ${hex.length}`);
}
// Type guard to check if accounts is WalletAccount[]
function isWalletAccountArray(arr) {
    return arr.length === 0 || typeof arr[0] === "object" && "addressFormat" in arr[0] && "curve" in arr[0] && "path" in arr[0] && "pathFormat" in arr[0];
}
function createWalletAccountFromAddressFormat(addressFormat) {
    const walletAccount = addressFormatConfig[addressFormat]?.defaultAccounts;
    if (!walletAccount) {
        throw new Error(`Unsupported address format: ${addressFormat}`);
    }
    if (walletAccount[0]) {
        return walletAccount[0];
    }
    throw new Error(`No default accounts defined for address format: ${addressFormat}`);
}
/**@internal */ function generateWalletAccountsFromAddressFormat(params) {
    const { addresses, existingWalletAccounts } = params;
    const pathMap = new Map();
    // Build a lookup for max index per (addressFormat, basePath)
    const maxIndexMap = new Map();
    if (existingWalletAccounts && existingWalletAccounts.length > 0) {
        for (const acc of existingWalletAccounts){
            // Normalize base path (remove account index)
            const basePath = acc.path.replace(/^((?:[^\/]+\/){3})[^\/]+/, "$1");
            const key = `${acc.addressFormat}:${basePath}`;
            const idxSegment = acc.path.split("/")[3];
            const idx = idxSegment ? parseInt(idxSegment.replace(/'/, ""), 10) : -1;
            if (!isNaN(idx)) {
                maxIndexMap.set(key, Math.max(maxIndexMap.get(key) ?? -1, idx));
            }
        }
    }
    return addresses.map((addressFormat)=>{
        const account = createWalletAccountFromAddressFormat(addressFormat);
        const basePath = account.path.replace(/^((?:[^\/]+\/){3})[^\/]+/, "$1");
        const key = `${addressFormat}:${basePath}`;
        let nextIndex = 0;
        if (maxIndexMap.has(key)) {
            nextIndex = maxIndexMap.get(key) + 1;
            maxIndexMap.set(key, nextIndex);
        } else if (pathMap.has(account.path)) {
            nextIndex = pathMap.get(account.path);
        }
        const pathWithIndex = account.path.replace(/^((?:[^\/]*\/){3})(\d+)/, (_, prefix)=>`${prefix}${nextIndex}`);
        pathMap.set(account.path, nextIndex + 1);
        return {
            ...account,
            path: pathWithIndex
        };
    });
}
function buildSignUpBody(params) {
    const { createSubOrgParams } = params;
    const authenticatorName = isWeb() ? `${window.location.hostname}-${Date.now()}` : `passkey-${Date.now()}`;
    let authenticators = [];
    if (createSubOrgParams?.authenticators?.length) {
        authenticators = createSubOrgParams?.authenticators?.map((authenticator)=>({
                authenticatorName: authenticator?.authenticatorName || authenticatorName,
                challenge: authenticator.challenge,
                attestation: authenticator.attestation
            })) || [];
    }
    let apiKeys = [];
    if (createSubOrgParams?.apiKeys?.length) {
        apiKeys = createSubOrgParams.apiKeys.filter((apiKey)=>apiKey.curveType !== undefined).map((apiKey)=>({
                apiKeyName: apiKey.apiKeyName || `api-key-${Date.now()}`,
                publicKey: apiKey.publicKey,
                curveType: apiKey.curveType,
                ...apiKey?.expirationSeconds && {
                    expirationSeconds: apiKey.expirationSeconds
                }
            }));
    }
    return {
        userName: createSubOrgParams?.userName || createSubOrgParams?.userEmail || `user-${Date.now()}`,
        ...createSubOrgParams?.userEmail && {
            userEmail: createSubOrgParams?.userEmail
        },
        ...createSubOrgParams?.authenticators?.length ? {
            authenticators
        } : {
            authenticators: []
        },
        ...createSubOrgParams?.userPhoneNumber && {
            userPhoneNumber: createSubOrgParams.userPhoneNumber
        },
        ...createSubOrgParams?.userTag && {
            userTag: createSubOrgParams?.userTag
        },
        organizationName: createSubOrgParams?.subOrgName || `sub-org-${Date.now()}`,
        ...createSubOrgParams?.verificationToken && {
            verificationToken: createSubOrgParams?.verificationToken
        },
        ...createSubOrgParams?.apiKeys?.length ? {
            apiKeys
        } : {
            apiKeys: []
        },
        ...createSubOrgParams?.oauthProviders?.length ? {
            oauthProviders: createSubOrgParams.oauthProviders
        } : {
            oauthProviders: []
        },
        ...createSubOrgParams?.customWallet && {
            wallet: {
                walletName: createSubOrgParams.customWallet.walletName,
                accounts: createSubOrgParams.customWallet.walletAccounts
            }
        }
    };
}
/**
 * Extracts the public key from a Turnkey stamp header value.
 * @param stampHeaderValue - The base64url encoded stamp header value
 * @returns The public key as a hex string
 */ function getPublicKeyFromStampHeader(stampHeaderValue) {
    try {
        // we decode the base64url string to get the JSON stamp
        const stampJson = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$base64$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeBase64urlToString"])(stampHeaderValue);
        // we parse the JSON to get the stamp object
        const stamp = JSON.parse(stampJson);
        return stamp.publicKey;
    } catch (error) {
        throw new Error(`Failed to extract public key from stamp header: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**@internal */ function getPolicySignature(policy) {
    return JSON.stringify({
        policyName: policy.policyName,
        effect: policy.effect,
        condition: policy.condition ?? null,
        consensus: policy.consensus ?? null
    });
}
/**@internal */ function isEthereumProvider(provider) {
    return provider.chainInfo.namespace === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Chain"].Ethereum;
}
/**@internal */ function isSolanaProvider(provider) {
    return provider.chainInfo.namespace === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Chain"].Solana;
}
/** @internal */ function getCurveTypeFromProvider(provider) {
    if (isEthereumProvider(provider)) {
        return "API_KEY_CURVE_SECP256K1";
    }
    if (isSolanaProvider(provider)) {
        return "API_KEY_CURVE_ED25519";
    }
    // we should never hit this case
    // if we do then it means we added support for a new chain but missed updating this function
    throw new Error(`Unsupported provider namespace: ${provider.chainInfo.namespace}. Expected Ethereum or Solana.`);
}
/** @internal */ function getSignatureSchemeFromProvider(provider) {
    if (isEthereumProvider(provider)) {
        return "SIGNATURE_SCHEME_TK_API_SECP256K1_EIP191";
    }
    if (isSolanaProvider(provider)) {
        return "SIGNATURE_SCHEME_TK_API_ED25519";
    }
    // we should never hit this case
    // if we do then it means we added support for a new chain but missed updating this function
    throw new Error(`Unsupported provider namespace: ${provider.chainInfo.namespace}. Expected Ethereum or Solana.`);
}
/** @internal */ function findWalletProviderFromAddress(address, providers) {
    for (const provider of providers){
        if (provider.connectedAddresses.includes(address)) {
            return provider;
        }
    }
    // no provider found for that address
    return undefined;
}
/**
 * Derives a wallet address from a given public key and chain.
 *
 * @param chain - "ethereum" or "solana"
 * @param publicKey - The raw public key string (can be compressed or uncompressed)
 * @returns The derived wallet address
 */ function addressFromPublicKey(chain, publicKey) {
    if (chain === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Chain"].Ethereum) {
        const publicKeyBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(publicKey);
        let uncompressedKey;
        if (publicKeyBytes.length === 65 && publicKeyBytes[0] === 0x04) {
            // it's already uncompressed so we just convert
            // to hex without the 04 prefix
            uncompressedKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(publicKeyBytes.slice(1));
        } else {
            // it's compressed, so we need to uncompress it first
            // then convert to hex without the 04 prefix
            const publicKeyUncompressed = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$crypto$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uncompressRawPublicKey"])(publicKeyBytes, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"].SECP256K1);
            uncompressedKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(publicKeyUncompressed.slice(1));
        }
        // hash with Keccak256 and take last 20 bytes
        const hash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$crypto$2f$keccak$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["keccak256"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(uncompressedKey));
        return "0x" + hash.slice(-40);
    }
    if (chain === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Chain"].Solana) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$bs58$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bs58"].encode((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayFromHexString"])(publicKey));
    }
    throw new Error(`Unsupported chain: ${chain}`);
}
/**@internal */ function getAuthenticatorAddresses(user) {
    const ethereum = [];
    const solana = [];
    for (const key of user.apiKeys){
        const { type, publicKey } = key.credential;
        switch(type){
            case "CREDENTIAL_TYPE_API_KEY_SECP256K1":
                ethereum.push(addressFromPublicKey(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Chain"].Ethereum, publicKey));
                break;
            case "CREDENTIAL_TYPE_API_KEY_ED25519":
                solana.push(addressFromPublicKey(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Chain"].Solana, publicKey));
                break;
        }
    }
    return {
        ethereum,
        solana
    };
}
/**@internal */ async function getAuthProxyConfig(authProxyConfigId, authProxyUrl) {
    const fullUrl = (authProxyUrl ?? "https://authproxy.turnkey.com") + "/v1/wallet_kit_config";
    var headers = {
        "Content-Type": "application/json",
        "X-Auth-Proxy-Config-ID": authProxyConfigId
    };
    const response = await fetch(fullUrl, {
        method: "POST",
        headers: headers
    });
    if (!response.ok) {
        let res;
        try {
            res = await response.json();
        } catch (_) {
            throw new Error(`${response.status} ${response.statusText}`);
        }
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$error$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyRequestError"](res);
    }
    const data = await response.json();
    return data;
}
/**
 * Submits a signed request to Turnkey.
 *
 * You can pass in the SignedRequest returned by any of the SDK's
 * stamping methods (stampStampLogin, stampGetPolicies, etc.).
 *
 * @deprecated Use `httpClient.sendSignedRequest()` instead, which includes
 * automatic activity polling and result extraction.
 *
 * @param signedRequest A SignedRequest object returned by a stamping method.
 * @returns The parsed JSON response from Turnkey.
 * @throws TurnkeyNetworkError if the request fails.
 */ // TODO: (breaking change) remove this function
async function sendSignedRequest(signedRequest) {
    const headers = {
        "Content-Type": "application/json",
        "X-Client-Version": __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$generated_$5f2f$version$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERSION"],
        [signedRequest.stamp.stampHeaderName]: signedRequest.stamp.stampHeaderValue
    };
    const res = await fetch(signedRequest.url, {
        method: "POST",
        headers,
        body: signedRequest.body
    });
    if (!res.ok) {
        const errorText = await res.text();
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyNetworkError"]("Signed request failed", res.status, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE, errorText);
    }
    return res.json();
}
/**
 * @internal
 * Executes an async function with error handling.
 *
 * @param fn The async function to execute with error handling
 * @param errorOptions Options for customizing error handling
 * @param errorOptions.catchFn Optional function to execute in the catch block
 * @param errorOptions.errorMessage The default error message to use if no custom message is found
 * @param errorOptions.errorCode The default error code to use if no custom message is found
 * @param errorOptions.customErrorsByCodes Optional mapping of error codes to custom messages, if you're trying to target a specific error code and surface a custom message, use this
 * @param errorOptions.customErrorsByMessages Optional mapping of error messages to custom messages, if you're trying to target a specific error message and surface a custom message, use this
 * @param finallyFn Optional function to execute in the finally block
 * @returns The result of the async function or throws an error
 */ async function withTurnkeyErrorHandling(fn, catchOptions, finallyOptions) {
    const { errorMessage, errorCode, customErrorsByCodes, catchFn } = catchOptions;
    // Merge global error mappings with any caller-provided ones.
    //   - Start with the globals so theyre always available.
    //   - Spread the callers entries last so they override globals on conflicts.
    //   - If the caller didnt provide any, just fall back to the globals.
    const customErrorsByMessages = catchOptions.customErrorsByMessages ? {
        ...globalErrorsToMatch,
        ...catchOptions.customErrorsByMessages
    } : globalErrorsToMatch;
    const finallyFn = finallyOptions?.finallyFn;
    try {
        return await fn();
    } catch (error) {
        await catchFn?.();
        // some things throw plain objects (not Error instances), which would stringify as `[object Object]`
        // we normalize here to always produce a readable error message before wrapping it in TurnkeyError.
        const normalizedMessage = error instanceof Error && typeof error.message === "string" ? error.message : typeof error?.message === "string" ? error.message : JSON.stringify(error);
        if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]) {
            const customCodeMessage = customErrorsByCodes?.[error.code];
            if (customCodeMessage) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](customCodeMessage.message, customCodeMessage.code, error);
            }
            throwMatchingMessage(error.message, customErrorsByMessages, error);
            throw error;
        } else if (error instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$error$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyRequestError"]) {
            throwMatchingMessage(normalizedMessage, customErrorsByMessages, error);
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](errorMessage, errorCode, error);
        } else if (error instanceof Error) {
            throwMatchingMessage(normalizedMessage, customErrorsByMessages, error);
            // Wrap other errors in a TurnkeyError
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](errorMessage, errorCode, error);
        } else {
            throwMatchingMessage(normalizedMessage, customErrorsByMessages, error);
            // Handle non-Error exceptions
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](normalizedMessage, errorCode, error);
        }
    } finally{
        await finallyFn?.();
    }
}
/**
 * Throws a TurnkeyError with a custom message if the error message matches any key in customMessageByMessages.
 * If no match is found, it does nothing.
 *
 * @param errorMessage The error message to check against the custom messages.
 * @param customErrorsByMessages An object mapping error messages to custom messages and codes.
 * @param error The original error that triggered this function.
 */ const throwMatchingMessage = (errorMessage, customErrorsByMessages, error)=>{
    if (customErrorsByMessages && Object.keys(customErrorsByMessages).length > 0) {
        Object.keys(customErrorsByMessages).forEach((key)=>{
            if (errorMessage.includes(key)) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](customErrorsByMessages[key].message, customErrorsByMessages[key].code, error);
            }
        });
    }
};
/**
 * @internal
 *
 * Asserts that the provided key pair is a valid P-256 ECDSA key pair.
 * @param pair The key pair to validate.
 */ async function assertValidP256ECDSAKeyPair(pair) {
    const { privateKey, publicKey } = pair;
    // Check basic shape
    if (!(privateKey instanceof CryptoKey) || !(publicKey instanceof CryptoKey)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Both keys must be CryptoKey instances.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
    }
    if (privateKey.type !== "private") throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("privateKey.type must be 'private'.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
    if (publicKey.type !== "public") throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("publicKey.type must be 'public'.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
    // Verify extractability and usages
    if (privateKey.extractable !== false) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Provided privateKey must be non-extractable.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
    }
    if (!privateKey.usages.includes("sign")) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("privateKey must have 'sign' in keyUsages.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
    }
    if (!publicKey.usages.includes("verify")) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("publicKey must have 'verify' in keyUsages.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
    }
    // Algorithm checks (must be ECDSA on P-256)
    const pAlg = privateKey.algorithm;
    const pubAlg = publicKey.algorithm;
    if (pAlg.name !== "ECDSA" || pubAlg.name !== "ECDSA") {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Keys must be ECDSA keys.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
    }
    if (pAlg.namedCurve !== "P-256" || pubAlg.namedCurve !== "P-256") {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Keys must be on the P-256 curve.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
    }
    // Public key export sanity (should be uncompressed 65 bytes starting with 0x04)
    const rawPub = new Uint8Array(await crypto.subtle.exportKey("raw", publicKey));
    if (rawPub.length !== 65 || rawPub[0] !== 0x04) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Public key must be an uncompressed P-256 point (65 bytes, leading 0x04).", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
    }
    // Prove the pair matches: signverify a test message
    const msg = crypto.getRandomValues(new Uint8Array(32));
    const sig = await crypto.subtle.sign({
        name: "ECDSA",
        hash: "SHA-256"
    }, privateKey, msg);
    const ok = await crypto.subtle.verify({
        name: "ECDSA",
        hash: "SHA-256"
    }, publicKey, sig, msg);
    if (!ok) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("publicKey does not match privateKey (verify failed).", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
    }
}
function isValidPasskeyName(name) {
    const nameRegex = isReactNative() ? /^[a-zA-Z0-9 _\-:\/\.]{1,64}$/ : /^[a-zA-Z0-9 _\-:\/\.]+$/;
    if (!nameRegex.test(name)) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Passkey name must be 1-64 characters and only contain letters, numbers, spaces, dashes, underscores, colons, or slashes.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
    }
    return name;
}
function mapAccountsToWallet(accounts, walletMap) {
    // map of walletId to Wallet
    // map all wallet accounts to their wallets
    accounts.forEach(async (account)=>{
        if (walletMap.has(account.walletDetails.walletId)) {
            const wallet = walletMap.get(account.walletDetails.walletId);
            wallet.accounts.push({
                ...account,
                source: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WalletSource"].Embedded
            });
            return;
        } else {
            walletMap.set(account.walletDetails.walletId, {
                source: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WalletSource"].Embedded,
                walletId: account.walletDetails.walletId,
                walletName: account.walletDetails.walletName,
                createdAt: account.walletDetails.createdAt,
                updatedAt: account.walletDetails.updatedAt,
                exported: account.walletDetails.exported,
                imported: account.walletDetails.imported,
                accounts: [
                    {
                        ...account,
                        source: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WalletSource"].Embedded
                    }
                ]
            });
        }
    });
    return Array.from(walletMap.values());
}
async function withTimeout(promise, ms, label) {
    let timeout;
    const timer = new Promise((_, reject)=>{
        timeout = setTimeout(()=>reject(new Error(`${label} timed out after ${ms}ms`)), ms);
    });
    return Promise.race([
        promise,
        timer
    ]).finally(()=>clearTimeout(timeout));
}
async function fetchAllWalletAccountsWithCursor(httpClient, organizationId, stampWith) {
    let hasMore = true;
    let cursor;
    const accounts = [];
    const limit = 100;
    while(hasMore){
        const response = await httpClient.getWalletAccounts({
            organizationId,
            includeWalletDetails: true,
            paginationOptions: {
                limit: limit.toString(),
                ...cursor && {
                    after: cursor
                }
            }
        }, stampWith);
        if (!response || !response.accounts) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No wallet accounts found in the response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
        }
        accounts.push(...response.accounts);
        hasMore = response.accounts.length === limit;
        cursor = response.accounts && response.accounts.length > 0 ? response.accounts[response.accounts.length - 1]?.walletAccountId : undefined;
    }
    return accounts;
}
function decodeVerificationToken(verificationToken) {
    const [, payloadB64] = verificationToken.split(".");
    if (!payloadB64) {
        throw new Error("Invalid token: missing payload");
    }
    const json = atob(payloadB64);
    return JSON.parse(json);
}
function getClientSignatureMessageForLogin({ verificationToken, sessionPublicKey = undefined }) {
    try {
        const decoded = decodeVerificationToken(verificationToken);
        if (!decoded.public_key) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Invalid verification token: missing publicKey", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
        const verificationPublicKey = decoded.public_key;
        // if a session public key is provided, we use it instead
        const resolvedSessionPublicKey = sessionPublicKey || verificationPublicKey;
        const usage = {
            publicKey: resolvedSessionPublicKey
        };
        const payload = {
            login: usage,
            tokenId: decoded.id,
            type: "USAGE_TYPE_LOGIN"
        };
        const json = JSON.stringify(payload);
        return {
            message: json,
            publicKey: verificationPublicKey
        };
    } catch (error) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to create client signature bundle for login", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].UNKNOWN, error);
    }
}
function getClientSignatureMessageForSignup({ verificationToken, email, phoneNumber, apiKeys, authenticators, oauthProviders }) {
    try {
        const decoded = decodeVerificationToken(verificationToken);
        if (!decoded.public_key) throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Invalid verification token: missing publicKey", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
        const verificationPublicKey = decoded.public_key;
        const usage = {
            ...apiKeys ? {
                apiKeys
            } : {},
            ...authenticators ? {
                authenticators
            } : {},
            ...oauthProviders ? {
                oauthProviders
            } : {},
            ...email ? {
                email
            } : {},
            ...phoneNumber ? {
                phoneNumber
            } : {}
        };
        const payload = {
            signup: usage,
            tokenId: decoded.id,
            type: "USAGE_TYPE_SIGNUP"
        };
        const json = JSON.stringify(payload);
        return {
            message: json,
            publicKey: verificationPublicKey
        };
    } catch (error) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to create client signature bundle for signup", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].UNKNOWN, error);
    }
}
/**
 * Wraps a promise with a timeout. If the promise doesn't resolve within
 * the specified duration, it resolves to the fallback value instead of throwing.
 *
 * @param promise - The promise to wrap.
 * @param fallback - Value to return if the timeout is reached.
 * @param timeoutMs - Timeout duration in milliseconds. Defaults to 1000ms.
 * @returns The result of the promise, or the fallback if timed out.
 */ const withTimeoutFallback = (promise, fallback, timeoutMs)=>{
    const timeout = 1000;
    return Promise.race([
        promise,
        new Promise((resolve)=>setTimeout(()=>resolve(fallback), timeout))
    ]);
};
;
 //# sourceMappingURL=utils.mjs.map
}),
"[project]/node_modules/@turnkey/core/dist/__polyfills__/window.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>WindowWrapper
]);
const loadWindow = ()=>{
    if (typeof window !== "undefined") {
        return window;
    } else {
        return {
            localStorage: {
                getItem: (_key)=>{
                    return null;
                },
                setItem: (_key, _value)=>{},
                removeItem: (_key)=>{},
                clear: ()=>{},
                key: (_index)=>{
                    return null;
                },
                length: 0
            },
            location: {
                hostname: ""
            }
        };
    }
};
var WindowWrapper = loadWindow();
;
 //# sourceMappingURL=window.mjs.map
}),
"[project]/node_modules/@turnkey/core/dist/__storage__/web/storage.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WebStorageManager",
    ()=>WebStorageManager
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$polyfills_$5f2f$window$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__polyfills__/window.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__types__/enums.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/utils.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/sdk-types/dist/index.mjs [app-client] (ecmascript)");
;
;
;
;
const browserStorage = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$polyfills_$5f2f$window$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].localStorage;
class WebStorageManager {
    constructor(){
        this.getStorageValue = async (sessionKey)=>{
            const item = browserStorage.getItem(sessionKey);
            return item ? JSON.parse(item) : undefined;
        };
        this.setStorageValue = async (sessionKey, storageValue)=>{
            if (storageValue === undefined) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Session value cannot be undefined", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].STORE_SESSION_ERROR);
            }
            browserStorage.setItem(sessionKey, JSON.stringify(storageValue));
        };
        this.setActiveSessionKey = async (sessionKey)=>{
            await this.setStorageValue(WebStorageManager.ACTIVE_SESSION_KEY, sessionKey);
        };
        this.removeStorageValue = async (sessionKey)=>{
            browserStorage.removeItem(sessionKey);
        };
        this.storeSession = async (session, sessionKey = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SessionKey"].DefaultSessionkey)=>{
            const sessionWithMetadata = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseSession"])(session);
            await this.setStorageValue(sessionKey, sessionWithMetadata);
            // Ensure the session key is stored in the session keys list
            const keys = await this.getStorageValue(WebStorageManager.ALL_SESSION_KEYS) ?? [];
            if (!keys.includes(sessionKey)) {
                keys.push(sessionKey);
                await this.setStorageValue(WebStorageManager.ALL_SESSION_KEYS, keys);
            }
            // Set the active session key
            await this.setStorageValue(WebStorageManager.ACTIVE_SESSION_KEY, sessionKey);
        };
        this.getSession = async (sessionKey = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SessionKey"].DefaultSessionkey)=>{
            return this.getStorageValue(sessionKey);
        };
        this.getActiveSessionKey = async ()=>{
            return this.getStorageValue(WebStorageManager.ACTIVE_SESSION_KEY);
        };
        this.getActiveSession = async ()=>{
            const key = await this.getActiveSessionKey();
            return key ? this.getSession(key) : undefined;
        };
        this.listSessionKeys = async ()=>{
            return await this.getStorageValue(WebStorageManager.ALL_SESSION_KEYS) ?? [];
        };
        this.clearSession = async (sessionKey)=>{
            await this.removeStorageValue(sessionKey);
            const keys = await this.listSessionKeys();
            const updated = keys.filter((k)=>k !== sessionKey);
            await this.setStorageValue(WebStorageManager.ALL_SESSION_KEYS, updated);
            const active = await this.getActiveSessionKey();
            if (active === sessionKey) {
                await this.removeStorageValue(WebStorageManager.ACTIVE_SESSION_KEY);
            }
        };
        this.clearAllSessions = async ()=>{
            const keys = await this.listSessionKeys();
            await Promise.all(keys.map((k)=>this.removeStorageValue(k)));
            await this.removeStorageValue(WebStorageManager.ALL_SESSION_KEYS);
            await this.removeStorageValue(WebStorageManager.ACTIVE_SESSION_KEY);
        };
        this.storeWallets = async (wallets)=>{
            for (const wallet of wallets){
                browserStorage.setItem(wallet.walletId, JSON.stringify(wallet));
            }
        };
    }
}
WebStorageManager.ALL_SESSION_KEYS = "@turnkey/all-session-keys";
WebStorageManager.ACTIVE_SESSION_KEY = "@turnkey/active-session-key";
;
 //# sourceMappingURL=storage.mjs.map
}),
"[project]/node_modules/@turnkey/core/dist/__storage__/base.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createStorageManager",
    ()=>createStorageManager
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$storage_$5f2f$web$2f$storage$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__storage__/web/storage.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/utils.mjs [app-client] (ecmascript)");
;
;
// TODO (Amir): Turn this into a class that extends StorageBase and make an init function. See stamper
async function createStorageManager() {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isReactNative"])()) {
        try {
            // Dynamic import to prevent bundling the native module in web environments
            const { MobileStorageManager } = await __turbopack_context__.A("[project]/node_modules/@turnkey/core/dist/__storage__/mobile/storage.mjs [app-client] (ecmascript, async loader)");
            return new MobileStorageManager();
        } catch (error) {
            throw new Error(`Failed to load storage manager for react-native: ${error}`);
        }
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWeb"])()) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$storage_$5f2f$web$2f$storage$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebStorageManager"]();
    } else {
        throw new Error("Unsupported environment for storage manager.");
    }
}
;
 //# sourceMappingURL=base.mjs.map
}),
"[project]/node_modules/@turnkey/core/dist/__stampers__/api/web/stamper.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "IndexedDbStamper",
    ()=>IndexedDbStamper
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$encode$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/encode.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/hex.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$base64$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/base64.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/utils.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/api-key-stamper/dist/index.mjs [app-client] (ecmascript) <locals>");
;
;
;
const DB_NAME = "TurnkeyStamperDB";
const DB_STORE = "KeyStore";
const stampHeaderName = "X-Stamp";
/**
 * `SubtleCrypto.sign(...)` outputs signature in IEEE P1363 format:
 * - https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign#ecdsa
 *
 * Turnkey expects the signature encoding to be DER-encoded ASN.1:
 * - https://github.com/tkhq/tkcli/blob/7f0159af5a73387ff050647180d1db4d3a3aa033/src/internal/apikey/apikey.go#L149
 *
 * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts#L114
 *
 * Transform an ECDSA signature in IEEE 1363 encoding to DER encoding.
 *
 * @param ieee the ECDSA signature in IEEE encoding
 * @return ECDSA signature in DER encoding
 */ function convertEcdsaIeee1363ToDer(ieee) {
    if (ieee.length % 2 != 0 || ieee.length == 0 || ieee.length > 132) {
        throw new Error("Invalid IEEE P1363 signature encoding. Length: " + ieee.length);
    }
    const r = toUnsignedBigNum(ieee.subarray(0, ieee.length / 2));
    const s = toUnsignedBigNum(ieee.subarray(ieee.length / 2, ieee.length));
    let offset = 0;
    const length = 1 + 1 + r.length + 1 + 1 + s.length;
    let der;
    if (length >= 128) {
        der = new Uint8Array(length + 3);
        der[offset++] = 48;
        der[offset++] = 128 + 1;
        der[offset++] = length;
    } else {
        der = new Uint8Array(length + 2);
        der[offset++] = 48;
        der[offset++] = length;
    }
    der[offset++] = 2;
    der[offset++] = r.length;
    der.set(r, offset);
    offset += r.length;
    der[offset++] = 2;
    der[offset++] = s.length;
    der.set(s, offset);
    return der;
}
/**
 * Code modified from https://github.com/google/tink/blob/6f74b99a2bfe6677e3670799116a57268fd067fa/javascript/subtle/elliptic_curves.ts#L311
 *
 * Transform a big integer in big endian to minimal unsigned form which has
 * no extra zero at the beginning except when the highest bit is set.
 */ function toUnsignedBigNum(bytes) {
    let start = 0;
    while(start < bytes.length && bytes[start] == 0){
        start++;
    }
    if (start == bytes.length) {
        start = bytes.length - 1;
    }
    let extraZero = 0;
    if ((bytes[start] & 128) == 128) {
        extraZero = 1;
    }
    const res = new Uint8Array(bytes.length - start + extraZero);
    res.set(bytes.subarray(start), extraZero);
    return res;
}
class IndexedDbStamper {
    constructor(){
        if (typeof window === "undefined") {
            throw new Error("IndexedDB is only available in the browser");
        }
    }
    async openDb() {
        return new Promise((resolve, reject)=>{
            const request = indexedDB.open(DB_NAME, 1);
            request.onupgradeneeded = (event)=>{
                const db = event.target.result;
                if (!db.objectStoreNames.contains(DB_STORE)) {
                    db.createObjectStore(DB_STORE);
                }
            };
            request.onsuccess = ()=>resolve(request.result);
            request.onerror = ()=>reject(request.error);
        });
    }
    async storeKeyPair(publicKeyHex, privateKey) {
        const db = await this.openDb();
        return new Promise((resolve, reject)=>{
            const tx = db.transaction(DB_STORE, "readwrite");
            const store = tx.objectStore(DB_STORE);
            store.put(privateKey, publicKeyHex);
            tx.oncomplete = ()=>{
                db.close();
                resolve();
            };
            tx.onerror = ()=>reject(tx.error);
            tx.onabort = ()=>reject(tx.error);
        });
    }
    async getPrivateKey(publicKeyHex) {
        const db = await this.openDb();
        return new Promise((resolve, reject)=>{
            const tx = db.transaction(DB_STORE, "readonly");
            const store = tx.objectStore(DB_STORE);
            const request = store.get(publicKeyHex);
            request.onsuccess = ()=>{
                db.close();
                resolve(request.result || null);
            };
            request.onerror = ()=>{
                db.close();
                reject(request.error);
            };
        });
    }
    async listKeyPairs() {
        const db = await this.openDb();
        return new Promise((resolve, reject)=>{
            const tx = db.transaction(DB_STORE, "readonly");
            const store = tx.objectStore(DB_STORE);
            const request = store.getAllKeys();
            request.onsuccess = ()=>{
                db.close();
                resolve(request.result);
            };
            request.onerror = ()=>{
                db.close();
                reject(request.error);
            };
        });
    }
    async createKeyPair(externalKeyPair) {
        let privateKey;
        let publicKey;
        if (externalKeyPair) {
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["assertValidP256ECDSAKeyPair"])(externalKeyPair);
            privateKey = externalKeyPair.privateKey;
            publicKey = externalKeyPair.publicKey;
        } else {
            const keyPair = await crypto.subtle.generateKey({
                name: "ECDSA",
                namedCurve: "P-256"
            }, false, [
                "sign",
                "verify"
            ]);
            privateKey = keyPair.privateKey;
            publicKey = keyPair.publicKey;
        }
        const rawPubKey = new Uint8Array(await crypto.subtle.exportKey("raw", publicKey));
        const compressedPubKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$encode$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pointEncode"])(rawPubKey);
        const compressedHex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(compressedPubKey);
        await this.storeKeyPair(compressedHex, privateKey);
        return compressedHex;
    }
    async deleteKeyPair(publicKeyHex) {
        const db = await this.openDb();
        return new Promise((resolve, reject)=>{
            const tx = db.transaction(DB_STORE, "readwrite");
            const store = tx.objectStore(DB_STORE);
            store.delete(publicKeyHex);
            tx.oncomplete = ()=>{
                db.close();
                resolve();
            };
            tx.onerror = ()=>reject(tx.error);
        });
    }
    async clearKeyPairs() {
        const db = await this.openDb();
        return new Promise((resolve, reject)=>{
            const tx = db.transaction(DB_STORE, "readwrite");
            const store = tx.objectStore(DB_STORE);
            store.clear();
            tx.oncomplete = ()=>{
                db.close();
                resolve();
            };
            tx.onerror = ()=>reject(tx.error);
        });
    }
    async sign(payload, publicKeyHex, format) {
        const privateKey = await this.getPrivateKey(publicKeyHex);
        if (!privateKey) {
            throw new Error("Key not found for publicKey: " + publicKeyHex);
        }
        const encodedPayload = new TextEncoder().encode(payload);
        const signatureIeee1363 = await crypto.subtle.sign({
            name: "ECDSA",
            hash: {
                name: "SHA-256"
            }
        }, privateKey, encodedPayload);
        if (format === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["SignatureFormat"].Raw) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(new Uint8Array(signatureIeee1363));
        } else {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(convertEcdsaIeee1363ToDer(new Uint8Array(signatureIeee1363)));
        }
    }
    async stamp(payload, publicKeyHex) {
        const signature = await this.sign(payload, publicKeyHex, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["SignatureFormat"].Der);
        const stamp = {
            publicKey: publicKeyHex,
            scheme: "SIGNATURE_SCHEME_TK_API_P256",
            signature
        };
        return {
            stampHeaderName,
            stampHeaderValue: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$base64$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringToBase64urlString"])(JSON.stringify(stamp))
        };
    }
}
;
 //# sourceMappingURL=stamper.mjs.map
}),
"[project]/node_modules/@turnkey/core/dist/__stampers__/api/base.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CrossPlatformApiKeyStamper",
    ()=>CrossPlatformApiKeyStamper
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/utils.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$stampers_$5f2f$api$2f$web$2f$stamper$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__stampers__/api/web/stamper.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/sdk-types/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/api-key-stamper/dist/index.mjs [app-client] (ecmascript) <locals>");
;
;
;
;
/**
 * Cross-platform API key stamper.
 *
 * - This stamper uses indexedDB on web and keychain on react-native to securely stamp Turnkey requests.
 * - ***Only supports P-256 ECDSA key pairs.***
 */ class CrossPlatformApiKeyStamper {
    constructor(storageManager){
        this.storageManager = storageManager;
    // Use init method to set up the stamper based on the platform. It's async, so can't be done in the constructor.
    }
    async init() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWeb"])()) {
            this.stamper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$stampers_$5f2f$api$2f$web$2f$stamper$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IndexedDbStamper"]();
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isReactNative"])()) {
            try {
                // Dynamic import to prevent bundling the native module in web environments.
                const { ReactNativeKeychainStamper } = await __turbopack_context__.A("[project]/node_modules/@turnkey/core/dist/__stampers__/api/mobile/stamper.mjs [app-client] (ecmascript, async loader)");
                this.stamper = new ReactNativeKeychainStamper();
            } catch (error) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Failed to load keychain stamper for react-native`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INITIALIZE_CLIENT_ERROR, error);
            }
        } else {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Unsupported platform for API key stamper", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].UNSUPPORTED_PLATFORM);
        }
    }
    listKeyPairs() {
        if (!this.stamper) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Stamper is not initialized. Please call .init() before calling this method.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CLIENT_NOT_INITIALIZED);
        }
        return this.stamper.listKeyPairs();
    }
    createKeyPair(externalKeyPair) {
        if (!this.stamper) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Stamper is not initialized. Please call .init() before calling this method.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CLIENT_NOT_INITIALIZED);
        }
        return this.stamper.createKeyPair(externalKeyPair);
    }
    deleteKeyPair(publicKeyHex) {
        if (!this.stamper) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Stamper is not initialized. Please call .init() before calling this method.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CLIENT_NOT_INITIALIZED);
        }
        // If the deleted key pair is the temporary one, clear it.
        if (this.temporaryPublicKey === publicKeyHex) {
            this.temporaryPublicKey = undefined;
        }
        return this.stamper.deleteKeyPair(publicKeyHex);
    }
    clearKeyPairs() {
        if (!this.stamper) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Stamper is not initialized. Please call .init() before calling this method.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CLIENT_NOT_INITIALIZED);
        }
        return this.stamper.clearKeyPairs();
    }
    // This allows forcing a specific public key to find the key pair for stamping. The key pair must already exist in indexedDB / Keychain.
    // This is useful if you need to stamp with a specific key pair without having an active session.
    // See "signUpWithPasskey" function in core.ts for usage
    setTemporaryPublicKey(publicKeyHex) {
        this.temporaryPublicKey = publicKeyHex;
    }
    getTemporaryPublicKey() {
        return this.temporaryPublicKey;
    }
    clearTemporaryPublicKey() {
        this.temporaryPublicKey = undefined;
    }
    async stamp(payload) {
        if (!this.stamper) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Stamper is not initialized. Please call .init() before calling this method.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CLIENT_NOT_INITIALIZED);
        }
        let publicKeyHex = this.temporaryPublicKey;
        if (!publicKeyHex) {
            const session = await this.storageManager.getActiveSession();
            if (!session) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No active session or token available.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].NO_SESSION_FOUND);
            }
            publicKeyHex = session.publicKey;
        }
        return this.stamper.stamp(payload, publicKeyHex);
    }
    async sign(payload, format = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["SignatureFormat"].Der) {
        if (!this.stamper) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Stamper is not initialized. Please call .init() before calling this method.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CLIENT_NOT_INITIALIZED);
        }
        let publicKeyHex = this.temporaryPublicKey;
        if (!publicKeyHex) {
            const session = await this.storageManager.getActiveSession();
            if (!session) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No active session or token available.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].NO_SESSION_FOUND);
            }
            publicKeyHex = session.publicKey;
        }
        return this.stamper.sign(payload, publicKeyHex, format);
    }
}
;
 //# sourceMappingURL=base.mjs.map
}),
"[project]/node_modules/@turnkey/core/dist/__stampers__/passkey/base.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CrossPlatformPasskeyStamper",
    ()=>CrossPlatformPasskeyStamper
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/utils.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/webauthn-stamper/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$base64$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/base64.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/encoding/dist/hex.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$http$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/http/dist/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$http$2f$dist$2f$webauthn$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/http/dist/webauthn.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__ = __turbopack_context__.i("[project]/node_modules/uuid/dist/esm-browser/v4.js [app-client] (ecmascript) <export default as v4>");
;
;
;
;
;
let PasskeyStamperModule;
class CrossPlatformPasskeyStamper {
    constructor(config){
        /**
         * Create a passkey for an end-user, taking care of various lower-level details.
         *
         * @returns {Promise<Passkey>}
         */ this.createWebPasskey = async (config = {})=>{
            const challenge = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["generateRandomBuffer"])();
            const encodedChallenge = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$base64$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64StringToBase64UrlEncodedString"])(btoa(String.fromCharCode(...new Uint8Array(challenge))));
            const authenticatorUserId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["generateRandomBuffer"])();
            // WebAuthn credential options options can be found here:
            // https://www.w3.org/TR/webauthn-2/#sctn-sample-registration
            //
            // All pubkey algorithms can be found here: https://www.iana.org/assignments/cose/cose.xhtml#algorithms
            // Turnkey only supports ES256 (-7) and RS256 (-257)
            //
            // The pubkey type only supports one value, "public-key"
            // See https://www.w3.org/TR/webauthn-2/#enumdef-publickeycredentialtype for more details
            // TODO: consider un-nesting these config params
            const webauthnConfig = {
                publicKey: {
                    rp: {
                        id: config.publicKey?.rp?.id ?? this.config.rpId,
                        name: config.publicKey?.rp?.name ?? ""
                    },
                    challenge: config.publicKey?.challenge ?? challenge,
                    pubKeyCredParams: config.publicKey?.pubKeyCredParams ?? [
                        {
                            type: "public-key",
                            alg: -7
                        },
                        {
                            type: "public-key",
                            alg: -257
                        }
                    ],
                    user: {
                        id: config.publicKey?.user?.id ?? authenticatorUserId,
                        name: config.publicKey?.user?.name ?? "Default User",
                        displayName: config.publicKey?.user?.displayName ?? "Default User"
                    },
                    authenticatorSelection: {
                        authenticatorAttachment: config.publicKey?.authenticatorSelection?.authenticatorAttachment ?? undefined,
                        requireResidentKey: config.publicKey?.authenticatorSelection?.requireResidentKey ?? true,
                        residentKey: config.publicKey?.authenticatorSelection?.residentKey ?? "required",
                        userVerification: config.publicKey?.authenticatorSelection?.userVerification ?? "preferred"
                    }
                }
            };
            const attestation = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$http$2f$dist$2f$webauthn$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWebAuthnAttestation"])(webauthnConfig);
            return {
                encodedChallenge: config.publicKey?.challenge ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$base64$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64StringToBase64UrlEncodedString"])(config.publicKey?.challenge) : encodedChallenge,
                attestation
            };
        };
        this.createReactNativePasskey = async (config = {})=>{
            const { name, displayName, authenticatorName } = config;
            const { createPasskey } = PasskeyStamperModule; // We do a 'selective' import when initializing the stamper. This is safe to do here.
            if (!createPasskey) {
                throw new Error("Ensure you have @turnkey/react-native-passkey-stamper installed and linked correctly. Are you not on React Native?");
            }
            return await createPasskey({
                rp: {
                    id: this.config.rpId,
                    name: this.config.rpName ?? "Turnkey"
                },
                user: {
                    id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uuid$2f$dist$2f$esm$2d$browser$2f$v4$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__default__as__v4$3e$__["v4"])(),
                    name,
                    displayName
                },
                authenticatorName: authenticatorName ?? name ?? "End-User Passkey"
            });
        };
        // Use init method to set up the stamper based on the platform. It's async, so can't be done in the constructor.
        this.config = config;
    }
    async init() {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWeb"])()) {
            const { default: WindowWrapper } = await __turbopack_context__.A("[project]/node_modules/@turnkey/core/dist/__polyfills__/window.mjs [app-client] (ecmascript, async loader)");
            this.stamper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WebauthnStamper"]({
                ...this.config,
                rpId: this.config.rpId ?? WindowWrapper.location.hostname
            });
        } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isReactNative"])()) {
            try {
                // Dynamic import to prevent bundling the native module in web environments.
                let PasskeyStamper;
                try {
                    PasskeyStamperModule = (()=>{
                        const e = new Error("Cannot find module '@turnkey/react-native-passkey-stamper'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e;
                    })();
                    PasskeyStamper = PasskeyStamperModule.PasskeyStamper;
                } catch  {
                    throw new Error("Please install react-native-passkeys and @turnkey/react-native-passkey-stamper in your app to use passkeys.");
                }
                this.stamper = new PasskeyStamper({
                    ...this.config,
                    rpId: this.config.rpId,
                    allowCredentials: this.config.allowCredentials?.map((cred)=>({
                            id: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$encoding$2f$dist$2f$hex$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToHexString"])(cred.id),
                            type: cred.type,
                            transports: cred.transports
                        }))
                });
            } catch (error) {
                throw new Error(`Failed to load passkey stamper for react-native: ${error}`);
            }
        } else {
            throw new Error("Unsupported platform for passkey stamper");
        }
    }
    async stamp(payload) {
        return await this.stamper.stamp(payload);
    }
}
;
 //# sourceMappingURL=base.mjs.map
}),
"[project]/node_modules/@turnkey/core/dist/__wallet__/base.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createWalletManager",
    ()=>createWalletManager
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/utils.mjs [app-client] (ecmascript)");
;
/**
 * Creates and initializes a wallet manager instance based on the runtime environment.
 *
 * - If the environment is React Native, it creates and initializes a `MobileWalletManager`.
 * - If the environment is Web, it creates and initializes a `WebWalletManager`.
 * - Throws an error if the environment is neither supported.
 *
 * @param cfg - Configuration object used to initialize the wallet manager.
 * @returns A promise that resolves to an initialized `WalletManagerBase` instance.
 * @throws {Error} If the environment is not supported (neither React Native nor Web).
 */ async function createWalletManager(cfg) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isReactNative"])()) {
        const { MobileWalletManager } = await __turbopack_context__.A("[project]/node_modules/@turnkey/core/dist/__wallet__/mobile/manager.mjs [app-client] (ecmascript, async loader)");
        const manager = new MobileWalletManager(cfg);
        await manager.init(cfg);
        return manager;
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWeb"])()) {
        const { WebWalletManager } = await __turbopack_context__.A("[project]/node_modules/@turnkey/core/dist/__wallet__/web/manager.mjs [app-client] (ecmascript, async loader)");
        const manager = new WebWalletManager(cfg);
        await manager.init(cfg);
        return manager;
    } else {
        throw new Error("Unsupported environment for wallet manager");
    }
}
;
 //# sourceMappingURL=base.mjs.map
}),
"[project]/node_modules/@turnkey/core/dist/__clients__/core.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TurnkeyClient",
    ()=>TurnkeyClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$generated_$5f2f$sdk$2d$client$2d$base$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__generated__/sdk-client-base.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/sdk-types/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$auth$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__types__/auth.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__types__/enums.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/utils.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$storage_$5f2f$base$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__storage__/base.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$stampers_$5f2f$api$2f$base$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__stampers__/api/base.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$stampers_$5f2f$passkey$2f$base$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__stampers__/passkey/base.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/turnkey-helpers.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jwt$2d$decode$2f$build$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jwt-decode/build/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$wallet_$5f2f$base$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__wallet__/base.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/ethers/lib.esm/utils/utf8.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/dist/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$proof$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/crypto/dist/proof.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/api-key-stamper/dist/index.mjs [app-client] (ecmascript) <locals>");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
class TurnkeyClient {
    constructor(config, // Users can pass in their own stampers, or we will create them. Should we remove this?
    apiKeyStamper, passkeyStamper, walletManager){
        /**
         * Creates a new TurnkeySDKClientBase instance with the provided configuration.
         * This method is used internally to create the HTTP client for making API requests,
         * but can also be used to create an additional client with different configurations if needed.
         * By default, it uses the configuration provided during the TurnkeyClient initialization.
         *
         * @param params - Optional configuration parameters to override the default client configuration.
         * @param params.apiBaseUrl - The base URL of the Turnkey API (defaults to `https://api.turnkey.com` if not provided).
         * @param params.organizationId - The organization ID to associate requests with.
         * @param params.authProxyUrl - The base URL of the Auth Proxy (defaults to `https://authproxy.turnkey.com` if not provided).
         * @param params.authProxyConfigId - The configuration ID to use when making Auth Proxy requests.
         * @param params.defaultStamperType - The default stamper type to use for signing requests
         *   (overrides automatic detection of ApiKey, Passkey, or Wallet stampers).
         *
         * @returns A new instance of {@link TurnkeySDKClientBase} configured with the provided parameters.
         */ this.createHttpClient = (params)=>{
            // We can comfortably default to the prod urls here
            const apiBaseUrl = params?.apiBaseUrl || this.config.apiBaseUrl || "https://api.turnkey.com";
            const authProxyUrl = params?.authProxyUrl || this.config.authProxyUrl || "https://authproxy.turnkey.com";
            const organizationId = params?.organizationId || this.config.organizationId;
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$generated_$5f2f$sdk$2d$client$2d$base$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeySDKClientBase"]({
                ...this.config,
                ...params,
                apiBaseUrl,
                authProxyUrl,
                organizationId,
                apiKeyStamper: this.apiKeyStamper,
                passkeyStamper: this.passkeyStamper,
                walletStamper: this.walletManager?.stamper,
                storageManager: this.storageManager
            });
        };
        /**
         * Creates a new passkey authenticator for the user.
         *
         * - This function generates a new passkey attestation and challenge, suitable for registration with the user's device.
         * - Handles both web and React Native environments, automatically selecting the appropriate passkey creation flow.
         * - The resulting attestation and challenge can be used to register the passkey with Turnkey.
         *
         * @param params.name - display name for the passkey (defaults to a generated name based on the current timestamp).
         * @param params.challenge - challenge string to use for passkey registration. If not provided, a new challenge will be generated.
         * @returns A promise that resolves to {@link CreatePasskeyResult}
         * @throws {TurnkeyError} If there is an error during passkey creation, or if the platform is unsupported.
         */ this.createPasskey = async (params)=>{
            const { name: nameFromParams, challenge } = params || {};
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                if (!this.passkeyStamper) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Passkey stamper is not initialized", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INTERNAL_ERROR);
                }
                const name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidPasskeyName"])(nameFromParams || `passkey-${Date.now()}`);
                let passkey;
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWeb"])()) {
                    const res = await this.passkeyStamper.createWebPasskey({
                        publicKey: {
                            user: {
                                name,
                                displayName: name
                            },
                            ...challenge && {
                                challenge
                            }
                        }
                    });
                    if (!res) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to create Web passkey", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INTERNAL_ERROR);
                    }
                    passkey = {
                        encodedChallenge: res?.encodedChallenge,
                        attestation: res?.attestation
                    };
                } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isReactNative"])()) {
                    const res = await this.passkeyStamper.createReactNativePasskey({
                        name,
                        displayName: name
                    });
                    if (!res) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to create React Native passkey", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INTERNAL_ERROR);
                    }
                    passkey = {
                        encodedChallenge: res?.challenge,
                        attestation: res?.attestation
                    };
                } else {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Unsupported platform for passkey creation", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                }
                return passkey;
            }, {
                errorMessage: "Failed to create passkey",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CREATE_PASSKEY_ERROR,
                customErrorsByMessages: {
                    "timed out or was not allowed": {
                        message: "Passkey creation was cancelled by the user.",
                        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SELECT_PASSKEY_CANCELLED
                    }
                }
            });
        };
        /**
         * Logs out the current client session.
         *
         * - This function clears the specified session and removes any associated key pairs from storage.
         * - If a sessionKey is provided, it logs out from that session; otherwise, it logs out from the active session.
         * - Cleans up any api keys associated with the session.
         *
         * @param params.sessionKey - session key to specify which session to log out from (defaults to the active session).
         * @returns A promise that resolves when the logout process is complete.
         * @throws {TurnkeyError} If there is no active session or if there is an error during the logout process.
         */ this.logout = async (params)=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                if (params?.sessionKey) {
                    const session = await this.storageManager.getSession(params.sessionKey);
                    this.storageManager.clearSession(params.sessionKey);
                    this.apiKeyStamper?.deleteKeyPair(session?.publicKey);
                } else {
                    const sessionKey = await this.storageManager.getActiveSessionKey();
                    const session = await this.storageManager.getActiveSession();
                    if (sessionKey) {
                        this.storageManager.clearSession(sessionKey);
                        this.apiKeyStamper?.deleteKeyPair(session?.publicKey);
                    } else {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No active session found to log out from.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].NO_SESSION_FOUND);
                    }
                }
            }, {
                errorMessage: "Failed to log out",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].LOGOUT_ERROR
            });
        };
        /**
         * Logs in a user using a passkey, optionally specifying the public key, session key, and session expiration.
         *
         * - This function initiates the login process with a passkey and handles session creation and storage.
         * - If a public key is not provided, a new key pair will be generated for authentication.
         * - If a session key is not provided, the default session key will be used.
         * - The session expiration can be customized via the expirationSeconds parameter.
         * - Handles cleanup of unused key pairs if login fails.
         *
         * @param params.publicKey - public key to use for authentication. If not provided, a new key pair will be generated.
         * @param params.sessionKey - session key to use for session creation (defaults to the default session key).
         * @param params.expirationSeconds - session expiration time in seconds (defaults to the configured default).
         * @param params.organizationId - organization ID to target (defaults to the session's organization ID or the parent organization ID).
         * @returns A promise that resolves to a {@link PasskeyAuthResult}, which includes:
         *          - `sessionToken`: the signed JWT session token.
         *          - `credentialId`: an empty string.
         * @throws {TurnkeyError} If there is an error during the passkey login process or if the user cancels the passkey prompt.
         */ this.loginWithPasskey = async (params)=>{
            let generatedPublicKey = undefined;
            return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                generatedPublicKey = params?.publicKey || await this.apiKeyStamper?.createKeyPair();
                const sessionKey = params?.sessionKey || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SessionKey"].DefaultSessionkey;
                const expirationSeconds = params?.expirationSeconds || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$auth$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_SESSION_EXPIRATION_IN_SECONDS"];
                if (!generatedPublicKey) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("A publickey could not be found or generated.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INTERNAL_ERROR);
                }
                const sessionResponse = await this.httpClient.stampLogin({
                    publicKey: generatedPublicKey,
                    organizationId: params?.organizationId ?? this.config.organizationId,
                    expirationSeconds
                }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StamperType"].Passkey);
                await this.storeSession({
                    sessionToken: sessionResponse.session,
                    sessionKey
                });
                generatedPublicKey = undefined; // Key pair was successfully used, set to null to prevent cleanup
                return {
                    sessionToken: sessionResponse.session,
                    // TODO: can we return the credentialId here?
                    // from a quick glance this is going to be difficult
                    // for now we return an empty string
                    credentialId: ""
                };
            }, {
                errorMessage: "Unable to log in with the provided passkey",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].PASSKEY_LOGIN_AUTH_ERROR,
                customErrorsByMessages: {
                    "timed out or was not allowed": {
                        message: "Passkey login was cancelled by the user.",
                        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SELECT_PASSKEY_CANCELLED
                    }
                }
            }, {
                finallyFn: async ()=>{
                    if (generatedPublicKey) {
                        try {
                            await this.apiKeyStamper?.deleteKeyPair(generatedPublicKey);
                        } catch (cleanupError) {
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Failed to clean up generated key pair`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].KEY_PAIR_CLEANUP_ERROR, cleanupError);
                        }
                    }
                }
            });
        };
        /**
         * Signs up a user using a passkey, creating a new sub-organization and session.
         *
         * - This function creates a new passkey authenticator and uses it to register a new sub-organization for the user.
         * - Handles both passkey creation and sub-organization creation in a single flow.
         * - Optionally accepts additional sub-organization parameters, a custom session key, a custom passkey display name, and a custom session expiration.
         * - Automatically generates a new API key pair for authentication and session management.
         * - Stores the resulting session token and manages cleanup of unused key pairs.
         *
         * @param params.passkeyDisplayName - display name for the passkey (defaults to a generated name based on the current timestamp).
         * @param params.challenge - challenge string to use for passkey registration. If not provided, a new challenge will be generated.
         * @param params.expirationSeconds - session expiration time in seconds (defaults to the configured default).
         * @param params.createSubOrgParams - parameters for creating a sub-organization (e.g., authenticators, user metadata).
         * @param params.sessionKey - session key to use for storing the session (defaults to the default session key).
         * @param params.organizationId - organization ID to target (defaults to the session's organization ID or the parent organization ID).
         * @returns A promise that resolves to a {@link PasskeyAuthResult}, which includes:
         *          - `sessionToken`: the signed JWT session token.
         *          - `credentialId`: the credential ID associated with the passkey created.
         * @throws {TurnkeyError} If there is an error during passkey creation, sub-organization creation, or session storage.
         */ this.signUpWithPasskey = async (params)=>{
            const { passkeyDisplayName, challenge, expirationSeconds = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$auth$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_SESSION_EXPIRATION_IN_SECONDS"], createSubOrgParams, sessionKey = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SessionKey"].DefaultSessionkey, organizationId } = params || {};
            let generatedPublicKey = undefined;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                generatedPublicKey = await this.apiKeyStamper?.createKeyPair();
                const passkeyName = passkeyDisplayName || `passkey-${Date.now()}`;
                // A passkey will be created automatically when you call this function. The name is passed in
                const passkey = await this.createPasskey({
                    name: passkeyName,
                    ...challenge && {
                        challenge
                    }
                });
                if (!passkey) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to create passkey: encoded challenge or attestation is missing", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INTERNAL_ERROR);
                }
                const signUpBody = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["buildSignUpBody"])({
                    createSubOrgParams: {
                        ...createSubOrgParams,
                        authenticators: [
                            ...createSubOrgParams?.authenticators ?? [],
                            {
                                // Add our passkey that we made earlier.
                                authenticatorName: passkeyName,
                                challenge: passkey.encodedChallenge,
                                attestation: passkey.attestation
                            }
                        ],
                        apiKeys: [
                            {
                                apiKeyName: `passkey-auth-${generatedPublicKey}`,
                                publicKey: generatedPublicKey,
                                curveType: "API_KEY_CURVE_P256",
                                expirationSeconds: "60"
                            }
                        ]
                    }
                });
                const res = await this.httpClient.proxySignup(signUpBody);
                if (!res) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Sign up failed`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].PASSKEY_SIGNUP_AUTH_ERROR);
                }
                const newGeneratedKeyPair = await this.apiKeyStamper?.createKeyPair();
                this.apiKeyStamper?.setTemporaryPublicKey(generatedPublicKey);
                const sessionResponse = await this.httpClient.stampLogin({
                    publicKey: newGeneratedKeyPair,
                    organizationId: organizationId ?? this.config.organizationId,
                    expirationSeconds
                });
                await Promise.all([
                    this.apiKeyStamper?.deleteKeyPair(generatedPublicKey),
                    this.storeSession({
                        sessionToken: sessionResponse.session,
                        sessionKey
                    })
                ]);
                generatedPublicKey = undefined; // Key pair was successfully used, set to null to prevent cleanup
                return {
                    sessionToken: sessionResponse.session,
                    appProofs: res.appProofs,
                    credentialId: passkey.attestation.credentialId
                };
            }, {
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].PASSKEY_SIGNUP_AUTH_ERROR,
                errorMessage: "Failed to sign up with passkey"
            }, {
                finallyFn: async ()=>{
                    this.apiKeyStamper?.clearTemporaryPublicKey();
                    if (generatedPublicKey) {
                        try {
                            await this.apiKeyStamper?.deleteKeyPair(generatedPublicKey);
                        } catch (cleanupError) {
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Failed to clean up generated key pair`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].KEY_PAIR_CLEANUP_ERROR, cleanupError);
                        }
                    }
                }
            });
        };
        /**
         * Retrieves wallet providers from the initialized wallet manager.
         *
         * - Optionally filters providers by the specified blockchain chain.
         * - Throws an error if the wallet manager is not initialized.
         *
         * @param chain - optional blockchain chain to filter the returned providers.
         * @returns A promise that resolves to an array of wallet providers.
         * @throws {TurnkeyError} If the wallet manager is uninitialized or provider retrieval fails.
         */ this.fetchWalletProviders = async (chain)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                if (!this.walletManager) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Wallet manager is not initialized", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].WALLET_MANAGER_COMPONENT_NOT_INITIALIZED);
                }
                return await this.walletManager.getProviders(chain);
            }, {
                errorMessage: "Unable to get wallet providers",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].FETCH_WALLETS_ERROR
            });
        };
        /**
         * Connects the specified wallet account.
         *
         * - Requires the wallet manager and its connector to be initialized.
         *
         * @param walletProvider - wallet provider to connect.
         * @returns A promise that resolves with the connected wallet's address.
         * @throws {TurnkeyError} If the wallet manager is uninitialized or the connection fails.
         */ this.connectWalletAccount = async (walletProvider)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                if (!this.walletManager?.connector) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Wallet connector is not initialized", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].WALLET_MANAGER_COMPONENT_NOT_INITIALIZED);
                }
                return await this.walletManager.connector.connectWalletAccount(walletProvider);
            }, {
                errorMessage: "Unable to connect wallet account",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CONNECT_WALLET_ACCOUNT_ERROR,
                customErrorsByMessages: {
                    "WalletConnect: The connection request has expired. Please scan the QR code again.": {
                        message: "Your WalletConnect session expired. Please scan the QR code again.",
                        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].WALLET_CONNECT_EXPIRED
                    },
                    "User rejected the request": {
                        message: "Connect wallet was cancelled by the user.",
                        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CONNECT_WALLET_CANCELLED
                    }
                }
            });
        };
        /**
         * Disconnects the specified wallet account.
         *
         * - Requires the wallet manager and its connector to be initialized.
         *
         * @param walletProvider - wallet provider to disconnect.
         * @returns A promise that resolves once the wallet account is disconnected.
         * @throws {TurnkeyError} If the wallet manager is uninitialized or the disconnection fails.
         */ this.disconnectWalletAccount = async (walletProvider)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                if (!this.walletManager?.connector) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Wallet connector is not initialized", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].WALLET_MANAGER_COMPONENT_NOT_INITIALIZED);
                }
                await this.walletManager.connector.disconnectWalletAccount(walletProvider);
            }, {
                errorMessage: "Unable to disconnect wallet account",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].DISCONNECT_WALLET_ACCOUNT_ERROR
            });
        };
        /**
         * Switches the wallet provider associated with a given wallet account
         * to a different chain.
         *
         * - Requires the wallet manager and its connector to be initialized
         * - Only works for connected wallet accounts
         * - Looks up the provider for the given account address
         * - Does nothing if the provider is already on the desired chain.
         *
         * @param params.walletAccount - The wallet account whose provider should be switched.
         * @param params.chainOrId - The target chain, specified as a chain ID string or a SwitchableChain object.
         * @param params.walletProviders - Optional list of wallet providers to search; falls back to `fetchWalletProviders()` if omitted.
         * @returns A promise that resolves once the chain switch is complete.
         *
         * @throws {TurnkeyError} If the wallet manager is uninitialized, the provider is not connected, or the switch fails.
         */ this.switchWalletAccountChain = async (params)=>{
            const { walletAccount, chainOrId, walletProviders } = params;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                if (!this.walletManager?.connector) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Wallet connector is not initialized", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].WALLET_MANAGER_COMPONENT_NOT_INITIALIZED);
                }
                if (walletAccount.source === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WalletSource"].Embedded) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("You can only switch chains for connected wallet accounts", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].NOT_FOUND);
                }
                const providers = walletProviders ?? await this.fetchWalletProviders();
                const walletProvider = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["findWalletProviderFromAddress"])(walletAccount.address, providers);
                if (!walletProvider) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Wallet provider not found", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SWITCH_WALLET_CHAIN_ERROR);
                }
                // if the wallet provider is already on the desired chain, do nothing
                if (walletProvider.chainInfo.namespace === chainOrId) {
                    return;
                }
                await this.walletManager.connector.switchChain(walletProvider, chainOrId);
            }, {
                errorMessage: "Unable to switch wallet account chain",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SWITCH_WALLET_CHAIN_ERROR
            });
        };
        /**
         * Builds and signs a wallet login request without submitting it to Turnkey.
         *
         * - This function prepares a signed request for wallet authentication, which can later be used
         *   to log in or sign up a user with Turnkey.
         * - It initializes the wallet stamper, ensures a valid session public key (generating one if needed),
         *   and signs the login intent with the connected wallet.
         * - For Ethereum wallets, derives the public key from the stamped request header.
         * - For Solana wallets, retrieves the public key directly from the connected wallet.
         * - The signed request is not sent to Turnkey immediately; it is meant to be used in a subsequent flow
         *   (e.g., `loginOrSignupWithWallet`) where sub-organization existence is verified or created first.
         *
         * @param params.walletProvider - the wallet provider used for authentication and signing.
         * @param params.publicKey - optional pre-generated session public key (auto-generated if not provided).
         * @param params.expirationSeconds - optional session expiration time in seconds (defaults to the configured default).
         * @returns A promise resolving to an object containing:
         *          - `signedRequest`: the signed wallet login request.
         *          - `publicKey`: the public key associated with the signed request.
         * @throws {TurnkeyError} If the wallet stamper is not initialized, the signing process fails,
         *                        or the public key cannot be derived or generated.
         */ this.buildWalletLoginRequest = async (params)=>{
            const { walletProvider, publicKey: providedPublicKey } = params;
            const expirationSeconds = params.expirationSeconds || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$auth$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_SESSION_EXPIRATION_IN_SECONDS"];
            let generatedPublicKey = undefined;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                if (!this.walletManager?.stamper) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Wallet stamper is not initialized", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].WALLET_MANAGER_COMPONENT_NOT_INITIALIZED);
                }
                const futureSessionPublicKey = providedPublicKey ?? (generatedPublicKey = await this.apiKeyStamper?.createKeyPair());
                if (!futureSessionPublicKey) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to find or generate a public key for building the wallet login request", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].WALLET_BUILD_LOGIN_REQUEST_ERROR);
                }
                this.walletManager.stamper.setProvider(walletProvider.interfaceType, walletProvider);
                // here we sign the request with the wallet, but we don't send it to Turnkey yet
                // this is because we need to check if the subOrg exists first, and create one if it doesn't
                // once we have the subOrg for the publicKey, we then can send the request to Turnkey
                const signedRequest = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                    return this.httpClient.stampStampLogin({
                        publicKey: futureSessionPublicKey,
                        organizationId: this.config.organizationId,
                        expirationSeconds
                    }, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["StamperType"].Wallet);
                }, {
                    errorMessage: "Failed to create stamped request for wallet login",
                    errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].WALLET_BUILD_LOGIN_REQUEST_ERROR,
                    customErrorsByMessages: {
                        "WalletConnect: The connection request has expired. Please scan the QR code again.": {
                            message: "Your WalletConnect session expired. Please scan the QR code again.",
                            code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].WALLET_CONNECT_EXPIRED
                        },
                        "Failed to sign the message": {
                            message: "Wallet auth was cancelled by the user.",
                            code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CONNECT_WALLET_CANCELLED
                        }
                    }
                });
                if (!signedRequest) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to create stamped request for wallet login", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                // the wallet's public key is embedded in the stamp header by the wallet stamper
                // so we extract it from there
                const publicKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPublicKeyFromStampHeader"])(signedRequest.stamp.stampHeaderValue);
                return {
                    signedRequest,
                    publicKey
                };
            }, {
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].WALLET_BUILD_LOGIN_REQUEST_ERROR,
                errorMessage: "Failed to build wallet login request",
                catchFn: async ()=>{
                    if (generatedPublicKey) {
                        try {
                            await this.apiKeyStamper?.deleteKeyPair(generatedPublicKey);
                        } catch (cleanupError) {
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Failed to clean up generated key pair`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].KEY_PAIR_CLEANUP_ERROR, cleanupError);
                        }
                    }
                }
            });
        };
        /**
         * Logs in a user using the specified wallet provider.
         *
         * - This function logs in a user by authenticating with the provided wallet provider via a wallet-based signature.
         * - If a public key is not provided, a new one will be generated for authentication.
         * - Optionally accepts a custom session key and session expiration time.
         * - Stores the resulting session token under the specified session key, or the default session key if not provided.
         * - Throws an error if a public key cannot be found or generated, or if the login process fails.
         *
         * @param params.walletProvider - wallet provider to use for authentication.
         * @param params.publicKey - optional public key to associate with the session (generated if not provided).
         * @param params.sessionKey - optional key to store the session under (defaults to the default session key).
         * @param params.expirationSeconds - optional session expiration time in seconds (defaults to the configured default).
         * @param params.organizationId - organization ID to target (defaults to the session's organization ID or the parent organization ID).
         * @returns A promise that resolves to a {@link WalletAuthResult}, which includes:
         *          - `sessionToken`: the signed JWT session token.
         *          - `address`: the authenticated wallet address.
         * @throws {TurnkeyError} If the wallet stamper is uninitialized, a public key cannot be found or generated, or login fails.
         */ this.loginWithWallet = async (params)=>{
            const { walletProvider, sessionKey = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SessionKey"].DefaultSessionkey } = params;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const { signedRequest, publicKey } = await this.buildWalletLoginRequest(params);
                const sessionResponse = await this.httpClient.sendSignedRequest(signedRequest);
                const sessionToken = sessionResponse.session;
                if (!sessionToken) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Session token not found in the response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                await this.storeSession({
                    sessionToken: sessionResponse.session,
                    sessionKey
                });
                return {
                    sessionToken: sessionResponse.session,
                    address: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addressFromPublicKey"])(walletProvider.chainInfo.namespace, publicKey)
                };
            }, {
                errorMessage: "Unable to log in with the provided wallet",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].WALLET_LOGIN_AUTH_ERROR
            });
        };
        /**
         * Signs up a user using a wallet, creating a new sub-organization and session.
         *
         * - This function creates a new wallet authenticator and uses it to register a new sub-organization for the user.
         * - Handles both wallet authentication and sub-organization creation in a single flow.
         * - Optionally accepts additional sub-organization parameters, a custom session key, and a custom session expiration.
         * - Automatically generates additional API key pairs for authentication and session management.
         * - Stores the resulting session token under the specified session key, or the default session key if not provided, and manages cleanup of unused key pairs.
         *
         * @param params.walletProvider - wallet provider to use for authentication.
         * @param params.createSubOrgParams - parameters for creating a sub-organization (e.g., authenticators, user metadata).
         * @param params.sessionKey - session key to use for storing the session (defaults to the default session key).
         * @param params.expirationSeconds - session expiration time in seconds (defaults to the configured default).
         * @param params.organizationId - organization ID to target (defaults to the session's organization ID or the parent organization ID).
         * @returns A promise that resolves to a {@link WalletAuthResult}, which includes:
         *          - `sessionToken`: the signed JWT session token.
         *          - `address`: the authenticated wallet address.
         * @throws {TurnkeyError} If there is an error during wallet authentication, sub-organization creation, session storage, or cleanup.
         */ this.signUpWithWallet = async (params)=>{
            const { walletProvider, createSubOrgParams, sessionKey = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SessionKey"].DefaultSessionkey } = params;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const { signedRequest, publicKey } = await this.buildWalletLoginRequest(params);
                const signUpBody = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["buildSignUpBody"])({
                    createSubOrgParams: {
                        ...createSubOrgParams,
                        apiKeys: [
                            {
                                apiKeyName: `wallet-auth:${publicKey}`,
                                publicKey: publicKey,
                                curveType: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCurveTypeFromProvider"])(walletProvider)
                            }
                        ]
                    }
                });
                const res = await this.httpClient.proxySignup(signUpBody);
                if (!res) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Sign up failed`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].WALLET_SIGNUP_AUTH_ERROR);
                }
                // now we can send the stamped request to Turnkey
                const sessionResponse = await this.httpClient.sendSignedRequest(signedRequest);
                const sessionToken = sessionResponse.session;
                if (!sessionToken) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Session token not found in the response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                await this.storeSession({
                    sessionToken: sessionToken,
                    sessionKey
                });
                return {
                    sessionToken: sessionToken,
                    appProofs: res.appProofs,
                    address: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addressFromPublicKey"])(walletProvider.chainInfo.namespace, publicKey)
                };
            }, {
                errorMessage: "Failed to sign up with wallet",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].WALLET_SIGNUP_AUTH_ERROR
            });
        };
        /**
         * Logs in an existing user or signs up a new user using a wallet, creating a new sub-organization if needed.
         *
         * - This function attempts to log in the user by stamping a login request with the provided wallet.
         * - If the wallets public key is not associated with an existing sub-organization, a new one is created.
         * - Handles both wallet authentication and sub-organization creation in a single flow.
         * - For Ethereum wallets, derives the public key from the signed request header; for Solana wallets, retrieves it directly from the wallet.
         * - Optionally accepts additional sub-organization parameters, a custom session key, and a custom session expiration.
         * - Stores the resulting session token under the specified session key, or the default session key if not provided.
         *
         * @param params.walletProvider - wallet provider to use for authentication.
         * @param params.publicKey - optional public key to associate with the session (generated if not provided).
         * @param params.createSubOrgParams - optional parameters for creating a sub-organization (e.g., authenticators, user metadata).
         * @param params.sessionKey - session key to use for storing the session (defaults to the default session key).
         * @param params.expirationSeconds - session expiration time in seconds (defaults to the configured default).
         * @param params.organizationId - organization ID to target (defaults to the session's organization ID or the parent organization ID).
         * @returns A promise that resolves to an object containing:
         *          - `sessionToken`: the signed JWT session token.
         *          - `address`: the authenticated wallet address.
         *          - `action`: whether the flow resulted in a login or signup ({@link AuthAction}).
         * @throws {TurnkeyError} If there is an error during wallet authentication, sub-organization creation, or session storage.
         */ this.loginOrSignupWithWallet = async (params)=>{
            const { walletProvider, createSubOrgParams, sessionKey = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SessionKey"].DefaultSessionkey } = params;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const { signedRequest, publicKey } = await this.buildWalletLoginRequest(params);
                // here we check if the subOrg exists and create one
                // then we send off the stamped request to Turnkey
                const accountRes = await this.httpClient.proxyGetAccount({
                    filterType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FilterType"].PublicKey,
                    filterValue: publicKey
                });
                if (!accountRes) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Account fetch failed`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].ACCOUNT_FETCH_ERROR);
                }
                const subOrganizationId = accountRes.organizationId;
                // if there is no subOrganizationId, we create one
                let signupRes;
                if (!subOrganizationId) {
                    const signUpBody = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["buildSignUpBody"])({
                        createSubOrgParams: {
                            ...createSubOrgParams,
                            apiKeys: [
                                {
                                    apiKeyName: `wallet-auth:${publicKey}`,
                                    publicKey: publicKey,
                                    curveType: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getCurveTypeFromProvider"])(walletProvider)
                                }
                            ]
                        }
                    });
                    signupRes = await this.httpClient.proxySignup(signUpBody);
                    if (!signupRes) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Sign up failed`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].WALLET_SIGNUP_AUTH_ERROR);
                    }
                }
                // now we can send the stamped request to Turnkey
                const sessionResponse = await this.httpClient.sendSignedRequest(signedRequest);
                const sessionToken = sessionResponse.session;
                if (!sessionToken) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Session token not found in the response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                await this.storeSession({
                    sessionToken: sessionToken,
                    sessionKey
                });
                return {
                    sessionToken: sessionToken,
                    appProofs: signupRes?.appProofs,
                    address: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addressFromPublicKey"])(walletProvider.chainInfo.namespace, publicKey),
                    // if the subOrganizationId exists, it means the user is logging in
                    action: subOrganizationId ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AuthAction"].LOGIN : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AuthAction"].SIGNUP
                };
            }, {
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].WALLET_LOGIN_OR_SIGNUP_ERROR,
                errorMessage: "Failed to log in or sign up with wallet"
            });
        };
        /**
         * Initializes the OTP process by sending an OTP code to the provided contact.
         *
         * - This function initiates the OTP flow by sending a one-time password (OTP) code to the user's contact information (email address or phone number) via the auth proxy.
         * - Supports both email and SMS OTP types.
         * - Returns an OTP ID that is required for subsequent OTP verification.
         *
         * @param params.otpType - type of OTP to initialize (OtpType.Email or OtpType.Sms).
         * @param params.contact - contact information for the user (e.g., email address or phone number).
         * @param params.organizationId - optional organization ID to target (defaults to the session's organization ID or the parent organization ID).
         * @returns A promise that resolves to the OTP ID required for verification.
         * @throws {TurnkeyError} If there is an error during the OTP initialization process or if the maximum number of OTPs has been reached.
         */ this.initOtp = async (params)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const initOtpRes = await this.httpClient.proxyInitOtp(params);
                if (!initOtpRes || !initOtpRes.otpId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to initialize OTP: otpId is missing", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INIT_OTP_ERROR);
                }
                return initOtpRes.otpId;
            }, {
                errorMessage: "Failed to initialize OTP",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INIT_OTP_ERROR,
                customErrorsByMessages: {
                    "Max number of OTPs have been initiated": {
                        message: "Maximum number of OTPs has been reached for this contact.",
                        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].MAX_OTP_INITIATED_ERROR
                    }
                }
            });
        };
        /**
         * Verifies the OTP code sent to the user.
         *
         * - This function verifies the OTP code entered by the user against the OTP sent to their contact information (email or phone) using the auth proxy.
         * - If verification is successful, it returns the sub-organization ID associated with the contact (if it exists) and a verification token.
         * - The verification token can be used for subsequent login or sign-up flows.
         * - Handles both email and SMS OTP types.
         *
         * @param params.otpId - ID of the OTP to verify (returned from `initOtp`).
         * @param params.otpCode - OTP code entered by the user.
         * @param params.contact - contact information for the user (e.g., email address or phone number).
         * @param params.otpType - type of OTP being verified (OtpType.Email or OtpType.Sms).
         * @param params.publicKey - public key the verification token is bound to for ownership verification (client signature verification during login/signup). This public key is optional; if not provided, a new key pair will be generated.
         * @returns A promise that resolves to an object containing:
         *   - subOrganizationId: sub-organization ID if the contact is already associated with a sub-organization, or an empty string if not.
         *   - verificationToken: verification token to be used for login or sign-up.
         * @throws {TurnkeyError} If there is an error during the OTP verification process, such as an invalid code or network failure.
         */ this.verifyOtp = async (params)=>{
            const { otpId, otpCode, contact, otpType } = params;
            const resolvedPublicKey = params.publicKey ?? await this.apiKeyStamper?.createKeyPair();
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const verifyOtpRes = await this.httpClient.proxyVerifyOtp({
                    otpId: otpId,
                    otpCode: otpCode,
                    publicKey: resolvedPublicKey
                });
                if (!verifyOtpRes) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`OTP verification failed`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INTERNAL_ERROR);
                }
                const accountRes = await this.httpClient.proxyGetAccount({
                    filterType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OtpTypeToFilterTypeMap"][otpType],
                    filterValue: contact,
                    verificationToken: verifyOtpRes.verificationToken
                });
                if (!accountRes) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Account fetch failed`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].ACCOUNT_FETCH_ERROR);
                }
                const subOrganizationId = accountRes.organizationId;
                return {
                    subOrganizationId: subOrganizationId,
                    verificationToken: verifyOtpRes.verificationToken
                };
            }, {
                errorMessage: "Failed to verify OTP",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].VERIFY_OTP_ERROR,
                customErrorsByMessages: {
                    "Invalid OTP code": {
                        message: "The provided OTP code is invalid.",
                        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_OTP_CODE
                    }
                }
            });
        };
        /**
         * Logs in a user using an OTP verification token.
         *
         * - This function logs in a user using the verification token received after OTP verification (from email or SMS).
         * - If a public key is not provided, a new API key pair will be generated for authentication.
         * - Optionally invalidates any existing sessions for the user if `invalidateExisting` is set to true.
         * - Stores the resulting session token under the specified session key, or the default session key if not provided.
         * - Handles cleanup of unused key pairs if login fails.
         *
         * @param params.verificationToken - verification token received after OTP verification.
         * @param params.publicKey - public key to use for authentication. If not provided, a new key pair will be generated.
         * @param params.organizationId - optional organization ID to target (defaults to the verified subOrg ID linked to the verification token contact).
         * @param params.invalidateExisting - flag to invalidate existing session for the user.
         * @param params.sessionKey - session key to use for session creation (defaults to the default session key).
         * @returns A promise that resolves to a {@link BaseAuthResult}, which includes:
         *          - `sessionToken`: the signed JWT session token.
         * @throws {TurnkeyError} If there is an error during the OTP login process or if key pair cleanup fails.
         */ this.loginWithOtp = async (params)=>{
            const { verificationToken, invalidateExisting = false, publicKey = await this.apiKeyStamper?.createKeyPair(), organizationId, sessionKey = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SessionKey"].DefaultSessionkey } = params;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const { message, publicKey: clientSignaturePublicKey } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getClientSignatureMessageForLogin"])({
                    verificationToken,
                    sessionPublicKey: publicKey
                });
                this.apiKeyStamper?.setTemporaryPublicKey(publicKey);
                const signature = await this.apiKeyStamper?.sign(message, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["SignatureFormat"].Raw);
                if (!signature) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Failed to sign client signature for OTP login`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INTERNAL_ERROR);
                }
                const clientSignature = {
                    message: message,
                    publicKey: clientSignaturePublicKey,
                    scheme: "CLIENT_SIGNATURE_SCHEME_API_P256",
                    signature: signature
                };
                const res = await this.httpClient.proxyOtpLogin({
                    verificationToken,
                    publicKey: publicKey,
                    invalidateExisting,
                    clientSignature,
                    ...organizationId && {
                        organizationId
                    }
                });
                if (!res) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Auth proxy OTP login failed`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].OTP_LOGIN_ERROR);
                }
                const loginRes = await res;
                if (!loginRes.session) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No session returned from OTP login", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].OTP_LOGIN_ERROR);
                }
                await this.storeSession({
                    sessionToken: loginRes.session,
                    sessionKey
                });
                return {
                    sessionToken: loginRes.session
                };
            }, {
                errorMessage: "Failed to log in with OTP",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].OTP_LOGIN_ERROR,
                catchFn: async ()=>{
                    // Clean up the generated key pair if it wasn't successfully used
                    if (publicKey) {
                        try {
                            await this.apiKeyStamper?.deleteKeyPair(publicKey);
                        } catch (cleanupError) {
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Failed to clean up generated key pair`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].KEY_PAIR_CLEANUP_ERROR, cleanupError);
                        }
                    }
                }
            }, {
                finallyFn: async ()=>{
                    this.apiKeyStamper?.clearTemporaryPublicKey();
                }
            });
        };
        /**
         * Signs up a user using an OTP verification token.
         *
         * - This function signs up a user using the verification token received after OTP verification (from email or SMS).
         * - Creates a new sub-organization for the user with the provided parameters and associates the contact (email or phone) with the sub-organization.
         * - Automatically generates a new API key pair for authentication and session management.
         * - Stores the resulting session token under the specified session key, or the default session key if not provided.
         * - Handles both email and SMS OTP types, and supports additional sub-organization creation parameters.
         *
         * @param params.verificationToken - verification token received after OTP verification.
         * @param params.contact - contact information for the user (e.g., email address or phone number).
         * @param params.otpType - type of OTP being used (OtpType.Email or OtpType.Sms).
         * @param params.createSubOrgParams - parameters for creating a sub-organization (e.g., authenticators, user metadata).
         * @param params.invalidateExisting - flag to invalidate existing session for the user.
         * @param params.sessionKey - session key to use for session creation (defaults to the default session key).
         * @returns A promise that resolves to a {@link BaseAuthResult}, which includes:
         *          - `sessionToken`: the signed JWT session token.
         * @throws {TurnkeyError} If there is an error during the OTP sign-up process or session storage.
         */ this.signUpWithOtp = async (params)=>{
            const { verificationToken, contact, otpType, createSubOrgParams, invalidateExisting, sessionKey, publicKey = await this.apiKeyStamper?.createKeyPair() } = params;
            // build sign up body without client signature first
            const signUpBody = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["buildSignUpBody"])({
                createSubOrgParams: {
                    ...createSubOrgParams,
                    ...otpType === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OtpType"].Email ? {
                        userEmail: contact
                    } : {
                        userPhoneNumber: contact
                    },
                    verificationToken
                }
            });
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const { message, publicKey: clientSignaturePublicKey } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getClientSignatureMessageForSignup"])({
                    verificationToken,
                    ...signUpBody.userEmail && {
                        email: signUpBody.userEmail
                    },
                    ...signUpBody.userPhoneNumber && {
                        phoneNumber: signUpBody.userPhoneNumber
                    },
                    apiKeys: signUpBody.apiKeys,
                    authenticators: signUpBody.authenticators,
                    oauthProviders: signUpBody.oauthProviders
                });
                this.apiKeyStamper?.setTemporaryPublicKey(publicKey);
                const signature = await this.apiKeyStamper?.sign(message, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["SignatureFormat"].Raw);
                if (!signature) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Failed to sign client signature for OTP sign up`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INTERNAL_ERROR);
                }
                const clientSignature = {
                    message: message,
                    publicKey: clientSignaturePublicKey,
                    scheme: "CLIENT_SIGNATURE_SCHEME_API_P256",
                    signature: signature
                };
                const signupRes = await this.httpClient.proxySignup({
                    ...signUpBody,
                    clientSignature
                });
                if (!signupRes) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Auth proxy OTP sign up failed`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].OTP_SIGNUP_ERROR);
                }
                const otpRes = await this.loginWithOtp({
                    verificationToken,
                    publicKey: publicKey,
                    ...invalidateExisting && {
                        invalidateExisting
                    },
                    ...sessionKey && {
                        sessionKey
                    }
                });
                return {
                    ...otpRes,
                    appProofs: signupRes.appProofs
                };
            }, {
                catchFn: async ()=>{
                    // Clean up the generated key pair if it wasn't successfully used
                    if (publicKey) {
                        try {
                            await this.apiKeyStamper?.deleteKeyPair(publicKey);
                        } catch (cleanupError) {
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Failed to clean up generated key pair`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].KEY_PAIR_CLEANUP_ERROR, cleanupError);
                        }
                    }
                },
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].OTP_SIGNUP_ERROR,
                errorMessage: "Failed to sign up with OTP"
            }, {
                finallyFn: async ()=>{
                    this.apiKeyStamper?.clearTemporaryPublicKey();
                }
            });
        };
        /**
         * Completes the OTP authentication flow by verifying the OTP code and then either signing up or logging in the user.
         *
         * - This function first verifies the OTP code for the provided contact and OTP type.
         * - If the contact is not associated with an existing sub-organization, it will automatically create a new sub-organization and complete the sign-up flow.
         * - If the contact is already associated with a sub-organization, it will complete the login flow.
         * - Supports passing a custom public key for authentication, invalidating existing session, specifying a session key, and providing additional sub-organization creation parameters.
         * - Handles both email and SMS OTP types.
         *
         * @param params.otpId - ID of the OTP to complete (returned from `initOtp`).
         * @param params.otpCode - OTP code entered by the user.
         * @param params.contact - contact information for the user (e.g., email address or phone number).
         * @param params.otpType - type of OTP being completed (OtpType.Email or OtpType.Sms).
         * @param params.publicKey - public key to use for authentication. If not provided, a new key pair may be generated.
         * @param params.invalidateExisting - flag to invalidate existing sessions for the user.
         * @param params.sessionKey - session key to use for session creation (defaults to the default session key).
         * @param params.createSubOrgParams - parameters for sub-organization creation (e.g., authenticators, user metadata).
         * @returns A promise that resolves to an object containing:
         *          - `sessionToken`: the signed JWT session token.
         *          - `verificationToken`: the OTP verification token.
         *          - `action`: whether the flow resulted in a login or signup ({@link AuthAction}).
         * @throws {TurnkeyError} If there is an error during OTP verification, sign-up, or login.
         */ this.completeOtp = async (params)=>{
            const { otpId, otpCode, contact, otpType, publicKey = await this.apiKeyStamper?.createKeyPair(), invalidateExisting = false, sessionKey, createSubOrgParams } = params;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const { subOrganizationId, verificationToken } = await this.verifyOtp({
                    otpId: otpId,
                    otpCode: otpCode,
                    contact: contact,
                    otpType: otpType,
                    publicKey: publicKey
                });
                if (!verificationToken) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No verification token returned from OTP verification", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].VERIFY_OTP_ERROR);
                }
                if (!subOrganizationId) {
                    const signUpRes = await this.signUpWithOtp({
                        verificationToken,
                        contact,
                        otpType,
                        ...createSubOrgParams && {
                            createSubOrgParams
                        },
                        ...invalidateExisting && {
                            invalidateExisting
                        },
                        ...sessionKey && {
                            sessionKey
                        },
                        publicKey: publicKey
                    });
                    return {
                        ...signUpRes,
                        verificationToken,
                        action: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AuthAction"].SIGNUP
                    };
                } else {
                    const loginRes = await this.loginWithOtp({
                        verificationToken,
                        publicKey: publicKey,
                        ...invalidateExisting && {
                            invalidateExisting
                        },
                        ...sessionKey && {
                            sessionKey
                        }
                    });
                    return {
                        ...loginRes,
                        verificationToken,
                        action: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AuthAction"].LOGIN
                    };
                }
            }, {
                errorMessage: "Failed to complete OTP process",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].OTP_COMPLETION_ERROR
            });
        };
        /**
         * Completes the OAuth authentication flow by either signing up or logging in the user, depending on whether a sub-organization already exists for the provided OIDC token.
         *
         * - This function first checks if there is an existing sub-organization associated with the OIDC token.
         * - If a sub-organization exists, it proceeds with the OAuth login flow.
         * - If no sub-organization exists, it creates a new sub-organization and completes the sign-up flow.
         * - Optionally accepts a custom OAuth provider name, session key, and additional sub-organization creation parameters.
         * - Handles session storage and management, and supports invalidating existing sessions if specified.
         *
         * @param params.oidcToken - OIDC token received after successful authentication with the OAuth provider.
         * @param params.publicKey - public key to use for authentication. Must be generated prior to calling this function, this is because the OIDC nonce has to be set to `sha256(publicKey)`.
         * @param params.providerName - name of the OAuth provider (defaults to a generated name with a timestamp).
         * @param params.createSubOrgParams - parameters for sub-organization creation (e.g., authenticators, user metadata).
         * @param params.invalidateExisting - flag to invalidate existing sessions for the user.
         * @param params.sessionKey - session key to use for session creation (defaults to the default session key).
         *
         * @returns A promise that resolves to an object containing:
         *          - `sessionToken`: the signed JWT session token.
         *          - `action`: whether the flow resulted in a login or signup ({@link AuthAction}).
         * @throws {TurnkeyError} If there is an error during the OAuth completion process, such as account lookup, sign-up, or login.
         */ this.completeOauth = async (params)=>{
            const { oidcToken, publicKey, providerName, createSubOrgParams, invalidateExisting, sessionKey } = params;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const accountRes = await this.httpClient.proxyGetAccount({
                    filterType: "OIDC_TOKEN",
                    filterValue: oidcToken
                });
                if (!accountRes) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Account fetch failed`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].ACCOUNT_FETCH_ERROR);
                }
                const subOrganizationId = accountRes.organizationId;
                if (subOrganizationId) {
                    const loginRes = await this.loginWithOauth({
                        oidcToken,
                        publicKey,
                        ...invalidateExisting && {
                            invalidateExisting
                        },
                        ...sessionKey && {
                            sessionKey
                        }
                    });
                    return {
                        ...loginRes,
                        action: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AuthAction"].LOGIN
                    };
                } else {
                    const signUpRes = await this.signUpWithOauth({
                        oidcToken,
                        publicKey,
                        ...providerName && {
                            providerName
                        },
                        ...createSubOrgParams && {
                            createSubOrgParams
                        },
                        ...invalidateExisting && {
                            invalidateExisting
                        },
                        ...sessionKey && {
                            sessionKey
                        }
                    });
                    return {
                        ...signUpRes,
                        action: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AuthAction"].SIGNUP
                    };
                }
            }, {
                errorMessage: "Failed to complete OAuth process",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].OAUTH_LOGIN_ERROR
            });
        };
        /**
         * Logs in a user using OAuth authentication.
         *
         * - This function logs in a user using the provided OIDC token and public key.
         * - Optionally invalidates any existing sessions for the user if `invalidateExisting` is set to true.
         * - Stores the resulting session token under the specified session key, or the default session key if not provided.
         * - Handles cleanup of unused key pairs if login fails.
         *
         * @param params.oidcToken - OIDC token received after successful authentication with the OAuth provider.
         * @param params.publicKey - The public key bound to the login session. This key is required because it is directly
         *                           tied to the nonce used during OIDC token generation and must match the value
         *                           encoded in the token.
         * @param params.organizationId - ID of the organization to target when creating the session.
         * @param params.invalidateExisting - flag to invalidate existing sessions for the user.
         * @param params.sessionKey - session key to use for session creation (defaults to the default session key).
         * @returns A promise that resolves to a {@link BaseAuthResult}, which includes:
         *          - `sessionToken`: the signed JWT session token.
         * @throws {TurnkeyError} If there is an error during the OAuth login process or if key pair cleanup fails.
         */ this.loginWithOauth = async (params)=>{
            const { oidcToken, publicKey, organizationId, invalidateExisting = false, sessionKey = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SessionKey"].DefaultSessionkey } = params;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                if (!publicKey) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Public key must be provided to log in with OAuth. Please create a key pair first.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].MISSING_PARAMS);
                }
                const loginRes = await this.httpClient.proxyOAuthLogin({
                    oidcToken,
                    publicKey,
                    invalidateExisting,
                    ...organizationId && {
                        organizationId
                    }
                });
                if (!loginRes) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Auth proxy OAuth login failed`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].OAUTH_LOGIN_ERROR);
                }
                if (!loginRes.session) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No session returned from oauth login", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].OAUTH_LOGIN_ERROR);
                }
                await this.storeSession({
                    sessionToken: loginRes.session,
                    sessionKey
                });
                return {
                    sessionToken: loginRes.session
                };
            }, {
                errorMessage: "Failed to complete OAuth login",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].OAUTH_LOGIN_ERROR,
                customErrorsByMessages: {
                    "OAUTH disallowed": {
                        message: "OAuth is disabled on the dashboard for this organization.",
                        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].AUTH_METHOD_NOT_ENABLED
                    }
                },
                catchFn: async ()=>{
                    // Clean up the generated key pair if it wasn't successfully used
                    if (publicKey) {
                        try {
                            await this.apiKeyStamper?.deleteKeyPair(publicKey);
                        } catch (cleanupError) {
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Failed to clean up generated key pair`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].KEY_PAIR_CLEANUP_ERROR, cleanupError);
                        }
                    }
                }
            });
        };
        /**
         * Signs up a user using OAuth authentication.
         *
         * - This function creates a new sub-organization for the user using the provided OIDC token, public key, and provider name.
         * - Handles the full OAuth sign-up flow, including sub-organization creation and session management.
         * - Optionally accepts additional sub-organization creation parameters and a custom session key.
         * - After successful sign-up, automatically logs in the user and returns a signed JWT session token.
         *
         * @param params.oidcToken - OIDC token received after successful authentication with the OAuth provider.
         * @param params.publicKey - public key to associate with the new sub-organization.
         * @param params.providerName - name of the OAuth provider (e.g., "Google", "Apple").
         * @param params.createSubOrgParams - parameters for sub-organization creation (e.g., authenticators, user metadata).
         * @param params.sessionKey - session key to use for session creation (defaults to the default session key).
         * @returns A promise that resolves to a {@link BaseAuthResult}, which includes:
         *          - `sessionToken`: the signed JWT session token.
         * @throws {TurnkeyError} If there is an error during the OAuth sign-up or login process.
         */ this.signUpWithOauth = async (params)=>{
            const { oidcToken, publicKey, providerName = "OpenID Connect Provider" + " " + Date.now(), createSubOrgParams, sessionKey } = params;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const signUpBody = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["buildSignUpBody"])({
                    createSubOrgParams: {
                        ...createSubOrgParams,
                        oauthProviders: [
                            {
                                providerName,
                                oidcToken
                            }
                        ]
                    }
                });
                const signupRes = await this.httpClient.proxySignup(signUpBody);
                if (!signupRes) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Auth proxy OAuth signup failed`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].OAUTH_SIGNUP_ERROR);
                }
                const oauthRes = await this.loginWithOauth({
                    oidcToken,
                    publicKey: publicKey,
                    ...sessionKey && {
                        sessionKey
                    }
                });
                return {
                    ...oauthRes,
                    appProofs: signupRes.appProofs
                };
            }, {
                errorMessage: "Failed to sign up with OAuth",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].OAUTH_SIGNUP_ERROR
            });
        };
        /**
         * Fetches all wallets for the current user, including both embedded and connected wallets.
         *
         * - Retrieves all wallets associated with the organizationId from the current active session.
         * - For each embedded wallet, automatically fetches and attaches all associated wallet accounts.
         * - For connected wallets (e.g., browser extensions or external providers), groups providers by wallet name and attaches all connected accounts.
         * - Returns both embedded and connected wallets in a single array, each with their respective accounts populated.
         * - Optionally allows stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         *
         * @param params.walletProviders - array of wallet providers to use for fetching wallets.
         * @param params.organizationId - organization ID to target (defaults to the session's organization ID).
         * @param params.userId - user ID to target (defaults to the session's user ID).
         * @param params.connectedOnly - if true, fetches only connected wallets; if false or undefined, fetches both embedded and connected wallets.
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @returns A promise that resolves to an array of `Wallet` objects.
         * @throws {TurnkeyError} If no active session is found or if there is an error fetching wallets.
         */ this.fetchWallets = async (params)=>{
            const { walletProviders, organizationId: organizationIdFromParams, userId: userIdFromParams, connectedOnly, stampWith = this.config.defaultStamperType } = params || {};
            const session = await this.storageManager.getActiveSession();
            if (!session && !connectedOnly) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No active session found. Fetching embedded wallets requires a valid session. If you only need connected wallets, set the 'connectedOnly' parameter to true.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].NO_SESSION_FOUND);
            }
            // if `connectedOnly` is true, we need to make sure the walletManager is initialized
            // or else we can't fetch connected wallets, and we throw an error
            if (connectedOnly && !this.walletManager?.connector) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Wallet connector is not initialized", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].WALLET_MANAGER_COMPONENT_NOT_INITIALIZED);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                let embedded = [];
                const organizationId = organizationIdFromParams || session?.organizationId;
                const userId = userIdFromParams || session?.userId;
                // we start fetching user early if we have the required params (needed for connected wallets)
                // this runs in parallel with the embedded wallet fetching below
                let userPromise;
                if (organizationId && userId && this.walletManager?.connector) {
                    const signedUserRequest = await this.httpClient.stampGetUser({
                        userId,
                        organizationId
                    }, stampWith);
                    if (!signedUserRequest) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to stamp user request", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                    }
                    userPromise = this.httpClient.sendSignedRequest(signedUserRequest).then((response)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAuthenticatorAddresses"])(response.user));
                }
                // if connectedOnly is true, we skip fetching embedded wallets
                if (!connectedOnly) {
                    if (!organizationId) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No organization ID provided and no active session found. Please log in first or pass in an organization ID.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                    }
                    if (!userId) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No user ID provided and no active session found. Please log in first or pass in a user ID.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                    }
                    // we stamp the wallet request first
                    // this is done to avoid concurrent passkey prompts
                    const signedWalletsRequest = await this.httpClient.stampGetWallets({
                        organizationId
                    }, stampWith);
                    if (!signedWalletsRequest) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to stamp wallet request", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                    }
                    const [accounts, walletsRes] = await Promise.all([
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fetchAllWalletAccountsWithCursor"])(this.httpClient, organizationId, stampWith),
                        this.httpClient.sendSignedRequest(signedWalletsRequest)
                    ]);
                    // create a map of walletId to EmbeddedWallet for easy lookup
                    const walletMap = new Map(walletsRes.wallets.map((wallet)=>[
                            wallet.walletId,
                            {
                                ...wallet,
                                source: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WalletSource"].Embedded,
                                accounts: []
                            }
                        ]));
                    // map the accounts to their respective wallets
                    embedded = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mapAccountsToWallet"])(accounts, walletMap);
                }
                // if wallet connecting is disabled we return only embedded wallets
                // this will never be hit if `connectedOnly` is true because of the check above
                if (!this.walletManager?.connector) return embedded;
                const providers = walletProviders ?? await this.fetchWalletProviders();
                const groupedProviders = new Map();
                for (const provider of providers){
                    // connected wallets don't all have some uuid we can use for the walletId
                    // so what we do is we use a normalized version of the name for the wallet, like "metamask" or "phantom-wallet"
                    const walletId = provider.info?.name?.toLowerCase().replace(/\s+/g, "-") || "unknown";
                    const group = groupedProviders.get(walletId) || [];
                    group.push(provider);
                    groupedProviders.set(walletId, group);
                }
                // we fetch user once for all connected wallets to avoid duplicate `fetchUser` calls
                // this is only done if we have `organizationId` and `userId`
                // Note: this was started earlier in parallel with embedded wallet fetching for performance
                let authenticatorAddresses;
                if (userPromise) {
                    authenticatorAddresses = await userPromise;
                }
                // has to be done in a for of loop so we can await each fetchWalletAccounts call individually
                // otherwise await Promise.all would cause them all to fire at once breaking passkey only set ups
                // (multiple wallet fetches at once causing "OperationError: A request is already pending.")
                let connected = [];
                for (const [walletId, grouped] of groupedProviders.entries()){
                    const timestamp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toExternalTimestamp"])();
                    const wallet = {
                        source: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WalletSource"].Connected,
                        walletId,
                        walletName: grouped[0]?.info?.name ?? "Unknown",
                        createdAt: timestamp,
                        updatedAt: timestamp,
                        exported: false,
                        imported: false,
                        accounts: []
                    };
                    const accounts = await this.fetchWalletAccounts({
                        wallet,
                        walletProviders: grouped,
                        ...stampWith !== undefined && {
                            stampWith
                        },
                        ...organizationIdFromParams !== undefined && {
                            organizationId: organizationIdFromParams
                        },
                        ...userIdFromParams !== undefined && {
                            userId: userIdFromParams
                        },
                        ...authenticatorAddresses && {
                            authenticatorAddresses
                        }
                    });
                    wallet.accounts = accounts;
                    if (wallet.accounts.length > 0) {
                        connected.push(wallet);
                    }
                }
                return [
                    ...embedded,
                    ...connected
                ];
            }, {
                errorMessage: "Failed to fetch wallets",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].FETCH_WALLETS_ERROR
            });
        };
        /**
         * Fetches all accounts for a specific wallet, including both embedded and connected wallet accounts.
         *
         * - For embedded wallets, retrieves accounts from the Turnkey API, supporting pagination (defaults to the first page with a limit of 100 accounts).
         * - For connected wallets (e.g., browser extensions or external providers), constructs account objects for each connected address from the provided or discovered wallet providers.
         * - Automatically determines the account type and populates relevant fields such as address, curve, and signing capability.
         * - Optionally allows filtering by a specific set of wallet providers and supports custom pagination options.
         * - Supports stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         *
         * @param params.wallet - wallet for which to fetch accounts.
         * @param params.walletProviders - list of wallet providers to filter by (used for connected wallets).
         * @param params.paginationOptions - pagination options for embedded wallets.
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @param params.organizationId - organization ID to target (defaults to the session's organization ID).
         * @param params.userId - user ID to target (defaults to the session's user ID).
         * @param params.authenticatorAddresses - optional authenticator addresses to avoid redundant user fetches (this is used for connected wallets to determine if a connected wallet is an authenticator)
         *
         * @returns A promise that resolves to an array of `v1WalletAccount` objects.
         * @throws {TurnkeyError} If no active session is found or if there is an error fetching wallet accounts.
         */ this.fetchWalletAccounts = async (params)=>{
            const { wallet, stampWith = this.config.defaultStamperType, walletProviders, paginationOptions } = params;
            const session = await this.storageManager.getActiveSession();
            const organizationId = params?.organizationId || session?.organizationId;
            const userId = params?.userId || session?.userId;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                // this is an embedded wallet so we fetch accounts from Turnkey
                if (wallet.source === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WalletSource"].Embedded) {
                    const embedded = [];
                    if (!organizationId) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No organization ID provided and no active session found. Please log in first or pass in an organization ID.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                    }
                    if (!userId) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No user ID provided and no active session found. Please log in first or pass in a user ID.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                    }
                    const res = await this.httpClient.getWalletAccounts({
                        walletId: wallet.walletId,
                        organizationId,
                        paginationOptions: paginationOptions || {
                            limit: "100"
                        }
                    }, stampWith);
                    if (!res || !res.accounts) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No wallet accounts found in the response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                    }
                    for (const account of res.accounts){
                        embedded.push({
                            ...account,
                            source: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WalletSource"].Embedded
                        });
                    }
                    return embedded;
                }
                // this is an external wallet so we fetch accounts from the connected wallet provider
                // if wallet connecting is disabled we return only embedded wallets
                // we should never reach this point if wallet connecting is disabled
                if (!this.walletManager?.connector) return [];
                const connected = [];
                const providers = walletProviders ?? await this.fetchWalletProviders();
                // Context: connected wallets don't all have some uuid we can use for the walletId so what
                //          we do is we use a normalized version of the name for the wallet, like "metamask"
                //          or "phantom-wallet"
                //
                // when fetching accounts, we select all providers with this normalized walletId.
                // A single wallet can map to multiple providers if it supports multiple chains
                // (e.g. MetaMask for Ethereum and MetaMask for Solana)
                const matching = providers.filter((p)=>p.info?.name?.toLowerCase().replace(/\s+/g, "-") === wallet.walletId && p.connectedAddresses.length > 0);
                const sign = this.walletManager.connector.sign.bind(this.walletManager.connector);
                let ethereumAddresses = [];
                let solanaAddresses = [];
                if (params.authenticatorAddresses) {
                    ({ ethereum: ethereumAddresses, solana: solanaAddresses } = params.authenticatorAddresses);
                } else if (organizationId && userId) {
                    // we only fetch the user if authenticator addresses aren't provided and we have the organizationId and userId
                    // if not, then that means `isAuthenticator` will always be false
                    const user = await this.fetchUser({
                        userId,
                        organizationId,
                        stampWith
                    });
                    ({ ethereum: ethereumAddresses, solana: solanaAddresses } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getAuthenticatorAddresses"])(user));
                }
                for (const provider of matching){
                    const timestamp = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toExternalTimestamp"])();
                    for (const address of provider.connectedAddresses){
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isEthereumProvider"])(provider)) {
                            const evmAccount = {
                                walletAccountId: `${wallet.walletId}-${provider.interfaceType}-${address}`,
                                organizationId: organizationId ?? "",
                                walletId: wallet.walletId,
                                pathFormat: "PATH_FORMAT_BIP32",
                                path: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WalletSource"].Connected,
                                source: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WalletSource"].Connected,
                                address,
                                createdAt: timestamp,
                                updatedAt: timestamp,
                                // ethereum specific
                                curve: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"].SECP256K1,
                                addressFormat: "ADDRESS_FORMAT_ETHEREUM",
                                chainInfo: provider.chainInfo,
                                isAuthenticator: ethereumAddresses.includes(address.toLowerCase()),
                                signMessage: (msg)=>sign(msg, provider, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SignIntent"].SignMessage),
                                signAndSendTransaction: (tx)=>sign(tx, provider, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SignIntent"].SignAndSendTransaction)
                            };
                            connected.push(evmAccount);
                            continue;
                        }
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSolanaProvider"])(provider)) {
                            const solAccount = {
                                walletAccountId: `${wallet.walletId}-${provider.interfaceType}-${address}`,
                                organizationId: organizationId ?? "",
                                walletId: wallet.walletId,
                                pathFormat: "PATH_FORMAT_BIP32",
                                path: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WalletSource"].Connected,
                                source: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WalletSource"].Connected,
                                address,
                                createdAt: timestamp,
                                updatedAt: timestamp,
                                // solana specific
                                publicKey: address,
                                curve: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Curve"].ED25519,
                                addressFormat: "ADDRESS_FORMAT_SOLANA",
                                chainInfo: provider.chainInfo,
                                isAuthenticator: solanaAddresses.includes(address),
                                signMessage: (msg)=>sign(msg, provider, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SignIntent"].SignMessage),
                                signTransaction: (tx)=>sign(tx, provider, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SignIntent"].SignTransaction)
                            };
                            connected.push(solAccount);
                            continue;
                        }
                        throw new Error(`Unsupported wallet chain: ${provider.chainInfo}. Supported chains are Ethereum and Solana.`);
                    }
                }
                return connected;
            }, {
                errorMessage: "Failed to fetch wallet accounts",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].FETCH_WALLET_ACCOUNTS_ERROR
            });
        };
        /**
         * Fetches all private keys for the current user.
         *
         * - Retrieves private keys from the Turnkey API.
         * - Supports stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         *
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @param params.organizationId - organization ID to target (defaults to the session's organization ID).
         * @returns A promise that resolves to an array of `v1PrivateKey` objects.
         * @throws {TurnkeyError} If no active session is found or if there is an error fetching private keys.
         */ this.fetchPrivateKeys = async (params)=>{
            const { stampWith = this.config.defaultStamperType } = params || {};
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            const organizationId = params?.organizationId || session?.organizationId;
            if (!organizationId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No organization ID provided and no active session found. Please log in first or pass in an organization ID.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const res = await this.httpClient.getPrivateKeys({
                    organizationId
                }, stampWith);
                if (!res) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to fetch private keys", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                return res.privateKeys;
            }, {
                errorMessage: "Failed to fetch private keys",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].FETCH_PRIVATE_KEYS_ERROR
            });
        };
        /**
         * Signs a message using the specified wallet account.
         *
         * Behavior differs depending on the wallet type:
         *
         * - **Connected wallets**
         *   - Delegates signing to the wallet providers native signing method.
         *   - *Ethereum*: signatures always follow [EIP-191](https://eips.ethereum.org/EIPS/eip-191).
         *     - The wallet automatically prefixes messages with
         *       `"\x19Ethereum Signed Message:\n" + message length` before signing.
         *     - As a result, these signatures cannot be used as raw transaction signatures or broadcast on-chain.
         *     - If `addEthereumPrefix` is set to `false`, an error is thrown because connected Ethereum wallets always prefix.
         *   - *Other chains*: follows the native connected wallet behavior.
         *
         * - **Embedded wallets**
         *   - Uses the Turnkey API to sign the message directly.
         *   - Supports optional `addEthereumPrefix`:
         *     - If `true` (default for Ethereum), the message is prefixed before signing.
         *     - If `false`, the raw message is signed without any prefix.
         *
         * Additional details:
         * - Automatically handles encoding and hashing based on the wallet accounts address format,
         *   unless explicitly overridden.
         * - Optionally allows stamping with a specific stamper
         *   (`StamperType.Passkey`, `StamperType.ApiKey`, or `StamperType.Wallet`).
         *
         * @param params.message - plaintext (UTF-8) message to sign.
         * @param params.walletAccount - wallet account to use for signing.
         * @param params.encoding - override for payload encoding (defaults to the encoding appropriate for the address format).
         * @param params.hashFunction - override for hash function (defaults to the function appropriate for the address format).
         * @param params.stampWith - optional stamper for the signing request.
         * @param params.addEthereumPrefix - whether to prefix the message with Ethereums
         *   `"\x19Ethereum Signed Message:\n"` string (default: `true` for Ethereum).
         * @param params.organizationId - organization ID to target (defaults to the session's organization ID).
         *
         * @returns A promise that resolves to a `v1SignRawPayloadResult` containing the signature and metadata.
         * @throws {TurnkeyError} If signing fails, the wallet type does not support message signing, or the response is invalid.
         */ this.signMessage = async (params)=>{
            const { message, walletAccount, stampWith = this.config.defaultStamperType, addEthereumPrefix, organizationId } = params;
            const hashFunction = params.hashFunction || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getHashFunction"])(walletAccount.addressFormat);
            const payloadEncoding = params.encoding || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEncodingType"])(walletAccount.addressFormat);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const isEthereum = walletAccount.addressFormat === "ADDRESS_FORMAT_ETHEREUM";
                if (walletAccount.source === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WalletSource"].Connected) {
                    // this is a connected wallet
                    if (!addEthereumPrefix && isEthereum) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Connected Ethereum wallets automatically prefix messages. Use `addEthereumPrefix: true`.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SIGN_MESSAGE_ERROR);
                    }
                    let encodedMessage = message;
                    if (isEthereum) {
                        const msgBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUtf8Bytes"])(message);
                        encodedMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEncodedMessage"])(payloadEncoding, msgBytes);
                    }
                    const sigHex = await walletAccount.signMessage(encodedMessage);
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["splitSignature"])(sigHex, walletAccount.addressFormat);
                }
                // this is an embedded wallet
                let msgBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUtf8Bytes"])(message);
                if (addEthereumPrefix && isEthereum) {
                    const prefix = `\x19Ethereum Signed Message:\n${msgBytes.length}`;
                    const prefixBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ethers$2f$lib$2e$esm$2f$utils$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toUtf8Bytes"])(prefix);
                    const combined = new Uint8Array(prefixBytes.length + msgBytes.length);
                    combined.set(prefixBytes, 0);
                    combined.set(msgBytes, prefixBytes.length);
                    msgBytes = combined;
                }
                const encodedMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEncodedMessage"])(payloadEncoding, msgBytes);
                const response = await this.httpClient.signRawPayload({
                    signWith: walletAccount.address,
                    payload: encodedMessage,
                    encoding: payloadEncoding,
                    hashFunction,
                    ...organizationId && {
                        organizationId
                    }
                }, stampWith);
                if (response.activity.failure) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to sign message, no signed payload returned", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SIGN_MESSAGE_ERROR);
                }
                return response.activity.result.signRawPayloadResult;
            }, {
                errorMessage: "Failed to sign message",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SIGN_MESSAGE_ERROR
            });
        };
        /**
         * Signs a transaction using the specified wallet account.
         *
         * Behavior differs depending on the type of wallet:
         *
         * - **Connected wallets**
         *   - Ethereum: does not support raw transaction signing. Calling this function will throw an error instructing you to use `signAndSendTransaction` instead.
         *   - Solana: supports raw transaction signing via the connected wallet provider.
         *   - Other chains: not supported; will throw an error.
         *
         * - **Embedded wallets**
         *   - Delegates signing to the Turnkey API, which returns the signed transaction.
         *   - Supports all Turnkey-supported transaction types (e.g., Ethereum, Solana, Tron).
         *   - Optionally allows stamping with a specific stamper (`StamperType.Passkey`, `StamperType.ApiKey`, or `StamperType.Wallet`).
         *   - Note: For embedded Ethereum wallets, the returned signature doesnt include the `0x` prefix. You should add `0x` before
         *     broadcasting if its missing. Its a good idea to check whether the signature already starts with `0x` before adding it,
         *     since we plan to include the prefix by default in a future breaking change.
         *
         * @param params.walletAccount - wallet account to use for signing.
         * @param params.unsignedTransaction - unsigned transaction data as a serialized
         *   string in the canonical encoding for the given `transactionType`.
         * @param params.transactionType - type of transaction (e.g., "TRANSACTION_TYPE_ETHEREUM", "TRANSACTION_TYPE_SOLANA", "TRANSACTION_TYPE_TRON").
         * @param params.stampWith - stamper to use for signing (`StamperType.Passkey`, `StamperType.ApiKey`, or `StamperType.Wallet`).
         * @param params.organizationId - organization ID to target (defaults to the session's organization ID).
         * @returns A promise that resolves to the signed transaction string.
         * @throws {TurnkeyError} If the wallet type is unsupported, signing fails, or the response is invalid.
         */ this.signTransaction = async (params)=>{
            const { walletAccount, unsignedTransaction, transactionType, stampWith = this.config.defaultStamperType, organizationId } = params;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                if (walletAccount.source === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WalletSource"].Connected) {
                    switch(walletAccount.chainInfo.namespace){
                        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Chain"].Ethereum:
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Ethereum connected wallets do not support raw transaction signing. Use signAndSendTransaction instead.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Chain"].Solana:
                            // not sure why typescript isn't inferring the type here
                            // if namespace is Chain.Solana, then it must be a ConnectedSolanaWalletAccount
                            return walletAccount.signTransaction(unsignedTransaction);
                        default:
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Unsupported connected wallet type.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                    }
                }
                // this is an embedded wallet account
                const signTransaction = await this.httpClient.signTransaction({
                    signWith: walletAccount.address,
                    unsignedTransaction,
                    type: transactionType,
                    ...organizationId && {
                        organizationId
                    }
                }, stampWith);
                // TODO (breaking change): eventually we should append a `0x` prefix for ethereum signatures here
                // then we should remove the note in the comment header
                return signTransaction.signedTransaction;
            }, {
                errorMessage: "Failed to sign transaction",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SIGN_TRANSACTION_ERROR
            });
        };
        /**
         * Signs and broadcasts a transaction using the specified wallet account.
         *
         * Behavior differs depending on the type of wallet:
         *
         * - **Connected wallets**
         *   - *Ethereum*: delegates to the wallets native `signAndSendTransaction` method.
         *     - Does **not** require an `rpcUrl` (the wallet handles broadcasting).
         *   - *Solana*: signs the transaction locally with the connected wallet, but requires an `rpcUrl` to broadcast it.
         *   - Other chains: not supported; will throw an error.
         *
         * - **Embedded wallets**
         *   - Signs the transaction using the Turnkey API.
         *   - Requires an `rpcUrl` to broadcast the signed transaction, since Turnkey does not broadcast directly.
         *   - Broadcasts the transaction using a JSON-RPC client and returns the resulting transaction hash/signature.
         *   - Optionally allows stamping with a specific stamper (`StamperType.Passkey`, `StamperType.ApiKey`, or `StamperType.Wallet`).
         *
         * @param params.walletAccount - wallet account to use for signing and broadcasting.
         * @param params.unsignedTransaction - unsigned transaction data as a serialized
         *   string in the canonical encoding for the given `transactionType`.
         * @param params.transactionType - type of transaction (e.g., `"TRANSACTION_TYPE_SOLANA"`, `"TRANSACTION_TYPE_ETHEREUM"`).
         * @param params.rpcUrl - JSON-RPC endpoint used for broadcasting (required for Solana connected wallets and all embedded wallets).
         * @param params.stampWith - optional stamper to use when signing (`StamperType.Passkey`, `StamperType.ApiKey`, or `StamperType.Wallet`).
         * @param params.organizationId - **Only for Turnkey embedded wallets**: organization ID to target (defaults to the session's organization ID).
         * @returns A promise that resolves to a transaction signature or hash.
         * @throws {TurnkeyError} If the wallet type is unsupported, or if signing/broadcasting fails.
         */ this.signAndSendTransaction = async (params)=>{
            const { walletAccount, unsignedTransaction, transactionType, rpcUrl, stampWith = this.config.defaultStamperType, organizationId } = params;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                if (walletAccount.source === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["WalletSource"].Connected) {
                    // this is a connected wallet account
                    switch(walletAccount.chainInfo.namespace){
                        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Chain"].Ethereum:
                            // not sure why typescript isn't inferring the type here
                            // if namespace is Chain.Ethereum, then it must be a ConnectedEthereumWalletAccount
                            return await walletAccount.signAndSendTransaction(unsignedTransaction);
                        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Chain"].Solana:
                            if (!rpcUrl) {
                                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Missing rpcUrl: connected Solana wallets require an RPC URL to broadcast transactions.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SIGN_AND_SEND_TRANSACTION_ERROR);
                            }
                            // not sure why typescript isn't inferring the type here
                            // if namespace is Chain.Solana, then it must be a ConnectedSolanaWalletAccount
                            const signature = await walletAccount.signTransaction(unsignedTransaction);
                            return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcastTransaction"])({
                                signedTransaction: signature,
                                rpcUrl,
                                transactionType
                            });
                        default:
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Connected wallets do not support signAndSendTransaction for this transaction type.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SIGN_AND_SEND_TRANSACTION_ERROR);
                    }
                }
                // this is an embedded wallet account
                // embedded wallet requires an RPC URL to broadcast
                // since Turnkey does not broadcast transactions directly
                if (!rpcUrl) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Missing rpcUrl: embedded wallets require an RPC URL to broadcast transactions.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SIGN_AND_SEND_TRANSACTION_ERROR);
                }
                const signTransactionResponse = await this.httpClient.signTransaction({
                    signWith: walletAccount.address,
                    unsignedTransaction,
                    type: transactionType,
                    ...organizationId && {
                        organizationId
                    }
                }, stampWith);
                const signedTx = transactionType === "TRANSACTION_TYPE_ETHEREUM" ? `0x${signTransactionResponse.signedTransaction}` : signTransactionResponse.signedTransaction;
                const txHash = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["broadcastTransaction"])({
                    signedTransaction: signedTx,
                    rpcUrl,
                    transactionType
                });
                return txHash;
            }, {
                errorMessage: "Failed to sign and send transaction",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SIGN_AND_SEND_TRANSACTION_ERROR
            });
        };
        /**
         * @beta
         * * **API subject to change**
         *
         * Signs and submits an Ethereum transaction using a Turnkey-managed (embedded) wallet.
         *
         * This method performs **authorization and signing**, and submits the transaction
         * to Turnkeys coordinator. It **does not perform any polling**  callers must use
         * `pollTransactionStatus` to obtain the final on-chain result.
         *
         * Behavior:
         *
         * - **Connected wallets**
         *   - Connected wallets are **not supported** by this method.
         *   - They must instead use `signAndSendTransaction`.
         *
         * - **Embedded wallets**
         *   - Constructs the payload for Turnkey's `eth_send_transaction` endpoint.
         *   - Fetches nonces automatically when needed (normal nonce or Gas Station nonce).
         *   - Signs and submits the transaction through Turnkey.
         *   - Returns a `sendTransactionStatusId`, which the caller must pass to
         *     `pollTransactionStatus` to obtain the final result (tx hash + status).
         *
         * @param params.organizationId - Organization ID to execute the transaction under.
         *                                Defaults to the active session's organization.
         *
         * @param params.stampWith - Optional stamper to authorize signing (e.g., passkey).
         *
         * @param params.transaction - The Ethereum transaction details.
         * @returns A promise resolving to the `sendTransactionStatusId`.
         *          This ID must be passed to `pollTransactionStatus`.
         *
         * @throws {TurnkeyError} If the transaction is invalid or Turnkey rejects it.
         */ this.ethSendTransaction = async (params)=>{
            const { organizationId: organizationIdFromParams, stampWith = this.config.defaultStamperType, transaction } = params;
            const { from, to, caip2, value, data, nonce, gasLimit, maxFeePerGas, maxPriorityFeePerGas, sponsor } = transaction;
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            const organizationId = organizationIdFromParams || session?.organizationId;
            if (!organizationId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Organization ID must be provided to send a transaction", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                let gasStationNonce;
                let fetchedNonce;
                //
                // Fetch nonce(s) when needed:
                // - sponsored: Gas Station nonce
                // - non-sponsored: regular EIP-1559 nonce
                //
                if (!nonce || sponsor) {
                    const nonceResp = await this.httpClient.getNonces({
                        organizationId,
                        address: from,
                        caip2,
                        nonce: sponsor ? false : true,
                        gasStationNonce: sponsor ? true : false
                    });
                    gasStationNonce = nonceResp.gasStationNonce;
                    fetchedNonce = nonceResp.nonce;
                }
                const finalNonce = nonce ?? fetchedNonce;
                //
                // Build Turnkey intent
                //
                const intent = {
                    from,
                    to,
                    caip2,
                    ...value ? {
                        value
                    } : {},
                    ...data ? {
                        data
                    } : {}
                };
                if (sponsor) {
                    intent.sponsor = true;
                    if (gasStationNonce) intent.gasStationNonce = gasStationNonce;
                } else {
                    if (finalNonce !== undefined) intent.nonce = finalNonce;
                    if (gasLimit) intent.gasLimit = gasLimit;
                    if (maxFeePerGas) intent.maxFeePerGas = maxFeePerGas;
                    if (maxPriorityFeePerGas) intent.maxPriorityFeePerGas = maxPriorityFeePerGas;
                }
                //
                // Submit to Turnkey
                //
                const resp = await this.httpClient.ethSendTransaction({
                    ...intent,
                    organizationId
                });
                const id = resp.sendTransactionStatusId;
                if (!id) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Missing sendTransactionStatusId", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].ETH_SEND_TRANSACTION_ERROR);
                }
                return id;
            }, {
                errorMessage: "Failed to sign and send Ethereum transaction",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].ETH_SEND_TRANSACTION_ERROR
            });
        };
        /**
         * Fetches the user details for the current session or a specified user.
         *
         * - Retrieves user details from the Turnkey API using the provided userId and organizationId, or defaults to those from the active session.
         * - If no userId is provided, the userId from the current session is used.
         * - If no organizationId is provided, the organizationId from the current session is used.
         * - Optionally allows stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * - Ensures that an active session exists before making the request.
         *
         * @param params.organizationId - organization ID to specify the sub-organization (defaults to the current session's organizationId).
         * @param params.userId - user ID to fetch specific user details (defaults to the current session's userId).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @returns A promise that resolves to a `v1User` object containing the user details.
         * @throws {TurnkeyError} If there is no active session, if there is no userId, or if there is an error fetching user details.
         */ this.fetchUser = async (params)=>{
            const { organizationId: organizationIdFromParams, userId: userIdFromParams, stampWith = this.config.defaultStamperType } = params || {};
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            const userId = userIdFromParams || session?.userId;
            if (!userId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("User ID must be provided to fetch user", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            const organizationId = organizationIdFromParams || session?.organizationId;
            if (!organizationId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Organization ID must be provided to fetch user", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const userResponse = await this.httpClient.getUser({
                    organizationId,
                    userId
                }, stampWith);
                if (!userResponse || !userResponse.user) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No user found in the response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                return userResponse.user;
            }, {
                errorMessage: "Failed to fetch user",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].FETCH_USER_ERROR
            });
        };
        /**
         * Fetches an existing user by P-256 API key public key, or creates a new one if none exists.
         *
         * - This function is idempotent: multiple calls with the same `publicKey` will always return the same user.
         * - Attempts to find a user whose API keys include the given P-256 public key.
         * - If a matching user is found, it is returned as-is.
         * - If no matching user is found, a new user is created with the given public key as a P-256 API key.
         *
         * @param params.publicKey - the P-256 public key to use for lookup and creation.
         * @param params.createParams.userName - optional username to assign if creating a new user (defaults to `"Public Key User"`).
         * @param params.createParams.apiKeyName - optional API key name to assign if creating a new API key (defaults to `public-key-user-${publicKey}`).
         * @param params.organizationId - organization ID to specify the sub-organization (defaults to the current session's organizationId).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @returns A promise that resolves to the existing or newly created {@link v1User}.
         * @throws {TurnkeyError} If there is no active session, if the input is invalid, if user retrieval fails, or if user creation fails.
         */ this.fetchOrCreateP256ApiKeyUser = async (params)=>{
            const { publicKey, createParams, stampWith = this.config.defaultStamperType, organizationId: organizationIdFromParams } = params;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
                const organizationId = organizationIdFromParams || session?.organizationId;
                if (!organizationId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Organization ID is required to fetch or create P-256 API key user.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                }
                // we validate their input
                if (!publicKey?.trim()) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("'publicKey' is required and cannot be empty.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                }
                const usersResponse = await this.httpClient.getUsers({
                    organizationId
                }, stampWith);
                if (!usersResponse || !usersResponse.users) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No users found in the response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                const userWithPublicKey = usersResponse.users.find((user)=>user.apiKeys.some((apiKey)=>apiKey.credential.publicKey === publicKey && apiKey.credential.type === "CREDENTIAL_TYPE_API_KEY_P256"));
                // the user already exists, so we return it
                if (userWithPublicKey) {
                    return userWithPublicKey;
                }
                // at this point we know the user doesn't exist, so we create it
                const userName = createParams?.userName?.trim() || "Public Key User";
                const apiKeyName = createParams?.apiKeyName?.trim() || `public-key-user-${publicKey}`;
                const createUserResp = await this.httpClient.createUsers({
                    organizationId,
                    users: [
                        {
                            userName: userName,
                            userTags: [],
                            apiKeys: [
                                {
                                    apiKeyName: apiKeyName,
                                    curveType: "API_KEY_CURVE_P256",
                                    publicKey
                                }
                            ],
                            authenticators: [],
                            oauthProviders: []
                        }
                    ]
                }, stampWith);
                if (!createUserResp?.userIds || createUserResp.userIds.length === 0 || !createUserResp.userIds[0]) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to create P-256 API key user", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CREATE_USERS_ERROR);
                }
                const newUserId = createUserResp.userIds[0];
                return await this.fetchUser({
                    organizationId,
                    userId: newUserId,
                    stampWith
                });
            }, {
                errorMessage: "Failed to get or create P-256 API key user",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CREATE_USERS_ERROR
            });
        };
        /**
         * Fetches each requested policy if it exists, or creates it if it does not.
         *
         * - This function is idempotent: multiple calls with the same policies will not create duplicates.
         * - For every policy in the request:
         *   - If it already exists, it is returned with its `policyId`.
         *   - If it does not exist, it is created and returned with its new `policyId`.
         *
         * @param params.policies - the list of policies to fetch or create.
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @param params.organizationId - organization ID to specify the sub-organization (defaults to the current session's organizationId).
         * @returns A promise that resolves to an array of objects, each containing:
         *          - `policyId`: the unique identifier of the policy.
         *          - `policyName`: human-readable name of the policy.
         *          - `effect`: the instruction to DENY or ALLOW an activity.
         *          - `condition`: (optional) the condition expression that triggers the effect.
         *          - `consensus`: (optional) the consensus expression that triggers the effect.
         *          - `notes`: (optional) developer notes or description for the policy.
         * @throws {TurnkeyError} If there is no active session, if the input is invalid,
         *                        if fetching policies fails, or if creating policies fails.
         */ this.fetchOrCreatePolicies = async (params)=>{
            const { policies, stampWith = this.config.defaultStamperType } = params;
            return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
                if (!Array.isArray(policies) || policies.length === 0) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("'policies' must be a non-empty array of policy definitions.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                }
                const organizationId = params?.organizationId ?? session?.organizationId;
                if (!organizationId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Organization ID is required to fetch or create policies.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                }
                // we first fetch existing policies
                const existingPoliciesResponse = await this.httpClient.getPolicies({
                    organizationId
                }, stampWith);
                const existingPolicies = existingPoliciesResponse.policies || [];
                // we create a map of existing policies by their signature
                // where the policySignature maps to its policyId
                const existingPoliciesSignatureMap = {};
                for (const existingPolicy of existingPolicies){
                    const signature = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPolicySignature"])(existingPolicy);
                    existingPoliciesSignatureMap[signature] = existingPolicy.policyId;
                }
                // we go through each requested policy and check if it already exists
                // if it exists, we add it to the alreadyExistingPolicies list
                // if it doesn't exist, we add it to the missingPolicies list
                const alreadyExistingPolicies = [];
                const missingPolicies = [];
                for (const policy of policies){
                    const existingId = existingPoliciesSignatureMap[(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPolicySignature"])(policy)];
                    if (existingId) {
                        alreadyExistingPolicies.push({
                            ...policy,
                            policyId: existingId
                        });
                    } else {
                        missingPolicies.push(policy);
                    }
                }
                // if there are no missing policies, that means we're done
                // so we return them with their respective IDs
                if (missingPolicies.length === 0) {
                    return alreadyExistingPolicies;
                }
                // at this point we know there is at least one missing policy.
                // so we create the missing policies and then return the full list
                const createPoliciesResponse = await this.httpClient.createPolicies({
                    organizationId,
                    policies: missingPolicies
                }, stampWith);
                // assign returned IDs back to the missing ones in order
                if (!createPoliciesResponse || !createPoliciesResponse.policyIds) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to create missing policies", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CREATE_POLICY_ERROR);
                }
                const newlyCreatedPolicies = missingPolicies.map((p, idx)=>({
                        ...p,
                        // we can safely assert the ID exists because we know Turnkey's api
                        // will return one ID for each created policy or throw an error
                        policyId: createPoliciesResponse.policyIds[idx]
                    }));
                // we return the full list of policies, both existing and the newly created
                // which includes each of their respective IDs
                return [
                    ...alreadyExistingPolicies,
                    ...newlyCreatedPolicies
                ];
            }, {
                errorMessage: "Failed to get or create policies",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CREATE_USERS_ERROR
            });
        };
        /**
         * Updates the user's email address.
         *
         * - This function updates the user's email address and, if provided, verifies it using a verification token (typically from an OTP flow).
         * - If a userId is provided, it updates the email for that specific user; otherwise, it uses the current session's userId.
         * - If a verificationToken is not provided, the email will be updated but will not be marked as verified.
         * - Automatically ensures an active session exists before making the request.
         * - Handles session management and error reporting for both update and verification flows.
         *
         * @param params.email - new email address to set for the user.
         * @param params.verificationToken - verification token from OTP email verification (required if verifying the email).
         * @param params.userId - user ID to update a specific user's email (defaults to the current session's userId).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @param params.organizationId - organization ID to specify the sub-organization (defaults to the current session's organizationId).
         * @returns A promise that resolves to the userId of the updated user.
         * @throws {TurnkeyError} If there is no active session, if the userId is missing, or if there is an error updating or verifying the user email.
         */ this.updateUserEmail = async (params)=>{
            const { verificationToken, email, stampWith = this.config.defaultStamperType, organizationId } = params;
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            const userId = params?.userId || session?.userId;
            if (!userId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("User ID must be provided to update user email", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                if (verificationToken) {
                    const existingUser = await this.httpClient.proxyGetAccount({
                        filterType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FilterType"].Email,
                        filterValue: email,
                        verificationToken
                    });
                    if (existingUser.organizationId) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Email ${email} is already associated with another user.`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].ACCOUNT_ALREADY_EXISTS);
                    }
                }
                const res = await this.httpClient.updateUserEmail({
                    userId: userId,
                    userEmail: email,
                    ...verificationToken && {
                        verificationToken
                    },
                    ...organizationId && {
                        organizationId
                    }
                }, stampWith);
                if (!res || !res.userId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No user ID found in the update user email response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                return res.userId;
            }, {
                errorMessage: "Failed to update user email",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].UPDATE_USER_EMAIL_ERROR
            });
        };
        /**
         * Removes the user's email address.
         *
         * - This function removes the user's email address by setting it to an empty string.
         * - If a userId is provided, it removes the email for that specific user; otherwise, it uses the current session's userId.
         * - Automatically ensures an active session exists before making the request.
         * - Optionally allows stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         *
         * @param params.userId - user ID to remove a specific user's email address (defaults to the current session's userId).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @param params.organizationId - organization ID to specify the sub-organization (defaults to the current session's organizationId).
         * @returns A promise that resolves to the userId of the user whose email was removed.
         * @throws {TurnkeyError} If there is no active session, if the userId is missing, or if there is an error removing the user email.
         */ this.removeUserEmail = async (params)=>{
            const { stampWith = this.config.defaultStamperType, organizationId } = params || {};
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const userId = params?.userId || session?.userId;
                if (!userId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("User ID must be provided to remove user email", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                }
                const res = await this.httpClient.updateUserEmail({
                    userId: userId,
                    userEmail: "",
                    ...organizationId && {
                        organizationId
                    }
                }, stampWith);
                if (!res || !res.userId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No user ID found in the remove user email response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                return res.userId;
            }, {
                errorMessage: "Failed to remove user email",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].UPDATE_USER_EMAIL_ERROR
            });
        };
        /**
         * Updates the user's phone number.
         *
         * - This function updates the user's phone number and, if provided, verifies it using a verification token (from an OTP flow).
         * - If a userId is provided, it updates the phone number for that specific user; otherwise, it uses the current session's userId.
         * - If a verificationToken is not provided, the phone number will be updated but will not be marked as verified.
         * - Automatically ensures an active session exists before making the request.
         * - Handles session management and error reporting for both update and verification flows.
         *
         * @param params.phoneNumber - new phone number to set for the user.
         * @param params.verificationToken - verification token from OTP phone verification (required if verifying the phone number).
         * @param params.userId - user ID to update a specific user's phone number (defaults to the current session's userId).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @param params.organizationId - organization ID to specify the sub-organization (defaults to the current session's organizationId).
         * @returns A promise that resolves to the userId of the updated user.
         * @throws {TurnkeyError} If there is no active session, if the userId is missing, or if there is an error updating or verifying the user phone number.
         */ this.updateUserPhoneNumber = async (params)=>{
            const { verificationToken, phoneNumber, stampWith = this.config.defaultStamperType, organizationId } = params;
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            const userId = params?.userId || session?.userId;
            if (!userId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("User ID must be provided to update user phone number", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                if (verificationToken) {
                    const existingUser = await this.httpClient.proxyGetAccount({
                        filterType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FilterType"].Sms,
                        filterValue: phoneNumber,
                        verificationToken
                    });
                    if (existingUser.organizationId) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Phone number ${phoneNumber} is already associated with another user.`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].ACCOUNT_ALREADY_EXISTS);
                    }
                }
                const res = await this.httpClient.updateUserPhoneNumber({
                    userId,
                    userPhoneNumber: phoneNumber,
                    ...verificationToken && {
                        verificationToken
                    },
                    ...organizationId && {
                        organizationId
                    }
                }, stampWith);
                if (!res || !res.userId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to update user phone number", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].UPDATE_USER_PHONE_NUMBER_ERROR);
                }
                return res.userId;
            }, {
                errorMessage: "Failed to update user phone number",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].UPDATE_USER_PHONE_NUMBER_ERROR
            });
        };
        /**
         * Removes the user's phone number.
         *
         * - This function removes the user's phone number by setting it to an empty string.
         * - If a userId is provided, it removes the phone number for that specific user; otherwise, it uses the current session's userId.
         * - Automatically ensures an active session exists before making the request.
         * - Optionally allows stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         *
         * @param params.userId - user ID to remove a specific user's phone number (defaults to the current session's userId).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @param params.organizationId - organization ID to specify the sub-organization (defaults to the current session's organizationId).
         * @returns A promise that resolves to the userId of the user whose phone number was removed.
         * @throws {TurnkeyError} If there is no active session, if the userId is missing, or if there is an error removing the user phone number.
         */ this.removeUserPhoneNumber = async (params)=>{
            const { stampWith = this.config.defaultStamperType, organizationId } = params || {};
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            const userId = params?.userId || session?.userId;
            if (!userId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("User ID must be provided to remove user phone number", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const res = await this.httpClient.updateUserPhoneNumber({
                    userId,
                    userPhoneNumber: "",
                    ...organizationId && {
                        organizationId
                    }
                }, stampWith);
                if (!res || !res.userId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to remove user phone number", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].UPDATE_USER_PHONE_NUMBER_ERROR);
                }
                return res.userId;
            }, {
                errorMessage: "Failed to remove user phone number",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].UPDATE_USER_PHONE_NUMBER_ERROR
            });
        };
        /**
         * Updates the user's name.
         *
         * - This function updates the user's display name.
         * - If a userId is provided, it updates the name for that specific user; otherwise, it uses the current session's userId.
         * - Automatically ensures an active session exists before making the request.
         * - Optionally allows stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * - Handles session management and error reporting for the update flow.
         *
         * @param params.userName - new name to set for the user.
         * @param params.userId - user ID to update a specific user's name (defaults to the current session's userId).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @param params.organizationId - organization ID to specify the sub-organization (defaults to the current session's organizationId).
         * @returns A promise that resolves to the userId of the updated user.
         * @throws {TurnkeyError} If there is no active session, if the userId is missing, or if there is an error updating the user name.
         */ this.updateUserName = async (params)=>{
            const { userName, stampWith = this.config.defaultStamperType, organizationId } = params;
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            const userId = params?.userId || session?.userId;
            if (!userId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("User ID must be provided to update user name", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const res = await this.httpClient.updateUserName({
                    userId,
                    userName,
                    ...organizationId && {
                        organizationId
                    }
                }, stampWith);
                if (!res || !res.userId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No user ID found in the update user name response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                return res.userId;
            }, {
                errorMessage: "Failed to update user name",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].UPDATE_USER_NAME_ERROR
            });
        };
        /**
         * Adds an OAuth provider to the user.
         *
         * - This function adds an OAuth provider (e.g., Google, Apple) to the user account.
         * - If a userId is provided, it adds the provider for that specific user; otherwise, it uses the current session's userId.
         * - Automatically checks if an account already exists for the provided OIDC token and prevents duplicate associations.
         * - If the user's email is not set or not verified, attempts to update and verify the email using the email from the OIDC token.
         * - Handles session management and error reporting for the add provider flow.
         * - Optionally allows stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         *
         * @param params.providerName - name of the OAuth provider to add (e.g., "Google", "Apple").
         * @param params.oidcToken - OIDC token for the OAuth provider.
         * @param params.organizationId - organization ID to specify the sub-organization (defaults to the current session's organizationId).
         * @param params.userId - user ID to add the provider for a specific user (defaults to current session's userId).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @returns A promise that resolves to an array of provider IDs associated with the user.
         * @throws {TurnkeyError} If there is no active session, if the account already exists, or if there is an error adding the OAuth provider.
         */ this.addOauthProvider = async (params)=>{
            const { providerName, oidcToken, stampWith = this.config.defaultStamperType } = params;
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const accountRes = await this.httpClient.proxyGetAccount({
                    filterType: "OIDC_TOKEN",
                    filterValue: oidcToken
                });
                if (!accountRes) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Account fetch failed`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].ACCOUNT_FETCH_ERROR);
                }
                if (accountRes.organizationId && accountRes.organizationId !== session?.organizationId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Account already exists with this OIDC token", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].ACCOUNT_ALREADY_EXISTS);
                }
                const userId = params?.userId || session?.userId;
                if (!userId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("User ID must be provided to add OAuth provider", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                }
                const organizationId = params?.organizationId ?? session?.organizationId;
                if (!organizationId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Organization ID is required to add OAuth provider", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                }
                // parse the oidc token so we can get the email. Pass it in to updateUser then call createOauthProviders. This will be verified by Turnkey.
                const { email: oidcEmail, iss } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jwt$2d$decode$2f$build$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["jwtDecode"])(oidcToken) || {};
                if (iss === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["googleISS"]) {
                    const verifiedSuborg = await this.httpClient.proxyGetAccount({
                        filterType: "EMAIL",
                        filterValue: oidcEmail,
                        oidcToken: oidcToken
                    });
                    const isVerified = verifiedSuborg.organizationId === organizationId;
                    const user = await this.fetchUser({
                        userId,
                        stampWith
                    });
                    // this block's pupose is for social linking, it's important that we update the email BEFORE we call createOauthProviders
                    // since for social linking createOauthProviders will mark the email as verified as long as it's the same one that lives in the
                    // OIDC token.
                    if (!user?.userEmail && !isVerified) {
                        // we cannot use our sugared updateUserEmail here since we need to pass in the oidcToken in case Require Verification Token On Account Lookup is enabled
                        // in the dashboard
                        const existingUser = await this.httpClient.proxyGetAccount({
                            filterType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FilterType"].Email,
                            filterValue: oidcEmail,
                            oidcToken: oidcToken
                        });
                        if (existingUser.organizationId) {
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Email ${oidcEmail} is already associated with another user.`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].ACCOUNT_ALREADY_EXISTS);
                        }
                        // update and verify their email since we got it from a verified OIDC token
                        await this.httpClient.updateUserEmail({
                            userId,
                            userEmail: oidcEmail,
                            organizationId
                        }, stampWith);
                    }
                }
                const createProviderRes = await this.httpClient.createOauthProviders({
                    userId,
                    oauthProviders: [
                        {
                            providerName,
                            oidcToken
                        }
                    ]
                }, stampWith);
                if (!createProviderRes) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to create OAuth provider", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].ADD_OAUTH_PROVIDER_ERROR);
                }
                return createProviderRes?.providerIds || [];
            }, {
                errorMessage: "Failed to add OAuth provider",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].ADD_OAUTH_PROVIDER_ERROR
            });
        };
        /**
         * Removes a list of OAuth providers from the user.
         *
         * - This function removes OAuth providers (e.g., Google, Apple) from the user's account.
         * - If a userId is provided, it removes the providers for that specific user; otherwise, it uses the current session's userId.
         * - Automatically ensures an active session exists before making the request.
         * - Optionally allows stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * - Returns an array of remaining provider IDs associated with the user after removal.
         *
         * @param params.providerIds - IDs of the OAuth providers to remove.
         * @param params.userId - user ID to remove the provider for a specific user (defaults to the current session's userId).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @param params.organizationId - organization ID to specify the sub-organization (defaults to the current session's organizationId).
         * @returns A promise that resolves to an array of provider IDs that were removed.
         * @throws {TurnkeyError} If there is no active session, if the userId is missing, or if there is an error removing the OAuth provider.
         */ this.removeOauthProviders = async (params)=>{
            const { providerIds, stampWith = this.config.defaultStamperType, organizationId } = params;
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            const userId = params?.userId || session?.userId;
            if (!userId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("User ID must be provided to remove OAuth provider", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const res = await this.httpClient.deleteOauthProviders({
                    userId,
                    providerIds,
                    ...organizationId && {
                        organizationId
                    }
                }, stampWith);
                if (!res) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to remove OAuth provider", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].REMOVE_OAUTH_PROVIDER_ERROR);
                }
                return res.providerIds;
            }, {
                errorMessage: "Failed to remove OAuth provider",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].REMOVE_OAUTH_PROVIDER_ERROR
            });
        };
        /**
         * Adds a new passkey authenticator for the user.
         *
         * - This function prompts the user to create a new passkey (WebAuthn/FIDO2) and adds it as an authenticator for the user.
         * - Handles both web and React Native environments, automatically selecting the appropriate passkey creation flow.
         * - If a userId is provided, the passkey is added for that specific user; otherwise, it uses the current session's userId.
         * - The passkey's name and display name can be customized; if not provided, defaults are generated.
         * - The resulting passkey attestation and challenge are registered with Turnkey as a new authenticator.
         *
         * @param params.name - name of the passkey (defaults to "Turnkey Passkey-`timestamp`").
         * @param params.displayName - display name of the passkey (defaults to the value of `name`).
         * @param params.userId - user ID to add the passkey for a specific user (defaults to the current session's userId).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @param params.organizationId - organization ID to specify the sub-organization (defaults to the current session's organizationId).
         * @returns A promise that resolves to an array of authenticator IDs for the newly added passkey(s).
         * @throws {TurnkeyError} If there is no active session, if passkey creation fails, or if there is an error adding the passkey.
         */ this.addPasskey = async (params)=>{
            const { stampWith = this.config.defaultStamperType, organizationId } = params || {};
            const name = params?.name || `Turnkey Passkey-${Date.now()}`;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
                const userId = params?.userId || session?.userId;
                if (!userId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("User ID must be provided to add passkey", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                }
                const { encodedChallenge, attestation } = await this.createPasskey({
                    name
                });
                if (!attestation || !encodedChallenge) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to create passkey challenge and attestation", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CREATE_PASSKEY_ERROR);
                }
                const res = await this.httpClient.createAuthenticators({
                    userId,
                    authenticators: [
                        {
                            authenticatorName: name,
                            challenge: encodedChallenge,
                            attestation
                        }
                    ],
                    ...organizationId && {
                        organizationId
                    }
                }, stampWith);
                return res?.authenticatorIds || [];
            }, {
                errorMessage: "Failed to add passkey",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].ADD_PASSKEY_ERROR
            });
        };
        /**
         * Removes passkeys (authenticator) from the user.
         *
         * - This function removes passkeys (WebAuthn/FIDO2 authenticators) from the user's account.
         * - If a userId is provided, it removes the passkeys for that specific user; otherwise, it uses the current session's userId.
         * - Automatically ensures an active session exists before making the request.
         * - Optionally allows stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * - Returns an array of remaining authenticator IDs for the user after removal.
         *
         * @param params.authenticatorIds - IDs of the authenticators (passkeys) to remove.
         * @param params.userId - user ID to remove the passkeys for a specific user (defaults to the current session's userId).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @param params.organizationId - organization ID to specify the sub-organization (defaults to the current session's organizationId).
         * @returns A promise that resolves to an array of authenticator IDs that were removed.
         * @throws {TurnkeyError} If there is no active session, if the userId is missing, or if there is an error removing the passkeys.
         */ this.removePasskeys = async (params)=>{
            const { authenticatorIds, stampWith = this.config.defaultStamperType, organizationId } = params;
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            const userId = params?.userId || session?.userId;
            if (!userId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("User ID must be provided to remove passkey", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const res = await this.httpClient.deleteAuthenticators({
                    userId,
                    authenticatorIds,
                    ...organizationId && {
                        organizationId
                    }
                }, stampWith);
                if (!res) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No response found in the remove passkey response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].REMOVE_PASSKEY_ERROR);
                }
                return res.authenticatorIds;
            }, {
                errorMessage: "Failed to remove passkey",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].REMOVE_PASSKEY_ERROR
            });
        };
        /**
         * Creates a new wallet for sub-organization.
         *
         * - This function creates a new wallet for the current sub-organization.
         * - If an organizationId is provided, the wallet will be created under that specific sub-organization; otherwise, it uses the current session's organizationId.
         * - If a list of address formats is provided, accounts will be created in the wallet based on those formats (starting from path index 0).
         * - If a list of account parameters is provided, those accounts will be created in the wallet.
         * - If no accounts or address formats are provided, default Ethereum and Solana accounts will be created.
         * - Optionally allows specifying the mnemonic length for the wallet seed phrase (defaults to 12).
         * - Optionally allows stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         *
         * @param params.walletName - name of the wallet to create.
         * @param params.accounts - array of account parameters or address formats to create in the wallet.
         * @param params.organizationId - organization ID to create the wallet under a specific sub-organization (defaults to the current session's organizationId).
         * @param params.mnemonicLength - mnemonic length for the wallet seed phrase (defaults to 12).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @returns A promise that resolves to the ID of the newly created wallet.
         * @throws {TurnkeyError} If there is no active session or if there is an error creating the wallet.
         */ this.createWallet = async (params)=>{
            const { walletName, accounts, organizationId: organizationIdFromParams, mnemonicLength, stampWith = this.config.defaultStamperType } = params;
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            const organizationId = organizationIdFromParams || session?.organizationId;
            if (!organizationId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Organization ID must be provided to create wallet", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            let walletAccounts = [];
            if (accounts && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWalletAccountArray"])(accounts)) {
                walletAccounts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["generateWalletAccountsFromAddressFormat"])({
                    addresses: accounts
                });
            } else {
                walletAccounts = accounts || [
                    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_ETHEREUM_ACCOUNTS"],
                    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_SOLANA_ACCOUNTS"]
                ];
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const res = await this.httpClient.createWallet({
                    organizationId: organizationId,
                    walletName,
                    accounts: walletAccounts,
                    mnemonicLength: mnemonicLength || 12
                }, stampWith);
                if (!res || !res.walletId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No wallet found in the create wallet response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                return res.walletId;
            }, {
                errorMessage: "Failed to create wallet",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CREATE_WALLET_ERROR
            });
        };
        /**
         * Creates new accounts in the specified wallet.
         *
         * - This function creates new wallet accounts based on the provided account parameters or address formats.
         * - If a walletId is provided, it creates the accounts in that specific wallet; otherwise, it uses the current session's wallet.
         * - If a list of address formats is provided, it will create accounts in the wallet based on those formats, automatically determining the next available path indexes to avoid duplicates with existing accounts.
         * - If account parameters are provided, they are used directly for account creation.
         * - Automatically queries existing wallet accounts to prevent duplicate account creation for the same address format and path.
         * - Supports stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         *
         * @param params.accounts - An array of account parameters or address formats to create in the wallet.
         * @param params.walletId - ID of the wallet to create accounts in.
         * @param params.organizationId - organization ID to create the accounts under a specific organization (walletId must be associated with the sub-organization).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @returns A promise that resolves to an array of addresses for the newly created accounts.
         * @throws {TurnkeyError} If there is no active session, if the wallet does not exist, or if there is an error creating the wallet accounts.
         */ this.createWalletAccounts = async (params)=>{
            const { accounts, walletId, organizationId: organizationIdFromParams, stampWith = this.config.defaultStamperType } = params;
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            const organizationId = organizationIdFromParams || session?.organizationId;
            if (!organizationId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Organization ID must be provided to create wallet accounts", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                let walletAccounts = [];
                if (accounts && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isWalletAccountArray"])(accounts)) {
                    // Query existing wallet accounts to avoid duplicates
                    const existingWalletAccounts = await this.httpClient.getWalletAccounts({
                        walletId,
                        organizationId: organizationId,
                        paginationOptions: {
                            limit: "100"
                        }
                    }, stampWith);
                    walletAccounts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["generateWalletAccountsFromAddressFormat"])({
                        addresses: accounts,
                        existingWalletAccounts: existingWalletAccounts.accounts || []
                    });
                } else {
                    walletAccounts = accounts;
                }
                const res = await this.httpClient.createWalletAccounts({
                    organizationId: organizationId,
                    walletId,
                    accounts: walletAccounts
                }, stampWith);
                if (!res || !res.addresses) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No account found in the create wallet account response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                return res.addresses;
            }, {
                errorMessage: "Failed to create wallet account",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CREATE_WALLET_ACCOUNT_ERROR
            });
        };
        /**
         * Exports a wallet as an encrypted bundle.
         *
         * - This function exports the specified wallet and its accounts as an encrypted bundle, suitable for backup or transfer.
         * - The exported bundle contains the wallet's seed phrase, encrypted to the provided target public key.
         * - If a targetPublicKey is provided, the bundle will be encrypted to that public key; otherwise, an error will be thrown.
         * - If an organizationId is provided, the wallet will be exported under that sub-organization; otherwise, the current session's organizationId is used.
         * - Optionally allows stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * - The exported bundle can later be imported using the `importWallet` method.
         *
         * @param params.walletId - ID of the wallet to export.
         * @param params.targetPublicKey - public key to encrypt the bundle to (required).
         * @param params.organizationId - organization ID to export the wallet under a specific sub-organization (walletId must be associated with the sub-organization).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @returns A promise that resolves to an `ExportBundle` object containing the encrypted wallet seed phrase and metadata.
         * @throws {TurnkeyError} If there is no active session, if the targetPublicKey is missing, or if there is an error exporting the wallet.
         */ this.exportWallet = async (params)=>{
            const { walletId, targetPublicKey, stampWith = this.config.defaultStamperType, organizationId: organizationIdFromParams } = params;
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            const organizationId = organizationIdFromParams || session?.organizationId;
            if (!organizationId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Organization ID must be provided to export wallet", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const res = await this.httpClient.exportWallet({
                    walletId,
                    targetPublicKey,
                    organizationId: organizationId
                }, stampWith);
                if (!res.exportBundle) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No export bundle found in the response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                return res.exportBundle;
            }, {
                errorMessage: "Failed to export wallet",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].EXPORT_WALLET_ERROR
            });
        };
        /**
         * Exports a private key as an encrypted bundle.
         *
         * - This function exports the specified private key as an encrypted bundle, suitable for backup or transfer.
         * - The exported bundle contains the private key's key material, encrypted to the provided target public key.
         * - If a targetPublicKey is provided, the bundle will be encrypted to that public key; otherwise, an error will be thrown.
         * - If an organizationId is provided, the private key will be exported under that sub-organization; otherwise, the current session's organizationId is used.
         * - Optionally allows stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         *
         * @param params.privateKeyId - ID of the private key to export.
         * @param params.targetPublicKey - public key to encrypt the bundle to (required).
         * @param params.organizationId - organization ID to export the private key under a specific sub
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @returns A promise that resolves to an `ExportBundle` object containing the encrypted private key and metadata.
         * @throws {TurnkeyError} If there is no active session, if the targetPublicKey is missing, or if there is an error exporting the private key.
         */ this.exportPrivateKey = async (params)=>{
            const { privateKeyId, targetPublicKey, stampWith = this.config.defaultStamperType, organizationId: organizationIdFromParams } = params;
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            const organizationId = organizationIdFromParams || session?.organizationId;
            if (!organizationId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Organization ID must be provided to export private key", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const res = await this.httpClient.exportPrivateKey({
                    privateKeyId,
                    targetPublicKey,
                    organizationId: organizationId
                }, stampWith);
                if (!res.exportBundle) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No export bundle found in the response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                return res.exportBundle;
            }, {
                errorMessage: "Failed to export private key",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].EXPORT_PRIVATE_KEY_ERROR
            });
        };
        /**
         * Exports a wallet account as an encrypted bundle.
         *
         * - This function exports the specified wallet account as an encrypted bundle, suitable for backup or transfer.
         * - The exported bundle contains the wallet account's key material, encrypted to the provided target public key.
         * - If a targetPublicKey is provided, the bundle will be encrypted to that public key; otherwise, an error will be thrown.
         * - If an organizationId is provided, the wallet account will be exported under that sub-organization; otherwise, the current session's organizationId is used.
         * - Optionally allows stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         *
         * @param params.address - address of the wallet account to export.
         * @param params.targetPublicKey - public key to encrypt the bundle to.
         * @param params.organizationId - organization ID to export the wallet account under a specific sub-organization.
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @returns A promise that resolves to an `ExportBundle` object containing the encrypted wallet account and metadata.
         * @throws {TurnkeyError} If there is no active session, if the targetPublicKey is missing, or if there is an error exporting the wallet account.
         *
         */ this.exportWalletAccount = async (params)=>{
            const { address, targetPublicKey, stampWith = this.config.defaultStamperType, organizationId: organizationIdFromParams } = params;
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            const organizationId = organizationIdFromParams || session?.organizationId;
            if (!organizationId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Organization ID must be provided to export wallet account", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const res = await this.httpClient.exportWalletAccount({
                    address,
                    targetPublicKey,
                    organizationId: organizationId
                }, stampWith);
                if (!res.exportBundle) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No export bundle found in the response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                return res.exportBundle;
            }, {
                errorMessage: "Failed to export wallet account",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].EXPORT_WALLET_ACCOUNT_ERROR
            });
        };
        /**
         * Imports a wallet from an encrypted bundle.
         *
         * - This function imports a wallet using the provided encrypted bundle and creates accounts based on the provided parameters.
         * - If a userId is provided, the wallet will be imported for that specific user; otherwise, it uses the current session's userId.
         * - If an accounts array is provided, those accounts will be created in the imported wallet; otherwise, default Ethereum and Solana accounts will be created.
         * - The encrypted bundle MUST be encrypted to
         * - Automatically ensures an active session exists before making the request.
         * - Optionally allows stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         *
         * @param params.encryptedBundle - encrypted bundle containing the wallet seed phrase and metadata.
         * @param params.walletName - name of the wallet to create upon import.
         * @param params.accounts - array of account parameters to create in the imported wallet (defaults to standard Ethereum and Solana accounts).
         * @param params.organizationId - organization ID to import the wallet under a specific sub-organization (wallet will be associated with the sub-organization).
         * @param params.userId - user ID to import the wallet for a specific user (defaults to the current session's userId).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @returns A promise that resolves to the ID of the imported wallet.
         * @throws {TurnkeyError} If there is no active session, if the encrypted bundle is invalid, or if there is an error importing the wallet.
         */ this.importWallet = async (params)=>{
            const { encryptedBundle, accounts, walletName, organizationId: organizationIdFromParams, userId: userIdFromParams, stampWith = this.config.defaultStamperType } = params;
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            const organizationId = organizationIdFromParams || session?.organizationId;
            if (!organizationId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Organization ID must be provided to import wallet", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            const userId = userIdFromParams || session?.userId;
            if (!userId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("User ID must be provided to import wallet", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const res = await this.httpClient.importWallet({
                    organizationId: organizationId,
                    userId: userId,
                    encryptedBundle,
                    walletName,
                    accounts: accounts || [
                        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_ETHEREUM_ACCOUNTS"],
                        ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$turnkey$2d$helpers$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_SOLANA_ACCOUNTS"]
                    ]
                }, stampWith);
                if (!res || !res.walletId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No wallet ID found in the import response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                return res.walletId;
            }, {
                errorMessage: "Failed to import wallet",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].IMPORT_WALLET_ERROR,
                customErrorsByMessages: {
                    "invalid mnemonic": {
                        message: "Invalid mnemonic input",
                        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_REQUEST
                    }
                }
            });
        };
        /**
         * Imports a private key from an encrypted bundle.
         *
         * - This function imports a private key using the provided encrypted bundle.
         * - If a userId is provided, the private key will be imported for that specific user; otherwise, it uses the current session's userId.
         * - Requires address formats to
         * - Automatically infers the cryptographic curve used to generate the private key based on the address format (can be optionally overriden if needed).
         * - The encrypted bundle MUST be encrypted to ensure security.
         * - Automatically ensures an active session exists before making the request.
         * - Optionally allows stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         *
         * @param params.encryptedBundle - encrypted bundle containing the private key key material and metadata.
         * @param params.privateKeyName - name of the private key to create upon import.
         * @param params.curve - the cryptographic curve used to generate a given private key
         * @param params.addressFormat - address format of the private key to import.
         * @param params.organizationId - organization ID to import the private key under a specific sub-organization (private key will be associated with the sub-organization).
         * @param params.userId - user ID to import the wallet for a specific user (defaults to the current session's userId).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @returns A promise that resolves to the ID of the imported wallet.
         * @throws {TurnkeyError} If there is no active session, if the encrypted bundle is invalid, or if there is an error importing the wallet.
         */ this.importPrivateKey = async (params)=>{
            const { encryptedBundle, privateKeyName, addressFormats, curve, organizationId: organizationIdFromParams, userId: userIdFromParams, stampWith = this.config.defaultStamperType } = params;
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            const organizationId = organizationIdFromParams || session?.organizationId;
            if (!organizationId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Organization ID must be provided to import private key", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            const userId = userIdFromParams || session?.userId;
            if (!userId) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("User ID must be provided to import private key", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const res = await this.httpClient.importPrivateKey({
                    organizationId,
                    userId,
                    encryptedBundle,
                    privateKeyName,
                    curve,
                    addressFormats
                }, stampWith);
                if (!res || !res.privateKeyId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No wallet ID found in the import response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                return res.privateKeyId;
            }, {
                errorMessage: "Failed to import wallet",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].IMPORT_WALLET_ERROR,
                customErrorsByMessages: {
                    "invalid mnemonic": {
                        message: "Invalid mnemonic input",
                        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_REQUEST
                    }
                }
            });
        };
        /**
         * Deletes the current sub-organization (sub-org) for the active session.
         *
         * - This function deletes the sub-organization associated with the current active session.
         * - By default, the deletion will fail if any wallets associated with the sub-organization have not been exported.
         * - If `deleteWithoutExport` is set to true, the sub-organization will be deleted even if its wallets have not been exported (potentially resulting in loss of access to those wallets).
         * - Requires an active session; otherwise, an error is thrown.
         * - Optionally allows stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         *
         * @param params.deleteWithoutExport - flag to delete the sub-organization without requiring all wallets to be exported first (defaults to false).
         * @param params.organizationId - organization ID to delete a specific sub-organization (defaults to the current session's organizationId).
         * @param params.stampWith - parameter to stamp the request with a specific stamper.
         * @returns A promise that resolves to a `TDeleteSubOrganizationResponse` object containing the result of the deletion.
         * @throws {TurnkeyError} If there is no active session or if there is an error deleting the sub-organization.
         */ this.deleteSubOrganization = async (params)=>{
            const { deleteWithoutExport = false, organizationId: organizationIdFromParams, stampWith = this.config.defaultStamperType } = params || {};
            const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
            const organizationId = organizationIdFromParams || session?.organizationId;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                return await this.httpClient.deleteSubOrganization({
                    deleteWithoutExport,
                    ...organizationId && {
                        organizationId
                    }
                }, stampWith);
            }, {
                errorMessage: "Failed to delete sub-organization",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].DELETE_SUB_ORGANIZATION_ERROR
            });
        };
        /**
         * Stores a session token and updates the session associated with the specified session key, or by default the active session.
         *
         * - This function parses and stores a signed JWT session token in local storage, associating it with the given session key.
         * - If a sessionKey is provided, the session will be stored under that key; otherwise, it will use the default session key.
         * - If a session already exists for the session key, its associated key pair will be deleted before storing the new session.
         * - After storing the session, any unused key pairs are automatically cleared from storage.
         * - Ensures that session management is consistent and prevents orphaned key pairs.
         *
         * @param params.sessionToken - JWT session token to store.
         * @param params.sessionKey - session key to store the session under (defaults to the default session key).
         * @returns A promise that resolves when the session is successfully stored.
         * @throws {TurnkeyError} If there is an error storing the session or cleaning up key pairs.
         */ this.storeSession = async (params)=>{
            const { sessionToken, sessionKey = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SessionKey"].DefaultSessionkey } = params;
            if (!sessionToken) return;
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                await this.storageManager.storeSession(sessionToken, sessionKey);
            }, {
                errorMessage: "Failed to store session",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].STORE_SESSION_ERROR
            }, {
                finallyFn: async ()=>await this.clearUnusedKeyPairs()
            });
        };
        /**
         * Clears the session associated with the specified session key, or the active session by default.
         *
         * - This function deletes the session and its associated key pair from storage.
         * - If a sessionKey is provided, it will clear the session under that key; otherwise, it will clear the default (active) session.
         * - Removes the session data from local storage and deletes the corresponding API key pair from the key store.
         * - Throws an error if the session does not exist or if there is an error during the clearing process.
         *
         * @param params.sessionKey - session key to clear the session under (defaults to the default session key).
         * @returns A promise that resolves when the session is successfully cleared.
         * @throws {TurnkeyError} If the session does not exist or if there is an error clearing the session.
         */ this.clearSession = async (params)=>{
            const { sessionKey = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SessionKey"].DefaultSessionkey } = params || {};
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const session = await this.storageManager.getSession(sessionKey);
                if (session) {
                    await Promise.all([
                        this.apiKeyStamper?.deleteKeyPair(session.publicKey),
                        this.storageManager.clearSession(sessionKey)
                    ]);
                } else {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`No session found with key: ${sessionKey}`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].NOT_FOUND);
                }
            }, {
                errorMessage: "Failed to delete session",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CLEAR_SESSION_ERROR
            });
        };
        /**
         * Clears all sessions and resets the active session state.
         *
         * - This function removes all session data from the client and persistent storage, including all associated key pairs.
         * - Iterates through all stored session keys, clearing each session and deleting its corresponding API key pair.
         * - After clearing, there will be no active session, and all session-related data will be removed from local storage.
         * - Throws an error if no sessions exist or if there is an error during the clearing process.
         *
         * @returns A promise that resolves when all sessions are successfully cleared.
         * @throws {TurnkeyError} If no sessions exist or if there is an error clearing all sessions.
         */ this.clearAllSessions = async ()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const sessionKeys = await this.storageManager.listSessionKeys();
                if (sessionKeys.length === 0) return;
                for (const sessionKey of sessionKeys){
                    this.clearSession({
                        sessionKey
                    });
                }
            }, {
                errorMessage: "Failed to clear all sessions",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CLEAR_ALL_SESSIONS_ERROR
            });
        };
        /**
         * Refreshes the session associated with the specified session key, or the active session by default.
         *
         * - This function refreshes the session and updates the session token and key pair associated with the given session key.
         * - If a sessionKey is provided, it will refresh the session under that key; otherwise, it will use the current active session key.
         * - Optionally allows specifying a new expiration time for the session, a custom public key, and whether to invalidate the existing session after refreshing.
         * - Makes a request to the Turnkey API to stamp a new login and stores the refreshed session token.
         * - Automatically manages key pair cleanup and session storage to ensure consistency.
         * - Optionally allows stamping the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         *
         * @param params.sessionKey - session key to refresh the session under (defaults to the active session key).
         * @param params.expirationSeconds - expiration time in seconds for the refreshed session (defaults to the configured default).
         * @param params.publicKey - public key to use for the refreshed session (if not provided, a new key pair will be generated).
         * @param params.invalidateExisitng - flag to invalidate the existing session before refreshing (defaults to false).
         * @param params.stampWith - parameter to stamp the request with a specific stamper.
         * @returns A promise that resolves to a `TStampLoginResponse` object containing the refreshed session details.
         * @throws {TurnkeyError} If the session key does not exist, if there is no active session, or if there is an error refreshing the session.
         */ this.refreshSession = async (params)=>{
            const { sessionKey = await this.storageManager.getActiveSessionKey(), expirationSeconds = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$auth$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DEFAULT_SESSION_EXPIRATION_IN_SECONDS"], publicKey, stampWith = this.config.defaultStamperType, invalidateExisitng = false } = params || {};
            if (!sessionKey) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No session key provided or active session to refresh session", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].NO_SESSION_FOUND);
            }
            const session = await this.getSession({
                sessionKey: sessionKey
            });
            if (!session) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`No active session found: ${sessionKey}`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].NO_SESSION_FOUND);
            }
            if (!this.httpClient) {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("HTTP client is not initialized. Please initialize the client before refreshing the session.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CLIENT_NOT_INITIALIZED);
            }
            let keyPair;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                keyPair = publicKey ?? await this.apiKeyStamper?.createKeyPair();
                if (!keyPair) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Failed to create new key pair.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INTERNAL_ERROR);
                }
                const res = await this.httpClient.stampLogin({
                    publicKey: keyPair,
                    expirationSeconds,
                    invalidateExisting: invalidateExisitng
                }, stampWith);
                if (!res || !res.session) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No session found in the refresh response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                await this.storeSession({
                    sessionToken: res.session,
                    ...sessionKey && {
                        sessionKey
                    }
                });
                return res;
            }, {
                errorMessage: "Failed to refresh session",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].REFRESH_SESSION_ERROR
            });
        };
        /**
         * Retrieves the session associated with the specified session key, or the active session by default.
         *
         * - This function retrieves the session object from storage, using the provided session key or, if not specified, the current active session key.
         * - If no session key is provided and there is no active session, it returns undefined.
         * - Returns the session details, including public key, organization ID, user ID, and expiration.
         *
         * @param params.sessionKey - session key to retrieve a specific session (defaults to the current active session key).
         * @returns A promise that resolves to a `Session` object containing the session details, or undefined if not found.
         * @throws {TurnkeyError} If there is an error retrieving the session from storage.
         */ this.getSession = async (params)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const { sessionKey = await this.storageManager.getActiveSessionKey() } = params || {};
                return this.storageManager.getSession(sessionKey);
            }, {
                errorMessage: "Failed to get session with key " + params?.sessionKey,
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].GET_SESSION_ERROR
            });
        };
        /**
         * Retrieves all sessions stored in persistent storage.
         *
         * - This function fetches all session objects currently stored by the client, including those that are not active.
         * - Returns a record mapping each session key to its corresponding `Session` object.
         * - Useful for session management, auditing, or displaying all available sessions to the user.
         * - Automatically skips any session keys that do not have a valid session object.
         *
         * @returns A promise that resolves to a record of session keys and their corresponding `Session` objects, or `undefined` if no sessions exist.
         * @throws {TurnkeyError} If there is an error retrieving sessions from storage.
         */ this.getAllSessions = async ()=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const sessionKeys = await this.storageManager.listSessionKeys();
                if (!sessionKeys || sessionKeys.length === 0) {
                    return undefined;
                }
                const sessions = {};
                for (const sessionKey of sessionKeys){
                    const session = await this.storageManager.getSession(sessionKey);
                    if (session) {
                        sessions[sessionKey] = session;
                    }
                }
                return sessions || undefined;
            }, {
                errorMessage: "Failed to get all sessions",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].GET_ALL_SESSIONS_ERROR
            });
        };
        /**
         * Sets the active session to the specified session key.
         *
         * - This function updates the `activeSessionKey` in persistent storage to the specified session key.
         * - Ensures that subsequent operations use the session associated with this key as the active session.
         * - Does not validate whether the session key exists or is valid; it simply updates the pointer.
         * - Useful for switching between multiple stored sessions or restoring a previous session context.
         *
         * @param params.sessionKey - session key to set as the active session.
         * @returns A promise that resolves when the active session key is successfully set.
         * @throws {TurnkeyError} If the client is not initialized or if there is an error setting the active session key.
         */ this.setActiveSession = async (params)=>{
            const { sessionKey } = params;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                await this.storageManager.setActiveSessionKey(sessionKey);
            }, {
                errorMessage: "Failed to set active session",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].SET_ACTIVE_SESSION_ERROR
            });
        };
        /**
         * Retrieves the active session key currently set in persistent storage.
         *
         * - This function fetches the session key that is currently marked as active in the client's persistent storage.
         * - The active session key determines which session is used for all session-dependent operations.
         * - If no active session key is set, returns `undefined`.
         * - Useful for determining which session is currently in use, especially when managing multiple sessions.
         *
         * @returns A promise that resolves to the active session key as a string, or `undefined` if no active session is set.
         * @throws {TurnkeyError} If there is an error retrieving the active session key from storage.
         */ this.getActiveSessionKey = async ()=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                return await this.storageManager.getActiveSessionKey();
            }, {
                errorMessage: "Failed to get active session key",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].GET_ACTIVE_SESSION_KEY_ERROR
            });
        };
        /**
         * Clears any unused API key pairs from persistent storage.
         *
         * - This function scans all API key pairs stored in indexedDB and removes any key pairs that are not associated with a session in persistent storage.
         * - Ensures that only key pairs referenced by existing sessions are retained, preventing orphaned or stale key pairs from accumulating.
         * - Iterates through all stored session keys and builds a map of in-use public keys, then deletes any key pairs not present in this map.
         * - Intended to be called after session changes (e.g., login, logout, session replacement) to keep key storage clean and secure.
         *
         * @returns A promise that resolves when all unused key pairs are successfully cleared.
         * @throws {TurnkeyError} If there is an error listing, checking, or deleting unused key pairs.
         */ this.clearUnusedKeyPairs = async ()=>{
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const publicKeys = await this.apiKeyStamper?.listKeyPairs();
                if (!publicKeys || publicKeys.length === 0) {
                    return;
                }
                const sessionKeys = await this.storageManager?.listSessionKeys();
                const sessionTokensMap = {};
                for (const sessionKey of sessionKeys){
                    const session = await this.storageManager.getSession(sessionKey);
                    if (session) {
                        sessionTokensMap[session.publicKey] = sessionKey;
                    }
                }
                for (const publicKey of publicKeys){
                    if (!sessionTokensMap[publicKey]) {
                        try {
                            await this.apiKeyStamper?.deleteKeyPair(publicKey);
                        } catch (error) {
                            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Failed to delete unused key pair ${publicKey}`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INTERNAL_ERROR, error);
                        }
                    }
                }
            }, {
                errorMessage: "Failed to clear unused key pairs",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CLEAR_UNUSED_KEY_PAIRS_ERROR
            });
        };
        /**
         * Creates a new API key pair and returns the public key.
         *
         * - This function generates a new API key pair and stores it in the underlying key store (IndexedDB).
         * - If an external key pair is provided, it will use that key pair for creation instead of generating a new one.
         * - If `storeOverride` is set to true, the generated or provided public key will be set as the override key in the API key stamper, making it the active key for subsequent signing operations.
         * - Ensures the API key stamper is initialized before proceeding.
         * - Handles both native CryptoKeyPair objects and raw key material.
         *
         * @param params.externalKeyPair - An externally generated key pair (either a CryptoKeyPair or an object with publicKey/privateKey strings) to use instead of generating a new one.
         * @param params.storeOverride - If true, sets the generated or provided public key as the override key in the API key stamper (defaults to false).
         * @return A promise that resolves to the public key of the created or provided API key pair as a string.
         * @throws {TurnkeyError} If the API key stamper is not initialized or if there is an error during key pair creation or storage.
         */ this.createApiKeyPair = async (params)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const externalKeyPair = params?.externalKeyPair;
                const storeOverride = params?.storeOverride ?? false;
                if (!this.apiKeyStamper) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("API Key Stamper is not initialized.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INTERNAL_ERROR);
                }
                const publicKey = await this.apiKeyStamper.createKeyPair(externalKeyPair ? externalKeyPair : undefined);
                if (storeOverride && publicKey) {
                    this.apiKeyStamper.setTemporaryPublicKey(publicKey);
                }
                return publicKey;
            }, {
                errorMessage: "Failed to create API key pair",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].CREATE_API_KEY_PAIR_ERROR
            });
        };
        /**
         * Fetches the WalletKit proxy authentication configuration from the auth proxy.
         *
         * - This function makes a request to the Turnkey auth proxy to retrieve the current WalletKit configuration,
         *   including supported authentication methods, OAuth providers, and any custom proxy settings.
         * - Useful for dynamically configuring the client UI or authentication flows based on the proxy's capabilities.
         * - Ensures that the client is aware of the latest proxy-side configuration, which may affect available login/signup options.
         *
         * @returns A promise that resolves to a `ProxyTGetWalletKitConfigResponse` object containing the proxy authentication configuration.
         * @throws {TurnkeyError} If there is an error retrieving the proxy authentication configuration from the auth proxy.
         */ this.getProxyAuthConfig = async ()=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const res = await this.httpClient.proxyGetWalletKitConfig({});
                if (!res) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"](`Failed to fetch auth proxy config`, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].GET_PROXY_AUTH_CONFIG_ERROR);
                }
                return res;
            }, {
                errorMessage: "Failed to get auth proxy config",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].GET_PROXY_AUTH_CONFIG_ERROR
            });
        };
        /**
         * Fetches the boot proof for a given app proof.
         *
         * - This function is idempotent: multiple calls with the same `app proof` will always return the boot proof.
         * - Attempts to find the boot proof for the given app proof.
         * - If a boot proof is found, it is returned as is.
         * - If no boot proof is found, an error is thrown.
         *
         * @param params.appProof - the app proof for which the boot proof is being fetched.
         * @param params.organizationId - organization ID to specify the sub-organization (defaults to the current session's organizationId).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @returns A promise that resolves to the {@link v1BootProof} associated with the given app proof.
         * @throws {TurnkeyError} If there is no active session, if the input is invalid, or if boot proof retrieval fails.
         */ this.fetchBootProofForAppProof = async (params)=>{
            const { appProof, stampWith = this.config.defaultStamperType, organizationId: organizationIdFromParams } = params;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
                const organizationId = organizationIdFromParams || session?.organizationId;
                if (!organizationId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Organization ID is required to fetch a Boot Proof.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                }
                // validate their input
                if (appProof === null || appProof?.publicKey === null) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("'appProof' is required and cannot be empty.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                }
                const ephemeralKey = appProof.publicKey;
                const bootProofResponse = await this.httpClient.getBootProof({
                    organizationId,
                    ephemeralKey
                }, stampWith);
                if (!bootProofResponse || !bootProofResponse.bootProof) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("No boot proof found in the response", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].BAD_RESPONSE);
                }
                return bootProofResponse.bootProof;
            }, {
                errorMessage: "Failed to get boot proof for app proof",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].FETCH_BOOT_PROOF_ERROR
            });
        };
        /**
         * Verifies a list of app proofs against their corresponding boot proofs.
         *
         * - This function iterates through each provided app proof, fetches the corresponding boot proof, and verifies the app proof against the boot proof.
         * - If any app proof fails verification, an error is thrown.
         * @param params.appProofs - the app proofs to verify.
         * @param params.organizationId - organization ID to specify the sub-organization (defaults to the current session's organizationId).
         * @param params.stampWith - parameter to stamp the request with a specific stamper (StamperType.Passkey, StamperType.ApiKey, or StamperType.Wallet).
         * @returns A promise that resolves when all app proofs have been successfully verified.
         * @throws {TurnkeyError} If there is no active session, if the input is invalid, or if verification fails.
         */ this.verifyAppProofs = async (params)=>{
            const { appProofs, stampWith = this.config.defaultStamperType, organizationId: organizationIdFromParams } = params;
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
                const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
                const organizationId = organizationIdFromParams || session?.organizationId;
                if (!organizationId) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Organization ID is required to verify app proofs.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                }
                if (!appProofs || appProofs.length === 0) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("'appProofs' is required and cannot be empty.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                }
                let lastPublicKey;
                let lastBootProof;
                for (const appProof of appProofs){
                    if (!appProof.publicKey) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("App proof publicKey is missing.", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
                    }
                    let bootProof;
                    if (appProof.publicKey === lastPublicKey && lastBootProof) {
                        bootProof = lastBootProof;
                    } else {
                        bootProof = await this.fetchBootProofForAppProof({
                            appProof,
                            organizationId,
                            stampWith
                        });
                        lastPublicKey = appProof.publicKey;
                        lastBootProof = bootProof;
                    }
                    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$crypto$2f$dist$2f$proof$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["verify"])(appProof, bootProof); // throws if invalid
                }
            }, {
                errorMessage: "Failed to verify app proofs",
                errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].VERIFY_APP_PROOFS_ERROR
            });
        };
        this.config = config;
        // Just store any explicitly provided stampers
        this.apiKeyStamper = apiKeyStamper;
        this.passkeyStamper = passkeyStamper;
        this.walletManager = walletManager;
    // Actual initialization will happen in init()
    }
    async init() {
        // Initialize storage manager
        // TODO (Amir): StorageManager should be a class that extends StorageBase and has an init method
        this.storageManager = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$storage_$5f2f$base$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createStorageManager"])();
        // Initialize the API key stamper
        this.apiKeyStamper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$stampers_$5f2f$api$2f$base$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CrossPlatformApiKeyStamper"](this.storageManager);
        // we parallelize independent initializations:
        // - API key stamper init
        // - Passkey stamper creation and init (if configured)
        // - Wallet manager creation (if configured)
        const initTasks = [
            this.apiKeyStamper.init()
        ];
        if (this.config.passkeyConfig) {
            const passkeyStamper = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$stampers_$5f2f$passkey$2f$base$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CrossPlatformPasskeyStamper"](this.config.passkeyConfig);
            initTasks.push(passkeyStamper.init().then(()=>{
                this.passkeyStamper = passkeyStamper;
            }));
        }
        if (this.config.walletConfig?.features?.auth || this.config.walletConfig?.features?.connecting) {
            initTasks.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$wallet_$5f2f$base$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createWalletManager"])(this.config.walletConfig).then((manager)=>{
                this.walletManager = manager;
            }));
        }
        await Promise.all(initTasks);
        // Initialize the HTTP client with the appropriate stampers
        // Note: not passing anything here since we want to use the configured stampers and this.config
        this.httpClient = this.createHttpClient();
    }
    /**
     * @beta
     * **API subject to change**
     *
     * Polls Turnkey for the final result of a previously submitted Ethereum transaction.
     *
     * This function repeatedly calls `getSendTransactionStatus` until the transaction
     * reaches a terminal state.
     *
     * Terminal states:
     * - **COMPLETED** or **INCLUDED**  resolves with `{ txHash }`
     * - **FAILED** rejects with an error
     *
     * Behavior:
     *
     * - Queries Turnkey every 500ms.
     * - Stops polling automatically when a terminal state is reached.
     * - Extracts the canonical on-chain hash via `resp.eth.txHash` when available.
     *
     * @param organizationId - Organization ID under which the transaction was submitted.
     * @param sendTransactionStatusId - Status ID returned by `ethSendTransaction.
     * @param pollingIntervalMs - Optional polling interval in milliseconds (default: 500ms).
     *
     * @returns A promise resolving to `{ txHash?: string }` if successful.
     * @throws {Error | string} If the transaction fails or is cancelled.
     */ async pollTransactionStatus(params) {
        const { organizationId: organizationIdFromParams, stampWith = this.config.defaultStamperType, sendTransactionStatusId, pollingIntervalMs } = params;
        const session = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getActiveSessionOrThrowIfRequired"])(stampWith, this.storageManager.getActiveSession);
        const organizationId = organizationIdFromParams || session?.organizationId;
        if (!organizationId) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyError"]("Organization ID must be provided to fetch user", __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].INVALID_REQUEST);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withTurnkeyErrorHandling"])(async ()=>{
            return new Promise((resolve, reject)=>{
                const interval = pollingIntervalMs ?? 500;
                const timeoutMs = 60_000; // 1 minute
                const ref = setInterval(async ()=>{
                    const resp = await this.httpClient.getSendTransactionStatus({
                        organizationId,
                        sendTransactionStatusId
                    });
                    const txStatus = resp?.txStatus;
                    const txError = resp?.txError;
                    if (!txStatus) return;
                    if (txError || txStatus === "FAILED" || txStatus === "CANCELLED") {
                        // TODO: use API enum in the future
                        clearInterval(ref);
                        clearTimeout(timeoutRef);
                        reject(txError || `Transaction ${txStatus}`);
                        return;
                    }
                    if (txStatus === "COMPLETED" || txStatus === "INCLUDED") {
                        // TODO: use API enum in the future
                        clearInterval(ref);
                        clearTimeout(timeoutRef);
                        resolve(resp);
                    }
                }, interval);
                const timeoutRef = setTimeout(()=>{
                    clearInterval(ref);
                    reject(new Error("Polling timed out after 1 minute"));
                }, timeoutMs);
            });
        }, {
            errorMessage: "Failed to poll transaction status",
            errorCode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TurnkeyErrorCodes"].POLL_TRANSACTION_STATUS_ERROR
        });
    }
}
;
 //# sourceMappingURL=core.mjs.map
}),
"[project]/node_modules/@turnkey/core/dist/index.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$api$2d$key$2d$stamper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/api-key-stamper/dist/index.mjs [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$webauthn$2d$stamper$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/webauthn-stamper/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$clients_$5f2f$core$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__clients__/core.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$auth$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__types__/auth.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$enums$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__types__/enums.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$error$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__types__/error.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$_$5f$types_$5f2f$http$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/__types__/http.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$sdk$2d$types$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/sdk-types/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$turnkey$2f$core$2f$dist$2f$utils$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@turnkey/core/dist/utils.mjs [app-client] (ecmascript)"); //# sourceMappingURL=index.mjs.map
;
;
;
;
;
;
;
;
;
}),
"[project]/node_modules/@turnkey/core/dist/__types__/enums.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * StamperType defines the type of stamper to use when stamping a request.
 */ exports.StamperType = void 0;
(function(StamperType) {
    StamperType["ApiKey"] = "api-key";
    StamperType["Passkey"] = "passkey";
    StamperType["Wallet"] = "wallet";
})(exports.StamperType || (exports.StamperType = {}));
/** @internal */ exports.SessionKey = void 0;
(function(SessionKey) {
    SessionKey["DefaultSessionkey"] = "@turnkey/session/v3";
})(exports.SessionKey || (exports.SessionKey = {}));
/**
 * OtpType defines the type of OTP to use.
 */ exports.OtpType = void 0;
(function(OtpType) {
    OtpType["Email"] = "OTP_TYPE_EMAIL";
    OtpType["Sms"] = "OTP_TYPE_SMS";
})(exports.OtpType || (exports.OtpType = {}));
/** @internal */ exports.FilterType = void 0;
(function(FilterType) {
    FilterType["Email"] = "EMAIL";
    FilterType["Sms"] = "PHONE_NUMBER";
    FilterType["OidcToken"] = "OIDC_TOKEN";
    FilterType["PublicKey"] = "PUBLIC_KEY";
})(exports.FilterType || (exports.FilterType = {}));
/** @internal */ const OtpTypeToFilterTypeMap = {
    [exports.OtpType.Email]: exports.FilterType.Email,
    [exports.OtpType.Sms]: exports.FilterType.Sms
};
/** @internal */ exports.Chain = void 0;
(function(Chain) {
    Chain["Ethereum"] = "ethereum";
    Chain["Solana"] = "solana";
})(exports.Chain || (exports.Chain = {}));
/**@internal */ exports.Curve = void 0;
(function(Curve) {
    Curve["SECP256K1"] = "CURVE_SECP256K1";
    Curve["ED25519"] = "CURVE_ED25519";
})(exports.Curve || (exports.Curve = {}));
/** @internal */ exports.WalletInterfaceType = void 0;
(function(WalletInterfaceType) {
    WalletInterfaceType["Solana"] = "solana";
    WalletInterfaceType["Ethereum"] = "ethereum";
    WalletInterfaceType["WalletConnect"] = "wallet_connect";
})(exports.WalletInterfaceType || (exports.WalletInterfaceType = {}));
/** @internal */ exports.WalletSource = void 0;
(function(WalletSource) {
    WalletSource["Embedded"] = "embedded";
    WalletSource["Connected"] = "connected";
})(exports.WalletSource || (exports.WalletSource = {}));
/** @internal */ exports.SignIntent = void 0;
(function(SignIntent) {
    SignIntent["SignMessage"] = "sign_message";
    SignIntent["SignTransaction"] = "sign_transaction";
    SignIntent["SignAndSendTransaction"] = "sign_and_send";
})(exports.SignIntent || (exports.SignIntent = {}));
exports.OtpTypeToFilterTypeMap = OtpTypeToFilterTypeMap; //# sourceMappingURL=enums.js.map
}),
]);

//# sourceMappingURL=node_modules_%40turnkey_core_dist_20f972c6._.js.map